/*
 * This file is generated.  Do not edit it directly.
 * Run 'ant annotate' to regenerate it.  See tools.javascript.JSConstantApf
 */

var LookupInputElement = {
'LOOKUP_IFRAME' : "lookupIFrame",
'pLOOKUP_WIDGET' : "_lkwgt",
'DIALOG_ID' : "LookupOverlayDialog"
};

var ForecastRoleUser = {
'pUSER' : "user",
'FORECAST_SHARE_RADIO' : "forecastSharingRadios",
'pCAN_SHARE' : "allowMgrFctSharing"
};

var IFrameElement = {
'EmptyRelatedListDoc' : "emptyHtmlDoc.html",
'BLANK_SRC' : "javascript: \'\'"
};

var DetailElement = {
'DEFAULT_DETAIL_ELEMENT_ID' : "ep",
'DEFAULT_ERROR_DIV_ID' : "errorDiv_ep",
'TOP_BUTTON_ROW' : "topButtonRow",
'BOTTOM_BUTTON_ROW' : "bottomButtonRow"
};

var DatePickerIds = {
'DOM_ID' : "datePicker",
'MONTH_PICKER' : "calMonthPicker",
'TABLE_ID' : "datePickerCalendar",
'YEAR_PICKER' : "calYearPicker"
};

var BusinessHoursPageConstants = {
'p24X7_CHECKBOX' : "has24x7"
};

var TaskOwnerLookup = {
'pLOOKUP_UROG_SUFFIX' : "_lkurogid",
'DONE_BUTTON_ID' : "doneButton"
};

var EmailAuthorConstants = {
'EMAIL_ADDR_DELIM' : "; "
};

var AjaxGetFieldTreeChildren = {
'FORMULA_TYPE' : "formulaType",
'NODE_LIST' : "nodeList",
'NODE_KEY' : "nodeKey"
};

var InlineEditConstants = {
'FIELD_REQUIRED' : "required",
'MASS_EDITABLE' : "massEditable",
'VALIDATION_ERRORS' : "validationErrors",
'NULLABLE' : "nullable",
'FIELD_STATE' : "state",
'LAYOUT_INFO' : "layoutInfo",
'IS_PERSON' : "isPerson",
'FIELD_ID' : "fieldId",
'MAX_SAVE' : 200,
'COLUMN_NAME' : "columnName",
'COLUMN_ID' : "columnId",
'NON_SPECIFIC_ERRORS' : "nonSpecificErrors",
'OVERRIDE_TYPE' : "overrideType",
'ROLODEXABLE' : "useRolodex",
'SUCCESS' : "success",
'INNER_ID' : "_ileinner",
'ENTITY_ID' : "entityId",
'FIELD_VALUE' : "initialValue",
'EDITABLE' : "editable",
'LAST_MOD' : "sysMod",
'CELL_ID' : "_ilecell",
'SAVED' : "saved",
'FIELD_TYPE' : "fieldType",
'SAVE_BUTTON' : "inlineEditSave",
'FIELD_DATA' : "fields",
'IDS' : "recordIds",
'ENTITY_TYPE' : "entityType",
'CANCEL_BUTTON' : "inlineEditCancel",
'NAME_LABEL' : "nameLabel",
'SORTABLE' : "isSortable",
'COLUMN_LABEL' : "label",
'DYNAMIC_DATA' : "dynamicData"
};

var CreateNewList = {
'DHTML_ID' : "newEntityList"
};

var SetupTreeNodeConstants = {
'COOKIE_KEY' : "setupopen"
};

var CriteriaInputConstants = {
'pOP' : "critop",
'pCOL' : "critfld",
'FILTER_SECTION_ID' : "filterSection",
'pFIELD_VAL' : "critfld_val",
'pVAL' : "pVAL",
'pLOOKUP' : "pLOOKUP",
'SHOW_SUMMARY_FILTER' : "filterControl"
};

var EmailCCBccLookupConstants = {
'CC_NAME_ID' : "cc_name",
'CC_ID' : "cc",
'ADDITIONAL_TO_ID' : "additional_to",
'BCC_ADDR_ID' : "bcc_addr",
'BCC_ID' : "bcc",
'ADDITIONAL_TO_NAME_ID' : "additional_to_name",
'ADDITIONAL_TO_ADDR_ID' : "additional_to_addr",
'BCC_NAME_ID' : "bcc_name",
'REF_ID' : "ref",
'CC_ADDR_ID' : "cc_addr"
};

var SearchSettingsConstants = {
'SIDEBAR_SEARCH_ENTITY_PICKER_ID' : "enableSidebarSearchEntityPicker",
'DEFAULT_SEARCH_ENTITY_CHECKBOX_ID' : "defaultSearchEntityCheckbox",
'DEFAULT_SEARCH_ENTITY_PICKLIST_ID' : "defaultSearchEntityPicklist"
};

var MultiSelectList = {
'pIDS' : "selectedIds",
'pFILTER_TYPE' : "filterType",
'availableTableId' : "availableTable",
'availableFrameId' : "available",
'pUNSAVED_IDS' : "unsavedIds",
'pTOTAL_ROW_COUNT_FILTER' : "msl_totalRowCountFilter",
'selectedFrameId' : "selected",
'availableCheckboxPrefix' : "chk_",
'nameCellPrefix' : "name_",
'availableRowPrefix' : "row_",
'allOrNoneCheckbox' : "allOrNone",
'pTOTAL_ROW_COUNT' : "msl_totalRowCount",
'selectedCheckboxPrefix' : "uch_",
'listEmptyLabelId' : "listEmptyLabel",
'selectionsTableId' : "selections",
'selectedRowPrefix' : "sel_",
'selectLabelId' : "selectLabel",
'deselectLabelId' : "deselectLabel"
};

var BlowoutServlet = {
'SUCCESS' : "success",
'BLOWOUT' : "blowout",
'SUFFIX' : "suf",
'SERVLETURL' : "/_ui/system/scheduler/cron/ScheduleBlowoutServlet"
};

var AjaxLoadPLAServlet = {
'TYPE' : "type",
'PAGE_SIZE' : "pageSize"
};

var FilterEditPageConstants = {
'pSEARCH_ANCHOR' : "searchAnchor"
};

var InlineHelp = {
'CLASS_NAME' : "helpButton",
'ORB' : "helpOrb",
'DISPLAY_DIV_CLASS' : "helpText",
'CLASS_NAME_HOVER' : "helpButtonOn",
'ID_SUFFIX' : "_help"
};

var SchedulePage = {
'pNotifyMe' : "nm",
'pBlowout' : "bout",
'pNotifyOthers' : "no",
'pJobType' : "jt",
'pDuelOuter' : "duelOuter",
'pDUEL' : "duel",
'pEmailUrog' : "eurog"
};

var ListView = {
'CHECKBOX_ID' : "ids",
'DEFAULT_ROWS_PER_PAGE' : 50,
'ID_COLUMN' : "LIST_RECORD_ID",
'SELECT_ALL_BOX_ID' : "allBox",
'ACTION_COLUMN' : "ACTION_COLUMN"
};

var TagConstants = {
'TAG_EDIT_LIST' : "tag_edit_list",
'BROWSER_SEARCH_HEADER_CLASS' : "pbTagBrowserSearch",
'TAG_DROP_DOWN_CONTENTS_ID' : "tag_drop_down_contents",
'BROWSER_LIST_ID' : "browseTags",
'BROWSER_TAG_TABLE_ID' : "browseTagsTable",
'EDIT_AREA_ID' : "tag_edit_area",
'TAG_DISPLAY_CONTAINER' : "tag_display_container",
'TAG_RESULTS_ID' : "tagResults",
'TAG_VALUE_FOR_UPDATE' : "tValForUpdate",
'ROLODEX_SEARCH_VALUE' : "-10",
'HIDING_PUBLIC_SECTION_ID' : "layoutPublicEditSection",
'CHANGE_TAGS_NAMES' : "changeTagsNames",
'TAG_SEARCH_FIELD' : "tagsSearch",
'TAG_MERGE_CHECK' : "/ui/tag/TagMergeCheckServlet",
'ERROR_DIV_ID' : "tagHomeErrorDiv",
'TAG_RESULTS_BODY_ID' : "tagListBody",
'TAG_EDIT_ERROR_ID' : "tag_edit_error",
'TAG_DROP_DOWN_ID' : "tag_drop_down",
'LOOKUP_TAGS_PAGE' : "/ui/tag/LookupTagsPage",
'TAG_ID_LIST' : "tIdList",
'TAG_HEADER' : "tag_header",
'TAG_SEARCH_RESULTS_URL' : "/search/TagSearchResults",
'SAVED_TAG_SEARCH' : "savedTagSearch",
'EDIT_SECTION_ID' : "editSectionId",
'NOTIFY_MSG_ID' : "successNotifyId",
'PUBLIC_TAG_IDS_ELEM' : "pTagIds",
'TAG_SAVE_ID' : "tag_save",
'HIDING_SECTION_ID' : "layoutEditSection",
'TAG_SUMMARY_ID' : "tagSummary",
'PUBLIC_TAG_NAMES_ELEM' : "pTagNames",
'TAG_DISPLAY_LIST' : "tag_display_list",
'TAG_ROLODEX_ID' : "tagRolodexId",
'TAG_SET_HAS_RECORDS' : "tagSetHasRecords",
'CHANGE_TAGS_IDS' : "changeTagsIds",
'HIDDEN_TAG_LIST' : "hidden_tag_list",
'TAG_IDS_ELEM' : "tagIds",
'SAVE_TAGS_PAGE' : "/ui/tag/SaveTagsPage",
'HIDDEN_TAG_ID_LIST' : "hidden_tag_id_list",
'TAG_UPDATE_STRING' : "tagUpdate",
'TAG_EDIT_ID' : "tag_edit",
'TAG_NAMES_ELEM' : "tagNames",
'EDIT_TAGS_PAGE' : "/ui/tag/TagsEditPage",
'pTAG_SCOPE_MODE' : "scopeMode",
'TAG_EDIT_TEXT_ID' : "tag_edit_text",
'IS_DELETE' : "isDelete",
'TAG_CANCEL_ID' : "tag_cancel"
};

var BounceEmailConstants = {
'HIDDEN_BOUNCE_DATE' : "hidden_bounce_date",
'HIDDEN_EMAIL_ADDRESS' : "hidden_email_address",
'HIDDEN_BOUNCE_REASON' : "hidden_bounce_reason"
};

var RequestInfo = {
'pSID' : "sid"
};

var LookupsUi = {
'LOOKUPS' : "lookups",
'FIELD' : "field",
'PATH' : "path"
};

var CrtLookupConstants = {
'LOOKUP_HEADER' : "lookupInnerHeader",
'CONTROL_ELEM_1' : "controlLinks1",
'LOOKUP_DEPTH_LIMIT' : 4,
'LOOKUP_ELEM' : "lookupBox",
'PATH_ELEM' : "pathBox"
};

var StageManager = {
'pWIZARD_RET_URL' : "wizardRetUrl"
};

var MouseOverElement = {
'DEFAULT_CLASS_INNER' : "mouseOverInfo",
'DEFAULT_CLASS' : "mouseOverInfoOuter"
};

var ActivityReminderPage = {
'pCLASS_NAME' : "ui.core.activity.ActivityReminderPage"
};

var ActivityReminderConstants = {
'pTEST' : "test",
'DISMISS_ID' : "dismiss",
'SUMMARY_ID' : "summary",
'SNOOZE_TIME_ID' : "snooze_time",
'DUE_MINUTES_ID' : "minutes",
'ALL_DAY_ATTR' : "all_day",
'DUE_TIME_ATTR' : "due_time",
'DISMISS_ALL_ID' : "dismiss_all",
'SNOOZE_ID' : "snooze",
'pAT' : "at",
'REMINDERS_OK' : "reminders_ready",
'pSNOOZED_AT' : "snoozed_at",
'REMINDER_ID' : "reminder",
'REMINDERS_NONE' : "reminders_none_active"
};

var ForecastSettings = {
'pFORECAST_SHARING' : "forecastSharing",
'pALLOW_FM_SHARING' : "allowFMSharing"
};

var ColorInputConstants = {
'COLOR_BOX_CSS' : "colorBox",
'ERROR_COLOR_BOX_CSS' : "errorColorBox"
};

var AdvancedCurrencyEnable = {
'pENABLE' : "enable",
'enableButton' : "enableButton"
};

var AjaxLoadPLAForRecordTypeServlet = {
'RECORD_TYPE_ID' : "rtId"
};

var AjaxLoadPLAForPageServlet = {
'PAGE_NUM' : "pageNum"
};

var CustomMotifDefinitionPageConst = {
'MOTIF_ICON_PARAM' : "file_id",
'COLOR_ELEMENT' : "ce"
};

var DeveloperSettings = {
'LICENSE_MGR_CHOICE_STR' : "licenseMgr"
};

var ReportsFch = {
'FLOATING_HEADER' : "floatingHeader",
'HEADER_ROW' : "headerRow",
'FCH_AREA' : "fchArea"
};

var UiData = {
'pCANCEL_URL' : "cancelURL",
'pRET_URL' : "retURL",
'pSAVE_URL' : "saveURL"
};

var SetupSearchElement = {
'ATT_SEARCH_TEXT' : "searchText",
'SETUP_SEARCH_PARAM' : "setupSearch"
};

var DurationInputElement = {
'pMINUTES_NAME' : "mi",
'pHOURS_NAME' : "hh"
};

var CompactLayoutUiConst = {
'showItemsLeft' : "showItemsLeft",
'showItemsRight' : "showItemsRight",
'switchColumnToLeft' : "switchColumnLeft",
'hideItemsLeft' : "hideItemsLeft",
'hideItemsRight' : "hideItemsRight",
'switchColumnToRight' : "switchColumnRight",
'saveButtonId' : "saveButton"
};

var MotifInputElementConst = {
'FIELD_NAME_MOTIF' : "motifName",
'MOTIF_ELEMENT_SUFFIX' : "motifElement",
'FIELD_NAME_ICON' : "motifIcon",
'FIELD_NAME_DESCRIPTION' : "motifClass"
};

var DesktopSidebarComponents = {
'GOOGLETALK_CONTAINER_ID' : "googleTalk",
'SOFTPHONE_CONTAINER_ID' : "softphoneContainer",
'MRU_LIST_CONTAINER_ID' : "mruList"
};

var EventObject = {
'ONE_DAY_IN_MINUTES' : 1440
};

var MultiLookupInputElement = {
'MULTI_LOOKUP_SELECT_SUFFIX' : "_mlktp"
};

var SoftphoneLayoutEditorConstants = {
'RESULT_FIELDS_KEY' : "resultFields",
'CALL_TYPE_PREFIX' : "callType_",
'XSLT_RELATED_OBJS_CSS' : "relatedObjects",
'HIDDEN_IFRAME_ID' : "previewIframe",
'FLIPPY_PREFIX' : "flippy_",
'CALL_TYPE_PREVIEW_PREFIX' : "callTypePreview_",
'FIRST_FLIPPY_CSS' : "firstFlippy",
'FLIPPY_CONTROL_PREFIX' : "control_",
'XSLT_INFO_FIELDS_CSS' : "infoFields",
'LISTING_PREFIX' : "listing_"
};

var ForecastSummaryPage = {
'pLOOKUP_INPUT_ENTERED' : "lookupEntered"
};

var vaSelectElementConst = {
'UP_CLASS' : "up",
'DOWN_CLASS' : "down"
};

var MCXHRParams = {
'pLoadObjId' : "LOI",
'pIsSuccess' : "isSuccess",
'pTestResultRecordCount' : "recordCount",
'pSaveObjParentId' : "SPI",
'pTestResultDataSize' : "dataSize",
'pScope' : "scope",
'pLoadObjType' : "LOT",
'pTotalsElement' : "totalsElement",
'pTestResultConfigError' : "configError",
'pCollisionParam' : "LMT",
'pData' : "data",
'pSaveObjId' : "SOI",
'pQSTestResults' : "qsTestResults",
'pTestResultQSID' : "id",
'pAction' : "ACT",
'pSaveObjType' : "SOT",
'pFilterItemCount' : "itemCount"
};

var TagMode = {
'PUBLIC' : "public",
'PERSONAL' : "personal"
};

var AjaxValidateFormula = {
'RANGE_KEY' : "range",
'VALID_KEY' : "valid"
};

var CrtLayoutElement = {
'cFIELD_IN_SECTION' : "#CCCCCC",
'pVALUE' : "val",
'SECTION_NAME' : "name",
'SECTION_CAN_EDIT_LABEL' : "canEditLabel",
'MAX_DISPLAY_FIELD_LENGTH' : 15,
'cFIELD_USED_FONT' : "#B0B0B0",
'CSS_CLASS_LAYOUT_ITEM_SEPARATOR' : "sepCell",
'LAYOUT_NAME' : "name",
'pSAVE_AND_CLOSE' : "saveAndClose",
'ACTIONREF_NAME' : "name",
'COLUMN_NAME' : "columnName",
'LAST_SEC_SEP_DIV' : "LAST_SEC_SEP_DIV",
'SECTION_SORT_ORDER_HORIZONTAL' : "h",
'cSEPARATOR_ON' : "#000000",
'SECTION_NUM_COLUMNS' : "numColumns",
'SECTION_SORT_ORDER' : "sortOrder",
'cFIELD_UNUSED' : "#CCCCAA",
'cFIELD_SELECTED' : "#6699CC",
'SECTION_DIV_SUFFIX' : "availSectionDiv",
'ITEM_CUSTOMLABEL' : "customLabel",
'ACTIONREF' : "actionRef",
'ITEM_LAYOUT_IDS' : "lIds",
'CSS_CLASS_LAYOUT_ITEM' : "itemCell",
'ITEM_BEHAVIOR' : "behavior",
'SECTION_HEADER_ID_PREFIX' : "sec_",
'ITEM_NAME' : "name",
'ITEM_POS_X' : "xPos",
'XML_FORM_NAME' : "submitForm",
'SCROLL_BUFFER_ID' : "scrollBuffer",
'cFIELD_EMPTY' : "#FFFFFF",
'LAYOUT_FIELDS_LIMIT' : 1000,
'SECTION_MASTER_LABEL' : "masterLabel",
'SECTION_TABLE_ID_PREFIX' : "table",
'ITEM_HEIGHT' : "height",
'SECTION_ID' : "sectionId",
'ITEM_WIDTH' : "width",
'COLUMN_ID' : "columnId",
'DEFAULT_NUM_COLS' : "defaultNumCols",
'HOVER_DIV' : "MOUSE_HOVER_DIV",
'SECTION_EDIT_HEADING' : "editHeading",
'cAVAILABLE_HIGHLIGHT' : "#000000",
'MAIN_TABLE_DIV_ID' : "mainTableDiv",
'ITEM' : "item",
'ITEM_ID' : "itemId",
'SECTION_SEP_DIV_PREFIX' : "LayoutSectionSeparator_",
'ACTIONREF_ORDER' : "order",
'NUM_LAYOUT_COLS' : 4,
'FIELD_TYPE_SELECT_NAME' : "availableDropDown",
'SEPARATOR_PREFIX' : "rp_",
'SECTION' : "section",
'CSS_CLASS_LAYOUT_CELL' : "layoutCell",
'cFIELD_USED' : "#EEEEEE",
'SECTION_AVAIL_WRAPPER_ID' : "availableSectionWrapper",
'ITEM_DEFAULT_CHECKED' : "defaultChecked",
'AVAIL_CELL' : "availCell",
'ITEM_SHOWLABEL' : "showLabel",
'ITEM_SHOWSCROLLBARS' : "showScrollbars",
'LEFT_SECTION_ID' : "layoutdndLeft",
'COLUMN' : "column",
'ITEM_TYPE' : "itemType",
'SECTION_DETAIL_HEADING' : "detailHeading",
'ROOT_CONTAINER' : "root"
};

var MailmergeTemplateSelectElementConst = {
'TEMPLATE_DESCRIPTION' : "mmtse_description",
'TEMPLATE_VIEW_BUTTON' : "mmtse_preview",
'TEMPLATE_ID' : "mmtse_id",
'TEMPLATE_TITLE' : "mmtse_title"
};

var GoogleDocCreator = {
'DOC_NAME' : "docName",
'DOC_TYPE' : "docType",
'PARENT_ID' : "parentId"
};

var FilterSelectionElement = {
'pCOLUMN' : "col",
'ON_LOAD_CRITERIA' : "onLoadCriteria",
'pOPERATOR' : "oper",
'pFILTER_VALUE' : "fval"
};

var TaskUi = {
'ASSIGNEE_SEPARATOR' : ",",
'pLOOKUP_BUTTON_MULTI_OWNER_SUFFIX' : "m",
'pSHOW_PREFERENCE' : "show_pref",
'MAX_TMU_ASSIGNEES' : 100,
'pNOTIFY_PREFERENCE_GROUP_ELEMENT' : "prefEl",
'pMAX_ASSIGNEE_TEXT_LENGTH' : 200,
'pLOOKUP_SUMMARY_SUFFIX' : "_sum",
'pLOOKUP_DISPLAY_SUFFIX' : "_dsp"
};

var DynamicContent = {
'pTYME' : "tyme",
'pERROR_TITLE' : "errorTitle",
'pCOOKIE_PARAM' : "cookieParam",
'pERROR_DESC' : "errorDesc"
};

var TimePickerInputElementConstants = {
'EMPTY_TIME_STANDIN' : "HH:MM"
};

var RoleTreeCookieConstants = {
'COOKIE_KEY' : "roleopen"
};

var HTPortal = {
'pORG_ID' : "orgId",
'pID' : "id",
'pTRACK' : "track",
'pTARGET' : "target",
'pCLASS_NAME' : "cname",
'pSECTION' : "section",
'pCLASS_DAY' : "R_DAY",
'pSELECT_LOCATION' : "sel_loc",
'pBODY' : "body",
'pLOCATION' : "loc",
'pFEATURE' : "feature"
};

var EditPageConstants = {
'pCANCEL' : "cancel",
'pEDIT_PAGE' : "editPage",
'pSAVE_CLOSE' : "save_close",
'pSAVE_ATTACH' : "save_attach",
'pSAVE_NEW_URL' : "save_new_url",
'pSAVE_NEW' : "save_new",
'pSAVE' : "save",
'pQUICK_SAVE' : "quick_save"
};

var EventUi = {
'ALL_SUBGROUP_DIVS' : "dwmy",
'REMINDER_DATE_TIME_ID' : "reminder_dt",
'pADD_INVITEE_ID' : "addInvId",
'REMINDER_SELECT_ID' : "reminder_lt",
'REMINDER_SET_ID' : "reminder_select_check",
'pONLINE_MEETING' : "onlinemtg",
'pONLINE_HOVER' : "olmhov",
'pISPERSONACCOUNT' : "pip",
'RECURRENCE_PATTERN_DIV' : "recpat"
};

var EmailAddrEditConstants = {
'pSAVE_CANCEL' : "saveCancel",
'pPASS_IN_EMAIL_ADDRESS' : "pass_in_email_address"
};

var EventPage = {
'DISABLED_RECURRENCE_MSG_DIV' : "DisabledRecurrenceMsgDiv",
'CALENDAR_IFRAME_ID' : "calendarIFrame"
};

var MenuButtonElement = {
'BUTTON' : "Button",
'GO_BUTTON' : "Go",
'MENU' : "Menu",
'SELECT' : "Select"
};

var CrtConstants = {
'PICKLIST_VALUE_TABLE_FIELD_SEPARATOR' : '.',
'OBJECT_PREFIX' : "o",
'MAX_OBJECTS' : 4,
'PICKLIST_VALUE_ID_SEPARATOR' : '|'
};

var Activity = {
'WHO_BUTTON_ID' : "whobtn",
'pNEW_ATTACHMENTS' : "newatt",
'pATT_WARNING' : "attWarning"
};

var ColorPickerConstants = {
'HEX_VIEW_ID' : "colorPickerHexView",
'DOM_ID' : "colorPicker",
'COLOR_VIEW_ID' : "colorPickerColorView"
};

var CrtObjectElement = {
'TERMINAL_OBJECT_WARNING' : "endWarning",
'REMOVE_OBJECT_LINK' : "remove",
'INNER_JOIN_SELECT' : "inner_select",
'GHOST1' : "ghost1",
'MAX_OBJECTS_WARNING' : "warning",
'LEVEL' : "level",
'ELBOW_INNER' : "elbow_inner",
'ELBOW_OUTER' : "elbow_outer",
'EST_OBJECT_LABEL' : "estObjLabel",
'JOIN_RADIO' : "radio",
'INNER_JOIN_OPTION' : "inner_join_option",
'GHOST_ELBOW' : "ghost_elbow",
'GHOST0' : "ghost0",
'OUTER_JOIN_SELECT' : "outer_select"
};

var MCFilterPaneParams = {
'pORDER_BY_DIV' : "orderBySection",
'pNO_LIMIT' : "noLimit",
'pMAX_RECORD_RADIO' : "maxRecordRadio",
'pSCOPE' : "ofscope",
'pSET_LIMIT' : "setLimit",
'NONE_SCOPE_VALUE' : "-1"
};

var BodyLayout = {
'FOOTER_DIV_ID' : "bodyFooter",
'PAGE_HEADER_ID' : "AppBodyHeader",
'BODY_CELL_ID' : "bodyCell",
'BODY_TABLE_ID' : "bodyTable"
};

var JSPDispatcher = {
'STANDARD_PACKAGE' : "ui",
'NONSTANDARD_PACKAGE_PREFIX' : "_ui/",
'PACKAGE_MARKER' : "p/"
};

var AjaxServlet = {
'CSRF_PROTECT' : "while(1);\n",
'ERROR_MSG_KEY' : "errMsg"
};

var ActivityReminderRefreshPage = {
'pCLASS_NAME' : "ui.core.activity.ActivityReminderRefreshPage"
};

var RuleFilterPageConstants = {
'NO_REASSIGN_SUFFIX' : "_noReassign"
};

var FieldTreeConstants = {
'SELECT_ID' : "FieldTreeSelect"
};

var Udd = {
'EMPTY_KEY' : "000000000000000"
};

var ProfileEditConstants = {
'CRUD_DELETE' : "crudDelete",
'CRUD_UPDATE' : "crudUpdate",
'CRUD_CREATE' : "crudCreate",
'CRUD_READ' : "crudRead"
};

var CaptchaVerifierServlet = {
'RESPONSE_PARAM' : "resp",
'SERVLET_NAME' : "common.html.captcha.CaptchaVerifierServlet",
'VALID_KEY' : "valid",
'CLIENT_ERROR_PARAM' : "error",
'CHALLENGE_PARAM' : "chal"
};

var AbstractAutoCompleteServlet = {
'AUTOCOMPLETE_USED_SUFFIX' : "_acused",
'pINPUT' : "inputString"
};

var EditEventMultiUserCalendarElementConstants = {
'EDIT_PAGE_CALENDAR' : "editEventCalendar"
};

var SearchRelatedList = {
'FILTER_FIELDS_PARAM' : "sFltrFields",
'ALL_STATES_PREFIX' : "allStates_",
'SearchUserLayoutServletName' : "UserSearchListLayout",
'COMBO_BUTTON_ID' : "comboButton",
'SearchFilterInfoServletName' : "SearchFilterInfo",
'COLUMN_SELECTOR_PREFIX' : "selector_",
'LIST_LAYOUT_TYPE_PARAMETER' : "layoutType",
'SEARCH_ACTION_IDENTIFIER_PARAM' : "aId",
'COLUMN_PARAMETER' : "columns",
'pSEARCH' : "search",
'pSEARCH_STR' : "str",
'ENTITY_PARAMETER' : "entity",
'SEARCH_IDENTIFIER_PARAM' : "searchId",
'PER_ENTITY_VALUE' : "perEntityValue",
'FILTER_FIELDS_SAVE_PREFIX' : "save_filter_",
'pENTITY_ALL' : "0",
'ShouldNotLookUp' : "noLookUp",
'FILTER_FIELD_FORM_PREFIX' : "field_name_form_",
'FILTER_FIELDS_PREFIX' : "field_name_"
};

var AjaxGetUsersInGroups = {
'pOWNER_ID_LIST' : "ownerIdList",
'pCLASS_NAME' : "common.ownership.group.AjaxGetUsersInGroups",
'pNUM_USERS' : "numUsers",
'pINVALID_GROUPS_MESSAGE' : "invalidGroups",
'pOWNER_NAME_LIST' : "ownerNameList"
};

var SidebarConstants = {
'HANDLE_ID' : "handle",
'SIDEBAR_PINNED_COOKIE' : "sidebarPinned",
'pSEARCH_SIDEBAR_STR' : "sbstr",
'PIN2_INDICATOR_ID' : "pinIndicator2",
'PIN_INDICATOR_ID' : "pinIndicator",
'SIDEBAR_DIV_ID' : "sidebarDiv"
};

var ColumnTypeConstants = {
'PERSONNAME_LASTNAME_OFFSET' : 2,
'PERSONNAME_FIRSTNAME_OFFSET' : 1,
'DEFAULT_STATE_LENGTH' : 20,
'ADDRESS_STREET_OFFSET' : 0,
'DEFAULT_CITY_LENGTH' : 40,
'PERSONNAME_SALUTATION_OFFSET' : 0,
'DEFAULT_ZIP_LENGTH' : 20,
'DEFAULT_SALUTATION_LENGTH' : 40,
'ADDRESS_POSTAL_CODE_OFFSET' : 3,
'DEFAULT_LASTNAME_LENGTH' : 80,
'DEFAULT_FIRSTNAME_LENGTH' : 40,
'DEFAULT_COUNTRY_LENGTH' : 40,
'ADDRESS_COUNTRY_OFFSET' : 4,
'ADDRESS_CITY_OFFSET' : 1,
'ADDRESS_STATE_OFFSET' : 2,
'DEFAULT_TEXTNAME_LENGTH' : 255,
'DEFAULT_STREET_LENGTH' : 255
};

var Desktop = {
'AgentConsoleY' : "AgentConsoleY",
'AgentConsoleS' : "AgentConsoleS",
'pGOTO_ID' : "goToId",
'RESIZE_WIDTH' : "resizeWidth",
'pGOTO_URL' : "goToUrl",
'AgentConsoleX' : "AgentConsoleX",
'BROWSER_MAX_URL' : "2048",
'AgentConsoleFE' : "AgentConsoleFE",
'SIDEBAR_NORMAL_WIDTH_STYLE_PX' : "200",
'IS_DESKTOP' : "isdtp"
};

var EditElement = {
'FIELD_NAME_LAST' : "name_last",
'pOLD_NAME_SUFFIX' : "_lkold",
'SELECTED_ID_SUFFIX' : "_selected",
'FIELD_NAME_ZIP' : "zip",
'pBASE_NAME' : "lknm",
'pTYPE_SUFFIX' : "_lktp",
'FIELD_NAME_SALUTATION' : "name_salutation",
'FIELD_NAME_CITY' : "city",
'FIELD_NAME_COUNTRY' : "country",
'pID_SUFFIX' : "_lkid",
'STREET_NUM_COLS' : 27,
'FIELD_NAME_FIRST' : "name_first",
'FIELD_NAME_STREET' : "street",
'FIELD_NAME_STATE' : "state",
'CHECKBOX_SUFFIX' : "_chkbox",
'STREET_NUM_ROWS' : 2,
'ERROR_CLASS' : "error",
'UNSELECTED_ID_SUFFIX' : "_unselected"
};

var EmailRelayConstants = {
'EMAIL_RELAY_TLS_SETTING_ID' : "email_relay_tls_setting",
'RESTRICT_TO_DOMAINS_ID' : "restrict_to_domains",
'ACTIVATE_RESTRICT_TO_DOMAINS_ID' : "activate_restrict_to_domains",
'EMAIL_HOST_PORT_ID' : "email_host_port",
'EMAIL_HOST_ID' : "email_host",
'ACTIVATE_EMAIL_RELAY_ID' : "activate_email_relay",
'RESTRICT_TO_DOMAINS_HIDDEN_ID' : "restrict_to_domains_hidden"
};

var ReportConstants = {
'pSubTotalBy0' : "subtotalBy0"
};

var BrowserSettingsWarningElement = {
'NEVER_SHOW_AGAIN_ID' : "browserSettingsWarningGoAway",
'cBrowserSettings' : "numReqs",
'BROWSER_SETTINGS_WARNING_ID' : "browserSettingsWarning",
'MORE_INFO_ID' : "browserSettingsWarningMoreInfo"
};

var CreateNewElement = {
'DOM_ID' : "createNew"
};

var ForecastSharingPrefPopup = {
'CAN_SHARE_RADIO' : "enableRadio",
'pIS_FCT_SHARE_ENABLED' : "isFctShareEnabled",
'DISABLE_CHECKBOX' : "disableCheckbox"
};

var SummaryFieldConstants = {
'OPERATION_CONTAINER_ID' : "operationCtr"
};

var ScheduleElement = {
'pPrefTimeDiv' : "prefTime",
'pPrefTimeLabelDiv' : "prefTimeLabel",
'pDailyEveryNDays' : "dn",
'pMonthlyOnDayN' : "mdom",
'pPrefTime' : "pst",
'pEndDate' : "end",
'pStartDate' : "start",
'pPrefTimeLoadingDiv' : "prefTimeLoad",
'pFreq' : "freq",
'pMonthlyOnNthDay' : "mond",
'pDailyRec' : "dr",
'pOtherPrefTimeLabelDiv' : "otherPrefTimeLabel",
'pDayOfWeek' : "ww",
'pOuterBox' : "outerBox",
'pMonthlyRec' : "mr",
'pMonthlyOnNDayOfWeek' : "mdn"
};

var GoogleTalkConstants = {
'MIN_EXPANDED_HEIGHT' : 22,
'EXPANDED_HEIGHT' : 400,
'HEIGHT_COOKIE' : "gTalkHeight",
'COLLAPSED_HEIGHT' : 0,
'COLLAPSED_COOKIE' : "gTalkCollapsed"
};

var PortalStyleConfigEditorConstants = {
'PARAM_PREFIX' : "p_"
};

var AjaxLoadFieldsForEntity = {
'pFIELD_LIST' : "fieldList",
'pENTITY_NAME' : "entity",
'pPARENT_ENTITY_NAME' : "parentEntity"
};

var TaskMassAction = {
'ROW_LIMIT' : 200
};

var ManageableInfo = {
'MORE_INFO_CLASS' : "manageableMoreInfo",
'DHTML_ID' : "manageableInfo"
};

var ColumnType = {'ANYTYPE':{'inlineEditFieldObject':null,'isCompond':false,'queryOperators':null,'inlineEditFieldConstructor':null,'datatypeLetter':'K','filterQueryOperators':null,'isNumber':false,'needsLookup':false,'inlineEditable':false,'inlineEditExtraData':null,'isDate':false}
,'AUTONUMBER':{'inlineEditFieldObject':'TextField','isCompond':false,'queryOperators':['e','n','l','g','m','h','c','k','s','i'],'inlineEditFieldConstructor':function(){return TextField;},'datatypeLetter':'V','filterQueryOperators':['e','n','c','k','s'],'isNumber':false,'needsLookup':false,'inlineEditable':true,'inlineEditExtraData':null,'isDate':false}
,'SUMMARY':{'inlineEditFieldObject':null,'isCompond':false,'queryOperators':null,'inlineEditFieldConstructor':null,'datatypeLetter':'1','filterQueryOperators':null,'isNumber':false,'needsLookup':false,'inlineEditable':false,'inlineEditExtraData':null,'isDate':false}
,'PERCENT':{'inlineEditFieldObject':'NumberField','isCompond':false,'queryOperators':['e','n','l','g','m','h'],'inlineEditFieldConstructor':function(){return NumberField;},'datatypeLetter':'P','filterQueryOperators':['e','n','l','g','m','h'],'isNumber':true,'needsLookup':false,'inlineEditable':true,'inlineEditExtraData':null,'isDate':false}
,'BLOB':{'inlineEditFieldObject':null,'isCompond':false,'queryOperators':null,'inlineEditFieldConstructor':null,'datatypeLetter':'X','filterQueryOperators':null,'isNumber':false,'needsLookup':false,'inlineEditable':false,'inlineEditExtraData':null,'isDate':false}
,'FAX':{'inlineEditFieldObject':'PhoneField','isCompond':false,'queryOperators':['e','n','l','g','m','h','c','k','s','i'],'inlineEditFieldConstructor':function(){return PhoneField;},'datatypeLetter':'G','filterQueryOperators':['e','n','c','k','s'],'isNumber':false,'needsLookup':false,'inlineEditable':true,'inlineEditExtraData':['maxLength','formatPhone'],'isDate':false}
,'DOUBLE':{'inlineEditFieldObject':'NumberField','isCompond':false,'queryOperators':['e','n','l','g','m','h'],'inlineEditFieldConstructor':function(){return NumberField;},'datatypeLetter':'N','filterQueryOperators':['e','n','l','g','m','h'],'isNumber':true,'needsLookup':false,'inlineEditable':true,'inlineEditExtraData':null,'isDate':false}
,'STATICENUM':{'inlineEditFieldObject':'StaticEnumField','isCompond':false,'queryOperators':['e','n','l','g','m','h','c','k','s','i'],'inlineEditFieldConstructor':function(){return StaticEnumField;},'datatypeLetter':'L','filterQueryOperators':['e','n','c','k','s'],'isNumber':false,'needsLookup':true,'inlineEditable':true,'inlineEditExtraData':['picklistData'],'isDate':false}
,'CURRENCYCODE':{'inlineEditFieldObject':'StaticEnumField','isCompond':false,'queryOperators':['e','n','l','g','m','h','c','k','s','i'],'inlineEditFieldConstructor':function(){return StaticEnumField;},'datatypeLetter':'L','filterQueryOperators':['e','n','c','k','s'],'isNumber':false,'needsLookup':false,'inlineEditable':true,'inlineEditExtraData':['picklistData'],'isDate':false}
,'TEXTENUM':{'inlineEditFieldObject':'TextField','isCompond':false,'queryOperators':['e','n','l','g','m','h','c','k','s','i'],'inlineEditFieldConstructor':function(){return TextField;},'datatypeLetter':'L','filterQueryOperators':['e','n','c','k','s'],'isNumber':false,'needsLookup':false,'inlineEditable':true,'inlineEditExtraData':['maxLength'],'isDate':false}
,'ADDRESSCOUNTRY':{'inlineEditFieldObject':'TextField','isCompond':false,'queryOperators':['e','n','l','g','m','h','c','k','s','i'],'inlineEditFieldConstructor':function(){return TextField;},'datatypeLetter':'S','filterQueryOperators':['e','n','c','k','s'],'isNumber':false,'needsLookup':false,'inlineEditable':true,'inlineEditExtraData':['maxLength'],'isDate':false}
,'EMAIL':{'inlineEditFieldObject':'TextField','isCompond':false,'queryOperators':['e','n','l','g','m','h','c','k','s','i'],'inlineEditFieldConstructor':function(){return TextField;},'datatypeLetter':'E','filterQueryOperators':['e','n','c','k','s'],'isNumber':false,'needsLookup':false,'inlineEditable':true,'inlineEditExtraData':['maxLength'],'isDate':false}
,'PHONE':{'inlineEditFieldObject':'PhoneField','isCompond':false,'queryOperators':['e','n','l','g','m','h','c','k','s','i'],'inlineEditFieldConstructor':function(){return PhoneField;},'datatypeLetter':'H','filterQueryOperators':['e','n','c','k','s'],'isNumber':false,'needsLookup':false,'inlineEditable':true,'inlineEditExtraData':['maxLength','formatPhone'],'isDate':false}
,'ENTITYID':{'inlineEditFieldObject':'ForeignKeyField','isCompond':false,'queryOperators':['e','n','s'],'inlineEditFieldConstructor':function(){return ForeignKeyField;},'datatypeLetter':'Y','filterQueryOperators':['e','n','s'],'isNumber':false,'needsLookup':false,'inlineEditable':true,'inlineEditExtraData':['domain','useNewLookups'],'isDate':false}
,'YEARQUARTER':{'inlineEditFieldObject':null,'isCompond':true,'queryOperators':['e','n','l','g','m','h','c','k','s','i'],'inlineEditFieldConstructor':null,'datatypeLetter':'O','filterQueryOperators':['e','n','c','k','s'],'isNumber':false,'needsLookup':false,'inlineEditable':false,'inlineEditExtraData':null,'isDate':false}
,'TIMEONLY':{'inlineEditFieldObject':null,'isCompond':false,'queryOperators':['e','n','l','g','m','h'],'inlineEditFieldConstructor':null,'datatypeLetter':'f','filterQueryOperators':['e','n','l','g','m','h'],'isNumber':false,'needsLookup':false,'inlineEditable':false,'inlineEditExtraData':null,'isDate':false}
,'ENCRYPTEDTEXT':{'inlineEditFieldObject':'EncryptedTextField','isCompond':false,'queryOperators':['e','n','l','g','m','h','c','k','s','i'],'inlineEditFieldConstructor':function(){return EncryptedTextField;},'datatypeLetter':'6','filterQueryOperators':['e','n','c','k','s'],'isNumber':false,'needsLookup':false,'inlineEditable':true,'inlineEditExtraData':['maxLength','masked'],'isDate':false}
,'RECORDTYPE':{'inlineEditFieldObject':null,'isCompond':false,'queryOperators':['e','n'],'inlineEditFieldConstructor':null,'datatypeLetter':'7','filterQueryOperators':['e','n'],'isNumber':false,'needsLookup':true,'inlineEditable':false,'inlineEditExtraData':null,'isDate':false}
,'HTMLSTRINGPLUSCLOB':{'inlineEditFieldObject':'MultiLineTextField','isCompond':false,'queryOperators':['e','n','l','g','m','h','c','k','s','i'],'inlineEditFieldConstructor':function(){return MultiLineTextField;},'datatypeLetter':'z','filterQueryOperators':['e','n','c','k','s'],'isNumber':false,'needsLookup':false,'inlineEditable':true,'inlineEditExtraData':['maxLength','numCols','numRows','isHtml'],'isDate':false}
,'SWITCHABLE_PERSONNAME':{'inlineEditFieldObject':null,'isCompond':true,'queryOperators':['e','n','l','g','m','h','c','k','s','i'],'inlineEditFieldConstructor':function(){return null;},'datatypeLetter':'m','filterQueryOperators':['e','n','c','k','s'],'isNumber':false,'needsLookup':false,'inlineEditable':true,'inlineEditExtraData':null,'isDate':false}
,'PERSONNAME':{'inlineEditFieldObject':'PersonNameField','isCompond':true,'queryOperators':['e','n','l','g','m','h','c','k','s','i'],'inlineEditFieldConstructor':function(){return PersonNameField;},'datatypeLetter':'M','filterQueryOperators':['e','n','c','k','s'],'isNumber':false,'needsLookup':false,'inlineEditable':true,'inlineEditExtraData':['hasSalutation','reverse','picklistId','labels'],'isDate':false}
,'DUEDATE':{'inlineEditFieldObject':'DateField','isCompond':false,'queryOperators':['e','n','l','g','m','h'],'inlineEditFieldConstructor':function(){return DateField;},'datatypeLetter':'F','filterQueryOperators':['e','n','l','g','m','h'],'isNumber':false,'needsLookup':false,'inlineEditable':true,'inlineEditExtraData':['hasTime'],'isDate':true}
,'URL':{'inlineEditFieldObject':'TextField','isCompond':false,'queryOperators':['e','n','l','g','m','h','c','k','s','i'],'inlineEditFieldConstructor':function(){return TextField;},'datatypeLetter':'U','filterQueryOperators':['e','n','c','k','s'],'isNumber':false,'needsLookup':false,'inlineEditable':true,'inlineEditExtraData':['maxLength'],'isDate':false}
,'CONTENT':{'inlineEditFieldObject':'TextField','isCompond':false,'queryOperators':['e','n','l','g','m','h','c','k','s','i'],'inlineEditFieldConstructor':function(){return TextField;},'datatypeLetter':'9','filterQueryOperators':['e','n','c','k','s'],'isNumber':false,'needsLookup':false,'inlineEditable':true,'inlineEditExtraData':['maxLength'],'isDate':false}
,'MULTILINETEXT':{'inlineEditFieldObject':'MultiLineTextField','isCompond':false,'queryOperators':['e','n','l','g','m','h','c','k','s','i'],'inlineEditFieldConstructor':function(){return MultiLineTextField;},'datatypeLetter':'X','filterQueryOperators':['e','n','c','k','s'],'isNumber':false,'needsLookup':false,'inlineEditable':true,'inlineEditExtraData':['maxLength'],'isDate':false}
,'ADDRESSSTATE':{'inlineEditFieldObject':'TextField','isCompond':false,'queryOperators':['e','n','l','g','m','h','c','k','s','i'],'inlineEditFieldConstructor':function(){return TextField;},'datatypeLetter':'S','filterQueryOperators':['e','n','c','k','s'],'isNumber':false,'needsLookup':false,'inlineEditable':true,'inlineEditExtraData':['maxLength'],'isDate':false}
,'MULTIENUM':{'inlineEditFieldObject':'MultiEnumField','isCompond':false,'queryOperators':['e','n','u','x'],'inlineEditFieldConstructor':function(){return MultiEnumField;},'datatypeLetter':'Q','filterQueryOperators':['e','n'],'isNumber':false,'needsLookup':true,'inlineEditable':true,'inlineEditExtraData':['picklistId','controller','controllerLabel','height'],'isDate':false}
,'STRINGPLUSCLOB':{'inlineEditFieldObject':'MultiLineTextField','isCompond':false,'queryOperators':['e','n','l','g','m','h','c','k','s','i'],'inlineEditFieldConstructor':function(){return MultiLineTextField;},'datatypeLetter':'J','filterQueryOperators':['e','n','c','k','s'],'isNumber':false,'needsLookup':false,'inlineEditable':true,'inlineEditExtraData':['maxLength'],'isDate':false}
,'SFDCENCRYPTEDTEXT':{'inlineEditFieldObject':null,'isCompond':false,'queryOperators':['e','n','l','g','m','h','c','k','s','i'],'inlineEditFieldConstructor':null,'datatypeLetter':'T','filterQueryOperators':['e','n','c','k','s'],'isNumber':false,'needsLookup':false,'inlineEditable':false,'inlineEditExtraData':null,'isDate':false}
,'BIRTHDAY':{'inlineEditFieldObject':'DateField','isCompond':false,'queryOperators':['e','n','l','g','m','h'],'inlineEditFieldConstructor':function(){return DateField;},'datatypeLetter':'D','filterQueryOperators':['e','n','l','g','m','h'],'isNumber':false,'needsLookup':false,'inlineEditable':true,'inlineEditExtraData':['hasTime'],'isDate':true}
,'INTEGER':{'inlineEditFieldObject':'NumberField','isCompond':false,'queryOperators':['e','n','l','g','m','h'],'inlineEditFieldConstructor':function(){return NumberField;},'datatypeLetter':'N','filterQueryOperators':['e','n','l','g','m','h'],'isNumber':true,'needsLookup':false,'inlineEditable':true,'inlineEditExtraData':null,'isDate':false}
,'BOOLEAN':{'inlineEditFieldObject':'BooleanField','isCompond':false,'queryOperators':['e','n'],'inlineEditFieldConstructor':function(){return BooleanField;},'datatypeLetter':'B','filterQueryOperators':['e','n'],'isNumber':false,'needsLookup':true,'inlineEditable':true,'inlineEditExtraData':null,'isDate':false}
,'CURRENCY':{'inlineEditFieldObject':'NumberField','isCompond':false,'queryOperators':['e','n','l','g','m','h'],'inlineEditFieldConstructor':function(){return NumberField;},'datatypeLetter':'C','filterQueryOperators':['e','n','l','g','m','h'],'isNumber':true,'needsLookup':false,'inlineEditable':true,'inlineEditExtraData':null,'isDate':false}
,'DATETIME':{'inlineEditFieldObject':'DateField','isCompond':false,'queryOperators':['e','n','l','g','m','h'],'inlineEditFieldConstructor':function(){return DateField;},'datatypeLetter':'F','filterQueryOperators':['e','n','l','g','m','h'],'isNumber':false,'needsLookup':false,'inlineEditable':true,'inlineEditExtraData':['hasTime'],'isDate':true}
,'DIVISION':{'inlineEditFieldObject':'StaticEnumField','isCompond':false,'queryOperators':['e','n','l','g','m','h','c','k','s','i'],'inlineEditFieldConstructor':function(){return StaticEnumField;},'datatypeLetter':'I','filterQueryOperators':['e','n','c','k','s'],'isNumber':false,'needsLookup':true,'inlineEditable':true,'inlineEditExtraData':['picklistData'],'isDate':false}
,'INETADDRESS':{'inlineEditFieldObject':null,'isCompond':false,'queryOperators':['e','n','l','g','m','h','c','k','s','i'],'inlineEditFieldConstructor':null,'datatypeLetter':'W','filterQueryOperators':['e','n','c','k','s'],'isNumber':false,'needsLookup':false,'inlineEditable':false,'inlineEditExtraData':null,'isDate':false}
,'TEXT':{'inlineEditFieldObject':'TextField','isCompond':false,'queryOperators':['e','n','l','g','m','h','c','k','s','i'],'inlineEditFieldConstructor':function(){return TextField;},'datatypeLetter':'S','filterQueryOperators':['e','n','c','k','s'],'isNumber':false,'needsLookup':false,'inlineEditable':true,'inlineEditExtraData':['maxLength'],'isDate':false}
,'DYNAMICENUM':{'inlineEditFieldObject':'DynamicEnumField','isCompond':false,'queryOperators':['e','n','l','g','m','h','c','k','s','i'],'inlineEditFieldConstructor':function(){return DynamicEnumField;},'datatypeLetter':'L','filterQueryOperators':['e','n','c','k','s'],'isNumber':false,'needsLookup':true,'inlineEditable':true,'inlineEditExtraData':['picklistId','controller','controllerLabel'],'isDate':false}
,'BITVECTOR':{'inlineEditFieldObject':null,'isCompond':false,'queryOperators':['e','n','l','g','m','h','c','k','s','i'],'inlineEditFieldConstructor':null,'datatypeLetter':'8','filterQueryOperators':['e','n','c','k','s'],'isNumber':false,'needsLookup':false,'inlineEditable':false,'inlineEditExtraData':null,'isDate':false}
,'FORMULA':{'inlineEditFieldObject':null,'isCompond':false,'queryOperators':null,'inlineEditFieldConstructor':null,'datatypeLetter':'Z','filterQueryOperators':null,'isNumber':false,'needsLookup':false,'inlineEditable':false,'inlineEditExtraData':null,'isDate':false}
,'ENUMORID':{'inlineEditFieldObject':null,'isCompond':false,'queryOperators':['e','n','l','g','m','h','c','k','s','i'],'inlineEditFieldConstructor':null,'datatypeLetter':'L','filterQueryOperators':['e','n','c','k','s'],'isNumber':false,'needsLookup':true,'inlineEditable':false,'inlineEditExtraData':null,'isDate':false}
,'DATEONLY':{'inlineEditFieldObject':'DateField','isCompond':false,'queryOperators':['e','n','l','g','m','h'],'inlineEditFieldConstructor':function(){return DateField;},'datatypeLetter':'D','filterQueryOperators':['e','n','l','g','m','h'],'isNumber':false,'needsLookup':false,'inlineEditable':true,'inlineEditExtraData':['hasTime'],'isDate':true}
,'FFX_BLOB':{'inlineEditFieldObject':null,'isCompond':false,'queryOperators':null,'inlineEditFieldConstructor':null,'datatypeLetter':'X','filterQueryOperators':null,'isNumber':false,'needsLookup':false,'inlineEditable':false,'inlineEditExtraData':null,'isDate':false}
,'ADDRESS':{'inlineEditFieldObject':'AddressField','isCompond':true,'queryOperators':['e','n','l','g','m','h','c','k','s','i'],'inlineEditFieldConstructor':function(){return AddressField;},'datatypeLetter':'A','filterQueryOperators':['e','n','c','k','s'],'isNumber':false,'needsLookup':false,'inlineEditable':true,'inlineEditExtraData':['showState','labels'],'isDate':false}
}

var QueryOperator = {'NOT_EQUAL':{'value':'n'}
,'EQUALS':{'value':'e'}
,'GREATER_THAN':{'value':'g'}
,'NOT_LIKE':{'value':'j'}
,'EXACT_EQUALS':{'value':'a'}
,'RANGE_EXCLUSIVE':{'value':'E'}
,'EXCLUDES':{'value':'x'}
,'STARTS_WITH':{'value':'s'}
,'NOT_CONTAIN':{'value':'k'}
,'RANGE_INCLUSIVE':{'value':'I'}
,'LESS_THAN':{'value':'l'}
,'RANGE_INCL_RIGHT':{'value':'R'}
,'RANGE_INCL_LEFT':{'value':'L'}
,'LESS_OR_EQUAL':{'value':'m'}
,'CONTAINS':{'value':'c'}
,'NOT_START_WITH':{'value':'t'}
,'INCLUDES':{'value':'u'}
,'LIKE':{'value':'i'}
,'NOT_EXACT_EQUALS':{'value':'o'}
,'GREATER_OR_EQUAL':{'value':'h'}
}

var InlineEditState = {'READONLY':{'display':true,'cssClass':'inlineEditLock'}
,'POSTONLY':{'display':false,'cssClass':''}
,'NONE':{'display':false,'cssClass':''}
,'EDIT':{'display':true,'cssClass':'inlineEditWrite'}
}

/*
* @author mpolcari
* @since 142.wm
*/

function GenericSfdcPage() {
  this.init()

  this.inlineHelpMap = {};
  this.helpFader = null;

  var self = this;

  this.handleHelpHover = function(e){
      var target = getEventTarget(getEvent(e));
      if (!target) return;
      if (target.className == InlineHelp.CLASS_NAME){
          target.className = InlineHelp.CLASS_NAME_HOVER;
      } else if (target.nodeName == 'LABEL' && target.parentNode.className == InlineHelp.CLASS_NAME){
          target.parentNode.className = InlineHelp.CLASS_NAME_HOVER;
      }else if (target.className == InlineHelp.ORB){
          helpSpan = target.parentNode;
          while (!(helpSpan.className == InlineHelp.CLASS_NAME || helpSpan.className == InlineHelp.CLASS_NAME_HOVER)){
              helpSpan = helpSpan.parentNode
          }
          var helpId = helpSpan.id;
          helpSpan.className = InlineHelp.CLASS_NAME_HOVER;
          if (helpId && helpId.length > InlineHelp.ID_SUFFIX.length){
              var helpKey = helpId.substring(0, helpId.length - InlineHelp.ID_SUFFIX.length);
              self.showHelp(helpKey, helpSpan);
          }
      }
  }

  this.handleHelpUnhover = function(e){
      var target = getEventTarget(getEvent(e));
     if (!target) return;
      if ((target.className == InlineHelp.CLASS_NAME_HOVER) && mouseExited(e, target)){
          target.className = InlineHelp.CLASS_NAME;
      } else if ((target.nodeName == 'LABEL' && target.parentNode.className == InlineHelp.CLASS_NAME_HOVER) && mouseExited(e, target.parentNode)) {
          target.parentNode.className = InlineHelp.CLASS_NAME;
      } else if (target.className == InlineHelp.DISPLAY_DIV_CLASS && mouseExited(e, target)){
          var toElement = getEventToElement(getEvent(e));
          if (toElement.className != InlineHelp.ORB && self.helpFader){
              self.helpFader.fadeOut();
          }
      } else if (target.className == InlineHelp.ORB && mouseExited(e, target)){
          var toElement = getEventToElement(getEvent(e));
          var parent = target.parentNode;
          //hack for accessiblity mode, where the img has a link around it.
          if (UserContext.isAccessibleMode){
              parent = parent.parentNode;
          }
          if (toElement.className == InlineHelp.DISPLAY_DIV_CLASS){
              return;
          }
          if (toElement != parent){
              parent.className = InlineHelp.CLASS_NAME;
          }
        if (self.helpFader){
            self.helpFader.fadeOut();
        }
      }
  }

  this.appendToOnloadQueue(function() {addEvent(document, 'mouseover', self.handleHelpHover, false);});
  this.appendToOnloadQueue(function() {addEvent(document, 'mouseout', self.handleHelpUnhover, false);});
}

GenericSfdcPage.prototype.init = function() {
  this.onLoadQueue = [];
  this.onBeforeUnloadQueue = [];
  this.hasRun = false;
  this.relatedLists = [];
  this.relatedListsById = {};
  this.dialogs = {};
  this.messages = {};
  this.appendToOnloadQueue(function() { XBrowser.turnOnBackgroundImageCache(); }, "Turn on CSS background image cache (IE6 only)");
}

GenericSfdcPage.prototype.prependToOnloadQueue = function(fn, description) {
  if (description) fn.desc = description;
  if (this.hasRun) {
    this.execFunctionNoThrow(fn); //if the queue has already run, just execute this function
  } else {
    this.onLoadQueue.unshift(fn);
  }
}

GenericSfdcPage.prototype.appendToOnloadQueue = function(fn, description) {
  if (description) fn.desc = description;
  if (this.hasRun) {
    this.execFunctionNoThrow(fn); //if the queue has already run, just execute this function
  } else {
    this.onLoadQueue.push(fn);
  }
}

GenericSfdcPage.prototype.executeOnloadQueue = function() {
  for(var i = 0; (this.onLoadQueue && (i < this.onLoadQueue.length)); i++) {
    this.execFunctionNoThrow(this.onLoadQueue[i]);
  }
  this.hasRun = true;
  this.onLoadQueue = [];
}

GenericSfdcPage.prototype.prependToOnBeforeUnloadQueue = function(fn, description) {
  if (description) fn.desc = description;
  this.onBeforeUnloadQueue.unshift(fn);
}

GenericSfdcPage.prototype.appendToOnBeforeUnloadQueue = function(fn, description) {
  if (description) fn.desc = description;
  this.onBeforeUnloadQueue.push(fn);
}

GenericSfdcPage.prototype.executeOnBeforeUnloadQueue = function() {
  for(var i = 0; (this.onBeforeUnloadQueue && (i < this.onBeforeUnloadQueue.length)); i++) {
    this.execFunctionNoThrow(this.onBeforeUnloadQueue[i]);
  }
}

GenericSfdcPage.prototype.execFunctionNoThrow = function(fn) {
    try {
      fn();
    } catch (ex) {
      if (fn.desc) ex.sfdcDesc = fn.desc;
      Gack.handleException(ex);
    }
}


GenericSfdcPage.prototype.registerRelatedList = function(listId, visibleRowCount, title, hasMore, refURL, refQS, onlySkipLink) {
  var firstList = (this.relatedLists.length == 0);

  if(!this.relatedListsById[listId]){
      this.relatedListsById[listId] = new RelatedList(listId, visibleRowCount, title, hasMore, refURL, refQS, onlySkipLink);
      this.relatedLists.push(this.relatedListsById[listId]);
  }

  if (this.relatedListPanel) {
    this.relatedListPanel.registerList(this.relatedListsById[listId]);
  }
  ///If this is the first RL on the page, queue up the panel initialization script
   var self = this;
   if (firstList) {
     this.prependToOnloadQueue(
       function () {
         if ((self.relatedListPanel) && (self.relatedListPanel.addListsToPanel)) {
           self.relatedListPanel.addListsToPanel();
         }
      }, "rlHovers: Initializing panel");
    }
}

GenericSfdcPage.prototype.registerDialog = function(dialog) {
    this.appendToOnloadQueue(function() { dialog.createDialog(); }, "Create a dialog");
    this.dialogs[dialog.id] = dialog;
}

GenericSfdcPage.prototype.getDialogById = function(dialogId) {
    return this.dialogs[dialogId];
}

GenericSfdcPage.prototype.getRelatedListById = function(listId) {
  return this.relatedListsById[listId];
}

/**
  Retrieves the current address as an URLencoded retUrl
*/
GenericSfdcPage.prototype.getHrefAsRetURL = function() {
  var href = window.location.href;

  var retUrlArr = href.split("/");
  retUrlArr.splice(0,3);
  return encodeURIComponent("/" + retUrlArr.join("/"));
}

GenericSfdcPage.prototype.includeJavascriptTag = function(scriptUri) {
    return this.embedJSTag(scriptUri, document);
}

GenericSfdcPage.prototype.embedJSTag = function(scriptUri, doc) {
    var html_doc = doc.getElementsByTagName('head').item(0);
    var js = doc.createElement('script');
    js.setAttribute('language', 'javascript');
    js.setAttribute('type', 'text/javascript');
    js.setAttribute('src', scriptUri);
    html_doc.appendChild(js);
    return false;
}

GenericSfdcPage.prototype.embedExternalStyleSheet = function(sheetUrl, doc) {
    var styleNode = doc.createElement("link");
    styleNode.setAttribute("href", sheetUrl);
    styleNode.setAttribute("type", "text/css");
    styleNode.setAttribute("rel", "stylesheet");

    var targetHead = doc.body.parentNode.firstChild;
    targetHead.appendChild(styleNode);
}

GenericSfdcPage.prototype.hideEmbeddingIframe = function(iframeWin) {
    if (iframeWin.name && document.getElementById(iframeWin.name)) {
      document.getElementById(iframeWin.name).style.display = 'none';
      document.getElementById(iframeWin.name).parentNode.style.border ='none';
    }
}

GenericSfdcPage.prototype.setHelp = function(key, text){
    this.inlineHelpMap[key] = text;
}

GenericSfdcPage.prototype.getHelp = function(key){
    return this.inlineHelpMap[key];
}

GenericSfdcPage.prototype.showHelp = function(id, element){
    var help = this.getHelp(id);
    if (help){
        if (!this.displayDiv){
            this.displayDiv = document.createElement("DIV");
            this.displayDiv.className = InlineHelp.DISPLAY_DIV_CLASS;
        }
        var parentElement = document.getElementById(BodyLayout.BODY_CELL_ID);
        if (!parentElement){
        	parentElement = document.body;
        }
        parentElement.appendChild(this.displayDiv);
        this.displayDiv.style.top = (getObjY(element) + element.offsetHeight + 8 - getObjY(parentElement)) + 'px';
        if (!this.helpFader){
            this.helpFader = new MouseOverFadeHandler(null, this.displayDiv, false);
        }
        this.displayDiv.innerHTML = help;
        this.helpFader.setPosition();
        var left = (getObjX(element) + element.offsetWidth - this.displayDiv.offsetWidth);
        //Make sure it's not behind the sidebar.
        var sidebar = document.getElementById(SidebarConstants.SIDEBAR_DIV_ID);
        if (sidebar){
        	var sidebarRight = getObjX(sidebar) + sidebar.offsetWidth;
        	if (left < sidebarRight){
        		left = sidebarRight;
        	}
        }
        if (left >= 0){
            this.displayDiv.style.left = left + 'px';
        }
        this.helpFader.fadeIn();
    }
}

/**
 * simple messaging for now. should have type, strength, etc and allow sorting, dismissing...
 */
GenericSfdcPage.prototype.registerMessage = function(id) {
    var message = document.getElementById(id);
    if (message && !this.messages[id]) {
        this.messages[id] = message;
    }
}

GenericSfdcPage.prototype.hideMessage = function(id) {
    var message = this.messages[id];
    if (message) {
        message.style.display = "none";
    }
}

GenericSfdcPage.prototype.showMessage = function(id) {
    var message = this.messages[id];
    if (message) {
        message.style.display = "block";
    }
}

/**
  A select element with the up & down arrows next to it.

  @author polcari
  @since 144

*/
function VerticallyArrangableSelectElement(_id) {
  this.id = _id;
  var vaSelectElement = this;
  sfdcPage.appendToOnloadQueue(function() {vaSelectElement.init()});
}

VerticallyArrangableSelectElement.prototype.init = function() {
  var containingNode = document.getElementById(this.id).parentNode.parentNode;
   //find the up & down buttons & attach to them
  var imgs = containingNode.getElementsByTagName("img");

  var _id = this.id;
  for (var i=0; (imgs && (i < imgs.length)); i++) {
    if (hasStyleClass(imgs[i], vaSelectElementConst.UP_CLASS)) {
      addEvent(imgs[i], 'click', function() {moveUp(document.getElementById(_id))}, false);
    } else if (hasStyleClass(imgs[i], vaSelectElementConst.DOWN_CLASS)) {
      addEvent(imgs[i], 'click', function() {moveDown(document.getElementById(_id))}, false);
    }
  }
}

/**
 * Functions for handling Email Relay Activation processing.
 * @author ccopek
 * @since 146
 */

function EmailRelay() {}

/**
 * The Activate Restrict Relay To Domains checkbox has to enable/disable the
 * restrict relay to domains input field based on being checked/un-checked.
 * When Activate is checked, the input field must be enabled.  When Activate
 * is un-checked, the input field must be disabled and blanked out.
 */
EmailRelay.prototype.checkActivateRestrictToDomains = function() {
    var restrictRelayToDomainsCheckbox = document.getElementById(EmailRelayConstants.ACTIVATE_RESTRICT_TO_DOMAINS_ID);
    var restrictRelayToDomains = document.getElementById(EmailRelayConstants.RESTRICT_TO_DOMAINS_ID);
    var restrictRelayToDomainsHidden = document.getElementById(EmailRelayConstants.RESTRICT_TO_DOMAINS_HIDDEN_ID);

    if (restrictRelayToDomainsCheckbox.checked) {
        // Activate Restrict Relay To Domains is checked.  Need to enable the Restrict Relay
        // To Domains input field.
        restrictRelayToDomains.disabled = false;
    } else {
        // Activate Restrict Relay To Domains is un-checked.  Need to disable the Restrict Relay
        // To Domains input field and blank out it's value.
        restrictRelayToDomains.value = '';

        // Blank out the hidden field as well.
        restrictRelayToDomainsHidden.value = '';

        restrictRelayToDomains.disabled = true;
    }
}

/**
 * In the case were the Restrict Relay To Domains field is disabled in either of these scenarios:
 *		- Come into the panel disabled and then is enabled via the activate checkbox being checked
 *	    OR
 *		- Is disabled via the activate checkbox being unchecked.
 * In these scenarios, the value contained in the Restrict Relay to Domains is not being sent
 * when the form is submitted.  A hidden variable is being used to transmit the value to
 * the server.  This function will set the value of the hidden variable to the value of the
 * restrict relay to domains input field when it has changed.
 */
EmailRelay.prototype.changeRestrictToDomains = function() {
    var restrictRelayToDomains = document.getElementById(EmailRelayConstants.RESTRICT_TO_DOMAINS_ID);
    var restrictRelayToDomainsHidden = document.getElementById(EmailRelayConstants.RESTRICT_TO_DOMAINS_HIDDEN_ID);

    restrictRelayToDomainsHidden.value = restrictRelayToDomains.value;
}

/**
 * When the Email Relay TLS Setting is changed to Off or from Off, we need to default
 * the Port as follows:
 * 		Change TLS TO Off - Default Port to 25
 *		Change TLS FROM Off - Default Port to 587
 */
EmailRelay.prototype.handleTlsChange = function() {
    var TLS_OFF_VALUE = 0;
    var DEFAULT_EMAIL_HOST_PORT_INDEX = 0;
    var DEFAULT_TLS_PORT_INDEX = 1;

    var emailRelayTlsSetting = document.getElementById(EmailRelayConstants.EMAIL_RELAY_TLS_SETTING_ID);
    var relayPort = document.getElementById(EmailRelayConstants.EMAIL_HOST_PORT_ID);
    var emailRelayTlsSettingVal = emailRelayTlsSetting.options[emailRelayTlsSetting.selectedIndex].value;
    var relayPortSelectedIndex = relayPort.selectedIndex;

    if (emailRelayTlsSettingVal == TLS_OFF_VALUE && relayPortSelectedIndex == DEFAULT_TLS_PORT_INDEX) {
        // TLS has been changed to Off.  Default Port to non TLS default value.
        // We will only Default the value if it's set to the non-TLS default.  We
        // don't want to change the value if the user has set their port to a custom
        // port.
        relayPort.options[DEFAULT_EMAIL_HOST_PORT_INDEX].selected = true;
    }
    else if (emailRelayTlsSettingVal != TLS_OFF_VALUE && relayPortSelectedIndex == DEFAULT_EMAIL_HOST_PORT_INDEX) {
        // TLS has been turned on.  Default Port to TLS default value.
        relayPort.options[DEFAULT_TLS_PORT_INDEX].selected = true;
    }
}

function ApiUtils() {}

ApiUtils.getApiURL = function(isPartner, version) {
    var url = window.location.href;
    var idx = url.indexOf('/', 10); // well after (http|https)://
    var base = url.substring(0, idx) + "/services/Soap/" + (isPartner ? "u" : "c") + "/" + version;
    return base;
}

ApiUtils.getSessionId = function(){
    var sessionId = getCookie(RequestInfo.pSID);
    return sessionId;
}

// fluff up a 15 char id to return an 18 char id
ApiUtils.to18CharId = function (id) {
 if (id == null || (id.length == 18)) return id;
 id = id.replace(/\"/g, ''); // scrub quotes from this id
 if (id.length != 15) {
  return null;
 }
 var suffix = "";
 for (var i = 0; i < 3; i++) {
  var flags = 0;
  for (var j = 0; j < 5; j++) {
   var c = id.charAt(i * 5 + j);
   if (c >= 'A' && c <= 'Z') {
    flags += 1 << j;
   }
  }
  if (flags <= 25) {
   suffix += "ABCDEFGHIJKLMNOPQRSTUVWXYZ".charAt(flags);
  } else {
   suffix += "012345".charAt(flags-26);
  }
 }
 return id + suffix;
}

ApiUtils.to15CharId = function(id){
    if (!id) return null;
    return id.substring(0, 15);
}

// the id field returned by the API is often returned twice,resulting
// in an array when calling record.get(). this returns a single ID always.
ApiUtils.getId = function(record){
    if (!record) return null;
    var id = record.get("Id");
    // looking for array by checking for "splice()" function
    if (id.splice && id.length && id.length > 0) {
        id = id[0];
    }
    if (id){
        id = ApiUtils.to15CharId(id);
    }
    return id;
}

ApiUtils.soqlEncode = function(str){
    var newStr = str;
    newStr = newStr.replace("\\", "\\\\");
    newStr = newStr.replace("'", "\\'");
    return newStr;
}

/*
* @author mpolcari
* @since 142.ml
*/
function DetailPage() {
    this.relatedListPanel = null;
    this.editMode = false;
    this.inlineEditData = null;
    this.detailButtons = [];
    this.editButtons = [];
    this.errorDiv = null;
    this.saving = false;
}

DetailPage.prototype = new GenericSfdcPage();

DetailPage.prototype.registerRelatedListPanel = function (panelId) {
  this.relatedListPanel = new RelatedListPanel(panelId);
  var self = this;
  this.appendToOnloadQueue(
    function () { //Copy css styleSheets, script includes, & body.className
      var iFrameWindow = self.relatedListPanel.getIFrameNode().contentWindow;
      var iFrameDoc = iFrameWindow.document;
      DomUtil.copyScriptsCssBodyClass(document, iFrameDoc);
      iFrameDoc.body.className += " rlHoverFrame";
      iFrameWindow.sfdcPage = self;
    }, "rlHovers: Importing Scripts and CSS");
}

DetailPage.prototype.getEntityId = function() {
  var href = window.location.href;
  var paths = href.split('?')[0].split('/');
  return paths[paths.length-1];
}

DetailPage.prototype.evalScripts = function (rlElement) {
  var scriptElements = rlElement.getElementsByTagName('script');
  for (var ind = 0; ind<scriptElements.length;ind++){
  	var jsExpression = scriptElements[ind].innerHTML;
  	eval(jsExpression);
  }
}

DetailPage.prototype.hasNoRelatedList = function(doc, listId) {
	var retVal = getElementByIdCSWithDoc(doc, listId);
	if(!retVal){
		return true;		
	}else{
		return false;
	}
}

DetailPage.prototype.desktopAjaxDisplayErrorInline = function() {
	return false;
}

DetailPage.prototype.hook_postRelatedListActionUpdate = function(listUrl) {
	return;
}

DetailPage.prototype.initInlineEdit = function(iled) {
    this.inlineEditData = iled;
    if (iled.isEditable) {
        var self = this;
        this.appendToOnloadQueue(function() { self.inlineEditData.init(); }, "Initialize inline edit");
        this.appendToOnloadQueue(function() { self.initializeButtons(); }, "Setup detail buttons");
    }
}

DetailPage.prototype.getFieldById = function(domId) {
    if (this.inlineEditData) {
        if (domId.search(InlineEditConstants.CELL_ID + "$") != -1) {
            return this.inlineEditData.getField(domId.substring(0, domId.length - InlineEditConstants.CELL_ID.length));
        } else {
            return this.inlineEditData.getField(domId);
        }
    }
}

DetailPage.prototype.initializeButtons = function() {
    var self = this;
    function getButtonsInCell(cellId) {
        var cell = document.getElementById(cellId);
        var buttons = cell.getElementsByTagName("input");
        for (var i = 0; i < buttons.length; i++) {
            var button = buttons[i];
            if (button.type == "button") {
                if (button.name == InlineEditConstants.SAVE_BUTTON || button.name == InlineEditConstants.CANCEL_BUTTON) {
                    self.editButtons.push(button);
                } else {
                    self.detailButtons.push(button);
                }
            }
        }
        var muttons = cell.getElementsByTagName("div");
        for (var i = 0; i < muttons.length; i++) {
            var mutton = muttons[i];
            if (mutton.className == "menuButton") {
                self.detailButtons.push(mutton);
            }
        }
    };
    getButtonsInCell(DetailElement.TOP_BUTTON_ROW);
    getButtonsInCell(DetailElement.BOTTOM_BUTTON_ROW);
}

DetailPage.prototype.focusOnSave = function() {
    this.editButtons[0].focus();
}

DetailPage.prototype.activateInlineEditMode = function() {
    if (!this.errorDiv) {
        this.errorDiv = document.getElementById(DetailElement.DEFAULT_ERROR_DIV_ID);
    }
    this.editMode = true;
    for (var i = 0; i < this.detailButtons.length; i++) {
        this.detailButtons[i].style.display = "none";
    }
    for (var i = 0; i < this.editButtons.length; i++) {
        this.editButtons[i].style.display = "inline";
    }
}

DetailPage.prototype.deactivateInlineEditMode = function() {
    this.editMode = false;
    for (var i = 0; i < this.detailButtons.length; i++) {
        this.detailButtons[i].style.display = "inline";
    }
    for (var i = 0; i < this.editButtons.length; i++) {
        this.editButtons[i].style.display = "none";
    }
    this.clearError();
}

DetailPage.prototype.setError = function(error) {
    if (this.saving) {
        this.saving = false;
        for (var i = 0; i < this.editButtons.length; i++) {
            this.editButtons[i].className = "btn"
            if (this.editButtons[i].name == InlineEditConstants.SAVE_BUTTON) {
                this.editButtons[i].value = LC.getLabel("Buttons", "save");
            } else if (this.editButtons[i].name == InlineEditConstants.CANCEL_BUTTON) {
                this.editButtons[i].value = LC.getLabel("Buttons", "cancel");
            }
        }
    }
    if (error) {
        this.errorDiv.innerHTML = error;
    }
    this.errorDiv.style.display = "block";
}

DetailPage.prototype.clearError = function(error) {
    this.errorDiv.style.display = "none";
}

DetailPage.prototype.refreshDetail = function() {
    //this.deactivateInlineEditMode();
    // TODO: ajax refresh here
    navigateToUrl(window.location);
}

DetailPage.prototype.save = function() {
    if (!this.saving && this.editMode) {
        this.saving = true;
        for (var i = 0; i < this.editButtons.length; i++) {
		    this.editButtons[i].className = "btnDisabled";
		    this.editButtons[i].value = LC.getLabel("Buttons", "saving");
        }
        this.inlineEditData.save();
    }
}

DetailPage.prototype.revert = function() {
    if (!this.saving && this.editMode) {
        this.inlineEditData.revert();
        this.deactivateInlineEditMode();
    }
}

DetailPage.prototype.dblClickField = function(evt, element) {
    var target = getEventTarget(getEvent(evt));
    if (target.nodeName.toLowerCase() != "a") {
        var field = this.getFieldById(element.id);
        if (field && field.state == InlineEditState.EDIT) {
            if (!this.editMode) {
                this.activateInlineEditMode();
            }
            if (!this.inlineEditData.isCurrentField(field)) {
                this.inlineEditData.openField(field);
            }
            eventCancelBubble(evt);
        }
    }
}

DetailPage.prototype.clickField = function(evt, element) {
    var field = this.getFieldById(element.id);
    if (field && this.inlineEditData.isCurrentField(field)) {
        eventCancelBubble(evt);
    }
}

DetailPage.prototype.mouseOverField = function(evt, element) {
    var field = this.getFieldById(element.id);
    if (field) {
        delStyleClass(element, field.getCSSClass());
        addStyleClass(element, field.getCSSHoverClass());
    }
}

DetailPage.prototype.mouseOutField = function(evt, element) {
    var field = this.getFieldById(element.id);
    if (field) {
        delStyleClass(element, field.getCSSHoverClass());
        addStyleClass(element, field.getCSSClass());
    }
}

DetailPage.prototype.dismissILEBanner = function() {
    UserContext.userPreferences.setBoolean("HideInlineEditSplash", true);
    this.hideMessage("ileBanner");
}



var backgroundIFrameTitle;
function EmailTemplateEditorUi(title, isCustomP, formNameP) {
    registerEmptyCellText(LC.getLabel("EmailTemplate", "emptyCellText"));
    this.editAreaIds = null;
    backgroundIFrameTitle = title; //used by EmailEditorJS
    this.isCustom = isCustomP;
    this.formName = formNameP;
}

EmailTemplateEditorUi.prototype.gatherEditableIds = function () {
    var tempIds = new Object(20);
    var elements = document.getElementsByTagName('td');
    var index = 0;
    for (var i = 0; i < elements.length; i++) {
        var element = elements[i];
        if (element.id != null && element.id.length > 0) {
            tempIds[index] = element.id;
            index++;
        }
    }
    editAreaIds = new Object(index);
    for (var i = 0; i < index; i++) {
        editAreaIds[i] = tempIds[i]
    }
}

EmailTemplateEditorUi.prototype.getTopTable = function() {
      var topTable = document.getElementById('topTable');
      var allTables = document.getElementsByTagName("table");
      if ((!topTable) && allTables) {
        topTable = allTables[0];
      }
      return topTable;
    }

EmailTemplateEditorUi.prototype.getDefaultPopupWidth = function (){
  var topTable = getTopTable();
  if (topTable) {
    return Math.min(Math.max(topTable.offsetWidth + 60, 500), 1024);
  } else {
    return 500;
  }
}
EmailTemplateEditorUi.prototype.getDefaultPopupHeight = function (){
  var topTable = getTopTable();
  if (topTable) {
    return Math.min(Math.max(topTable.offsetHeight + 200, 500), 768);
  } else {
    return 500;
  }
}
// Init function called by the onload event handler in the <BODY> tag.
EmailTemplateEditorUi.prototype.init = function () {
    if (top != this) {
    	if(this.isCustom) {
	        if (document.body) {
	 	       parent.setFrameWidth(document.body.scrollWidth);
    		   parent.setFrameHeight(document.body.scrollHeight);
	        }
    	}
    	else {
	        this.gatherEditableIds();
	        setEditableIds(editAreaIds);
	        registerLockingConfirmText(LC.getLabel("EmailTemplate", "SetLockedConfirmText"));
	        setLockedImageSrc("/email/wysiwyg/images/locked.gif");
	        setUnlockedImageSrc("/email/wysiwyg/images/unlocked.gif");
	        // Tells the editor where to load the values from, and where to save them to.
	        registerEditForm(parent.document.forms[this.formName]);
	        initializeEditor();
	        //signal the parent that the edit ctr is finished initializing
	        top.editFinishedLoading=true;
        }
    } else {
        window.resizeTo(this.getDefaultPopupWidth(), this.getDefaultPopupHeight());
    }
}
var SELECT_MENU_SELECT = 1;
var SELECT_MENU_SIDEWAYS = 2;

/**
 * A class that acts more or less exactly like a select box.
 *
 * @param sourceID The DOM id of a UL that will form the elements of the select
 * @param targetID A div target in which to build the SelectMenu
 * @param displayWord A string to display as the initial entry of the menu.
 * @param hasDefaultAction Splits the button in two parts if true: the button area, which when clicked
 *		  loads the first link in the list, and the arrow area, which displays or hides the menu.
 * @author emoses
 * @deprecated don't use this, use MenuButton instead
 */
function SelectMenu(sourceId, targetId, displayWord, selectMenuOuterClass, selectMenuClass, style, groupClass, needScrollbars, hasDefaultAction, isRightAligned){
    this.sourceList = document.getElementById(sourceId)
    this.select = null;
    this.menuDiv = null;
    this.displayWord = displayWord;
    this.targetDiv = document.getElementById(targetId)
    this.divClass = selectMenuOuterClass;
    this.menuClass = selectMenuClass;
    this.menuOpen = false;
    this.hasSetPosition = false;
    this.scrollbars = needScrollbars;
    this.hasDefaultAction = hasDefaultAction;
    this.isCreateNew = false;
    this.isRightAligned = isRightAligned;

    if (style){
        this.style = style;
    } else {
        this.style = SELECT_MENU_SELECT;
    }

    var self = this;

    this.documentHideMenu = function(e){
        var elem = getEventTarget(e);
        if(elem.className == groupClass) { return;}
        if (self.menuOpen){
            self.hideMenu();
        }
    }

    this.handleDocumentKeyDown = function(e){
        var evt = getEvent(e);

        if (self.menuOpen && evt.keyCode == KEY_ESC){
            //ESC key, when not pinned and all the way out
            self.hideMenu();
        }
    };

    this.handleDivClick = function(e) {
        var elem = getEventTarget(e);
        if(elem.className == groupClass) { return;}

        if (self.hasDefaultAction) {
            var nOffsetX=(e.layerX)?(e.layerX):e.offsetX;
            if(nOffsetX<(elem.offsetWidth-17)) {
                window.location = self.sourceList.childNodes[0].href;
                eventCancelBubble(e);
                return;
            }
        }
        if (self.menuOpen){
            self.hideMenu();

        } else {
            self.showMenu();
            self.setPosition();
        }
        eventCancelBubble(e);
    }

    if (!this.sourceList) return;
    if (!this.targetDiv) return;
    this.init();
}

SelectMenu.prototype.showMenu = function(){
    if (!this.isCreateNew) {
        this.targetDiv.style.position = "relative";
    }
    this.menuDiv.setStyle("display", "block");
    this.menuOpen = true;
};

SelectMenu.prototype.hideMenu = function(){
    if (!this.isCreateNew) {
        this.targetDiv.style.position = "static";
    }    
        this.menuDiv.setStyle("display", "none");
        this.menuOpen = false;
};

SelectMenu.prototype._setPositionSelect = function(){
    if (!this.hasSetPosition) {
        this.hasSetPosition = true;

        if (!this.isCreateNew) {
            this.menuDiv.setStyle("top", this.select.offsetHeight + "px");
            if(!this.isRightAligned){
                this.menuDiv.setStyle("left", "0px");
            }else{
                this.menuDiv.setStyle("right","3px");
            }
        }

        // Begin IE fix
        // Can't do this in CSS because the whitespace at the end of
        // the link elements don't function as a link.
        // So, grab the maximum text length of the link elements, make that
        // the width of the container div, and then set all link elements
        // to width 100%.

        var maxWidth = this.sourceList.childNodes[0].scrollWidth;
        var maxOptionWidth = maxWidth;
        for (var i = 1; i < this.sourceList.childNodes.length; i++) {
            if (this.sourceList.childNodes[i].scrollWidth > maxWidth)
                maxWidth = this.sourceList.childNodes[i].scrollWidth;
        }
        // this should not be set for menu with scrollbars
        for (var i = 0; i < this.sourceList.childNodes.length; i++) {
            this.sourceList.childNodes[i].style.width = "100%";
            if(this.sourceList.childNodes[i].offsetWidth > maxOptionWidth){
                maxOptionWidth = this.sourceList.childNodes[i].offsetWidth;
            }
        }
        this.menuDiv.setStyle("width", maxWidth + "px");
        // End IE Fix.

        // if the menu should have scrollbars then proceed with height calculations below
        if(this.scrollbars){
            // show a maximum of 20 items
            var maxHeight = this.sourceList.childNodes[0].offsetHeight*20;
            var actualHeight = this.sourceList.offsetHeight;
            if (actualHeight < maxHeight){
                maxHeight = actualHeight;
            }
            this.menuDiv.setStyle("height", maxHeight + "px");
            this.menuDiv.setStyle("overflowY", "auto");


        }
        if (this.menuDiv.div.offsetWidth < this.select.childNodes[0].offsetWidth){
            this.menuDiv.setStyle("width", this.select.childNodes[0].offsetWidth + "px");
            // firefox fix to ensure that horizontal scrollbar doesn't show up on click
            if(this.scrollbars){
                this.menuDiv.setStyle("width", (maxOptionWidth + 34) + "px");
                this.menuDiv.setStyle("backgroundColor", "#CCC");
                this.menuDiv.div.childNodes[0].style.width = this.menuDiv.div.offsetWidth - 34 + "px";
            }
        }
    }
};

SelectMenu.prototype._setPositionSideways = function() {
    this.menuDiv.setStyle("top", this.select.offsetHeight / 2 + "px");
    this.menuDiv.setStyle("left", this.select.offsetWidth + "px");
}

SelectMenu.prototype.init = function(){

    this.select = document.createElement("div");
    this.select.className = this.divClass;

    this.targetDiv.insertBefore(this.select, this.targetDiv.firstChild);

    var upperDiv = document.createElement("div");
    if (this.hasDefaultAction) {
        upperDiv.className = "selectMenuButton hasDefault";
    } else {
        upperDiv.className = "selectMenuButton";
    }
    this.select.appendChild(upperDiv);
    upperDiv.appendChild(document.createTextNode(this.displayWord));

    this.menuDiv = document.createElement("div");
    this.menuDiv.className = this.menuClass;
    this.select.appendChild(this.menuDiv);

    this.menuDiv.appendChild(this.sourceList);
    switch(this.style){
    case SELECT_MENU_SIDEWAYS:
        this.setPosition = this._setPositionSideways;
//      document.body.appendChild(this.menuDiv);
        break;
    case SELECT_MENU_SELECT:
    default:
        this.setPosition = this._setPositionSelect;
    }

    this.menuDiv = new iframeShim(this.menuDiv);
    this.menuDiv.setStyle("display", "none");
    this.menuDiv.setStyle("position", "absolute");

    addEvent(document, 'click', this.documentHideMenu, false);
    addEvent(document, 'keydown', this.handleDocumentKeyDown, true);
    addEvent(this.targetDiv, 'click', this.handleDivClick, false);
};

    /** @author zzhou
     *  @since 150
     * Used to determine whether we take a user directly to another forecast on inputting a value in the forecast user lookup
     * input box and pressing enter */

function FctSummaryPage() {}

FctSummaryPage.onForecastLookupBoxInput = function(element,oEvent) {
	if ((oEvent.keyCode && oEvent.keyCode==13) || (oEvent.which && oEvent.which==13)) {
		document.getElementById(ForecastSummaryPage.pLOOKUP_INPUT_ENTERED).value = 1;
		element.form.submit();
	}
}

function SearchQueryTool(targetEntityInputId) {
	this.queryTypeWithEntityStorage = new Object();
	this.targetEntityInputId = targetEntityInputId;
	this.entityInput = null;
	this.savedValue = null;
}

SearchQueryTool.prototype.addQueryTypeWithEntity = function (queryType){
	this.queryTypeWithEntityStorage[queryType] = queryType;
}

SearchQueryTool.prototype.processTargetEntity = function (queryType){
	if(!this.entityInput && !this.targetEntityInputId){ return; }
	
	// initialize lazily
	if (!this.entityInput){ 
		this.entityInput = document.getElementById(this.targetEntityInputId);
		this.targetEntityInputId = null;
	}
	
	if (queryType in this.queryTypeWithEntityStorage){
		this.entityInput.disabled = true;
		this.savedValue = this.entityInput.value;
		this.entityInput.value = '';
	} else {
		this.entityInput.disabled = false;
		if(this.savedValue){
			this.entityInput.value = this.savedValue;
		}
	}
}
/**
 * This class handles auto complete functionality on the tag header element.
 * It grabs _all_ the tags for the current user from LookupTagsPage and caches this list.
 * Given the current count limit on private tags (500) this is not a problem, but in the
 * future we might want to be more selective about what we grab.
 *
 * @author mpaksoy
 * @since 150
 * based on AutoComplete.js by rchoi
 */

/**
 * @param elem text area element used for auto complete
 * NOTE: this element needs a DOM id
 * @param callback keypress event handler callback. Auto complete needs priviledged access to
 * the keypress event to grab the tab/enter keys, it will pass the event on as necessary.
 */
function TagAutoComplete(elem, tagMode, callback) {
    this.element = elem;
    this.id = this.element.id;
    this.tagMode = tagMode;

    this.recordHeight = 18;

    this.selection = false;
    this.keyPressCallback = callback;

    // EVENT HANDLERS
    var self = this;
    addEvent(this.element, 'keyup', function(e) { self.onKeyUp(e); });
    addEvent(this.element, 'keydown', function(e) { self.captureKeyPress(e); });
    addEvent(this.element, 'keypress', function(e) { self.captureKeyPress(e, true); });
    addEvent(this.element, 'blur', function(e) { self.onBlur(e); });
    addEvent(window, 'resize', function(e) { self.resizeLocationUpdater(e); });

    window[this.id + TagAutoComplete.MOUSE_OVER_HANDLER] = function(i) { self.updateSelection(i); };
}

// STATIC CONSTANTS
TagAutoComplete.MOUSE_OVER_HANDLER = '_autoCompleteMouseOverHandler';
TagAutoComplete.BOX_ID = '_autoCompleteBoxId';
TagAutoComplete.FRAME_ID = '_autoCompleteFrameId';
TagAutoComplete.ROW_ID = '_autoCompleteRowId';
TagAutoComplete.BOX_CSS_CLASS = 'autoCompleteBox';
TagAutoComplete.ROW_CSS_CLASS = 'autoCompleteRow';
TagAutoComplete.SELECTED_ROW_CSS_CLASS = 'autoCompleteSelectedRow';
TagAutoComplete.MORE_ROW_CSS_CLASS = 'autoCompleteMoreRow';
TagAutoComplete.MIN_LENGTH_THRESHOLD = 1;
TagAutoComplete.MAX_SUGGESTIONS = 15;
TagAutoComplete.EMPTY = /^\s*$/;

// INSTANCE METHODS

/**
 * Set the function to call when text is entered to see if text area needs to
 * be resized.
 */
TagAutoComplete.prototype.setResizer = function(callback) {
    this.resizeCallback = callback;
}

/**
 * Call the resize handler and move auto complete box if necessary.
 */
TagAutoComplete.prototype.resizeTextArea = function() {
    if (this.resizeCallback && this.resizeCallback()) { // if resized
        this.updateBoxLocation();
    }
}

/**
 * Display the auto-complete box containing the given set of suggestions.
 * @param records array of suggestions
 */
TagAutoComplete.prototype.displayResults = function(records) {
    if (!records || !(records instanceof Array)) return;
    if (records.length == 0) {
        if (this.box) {
            this.doClear();
        }
        return;
    }

    var html = [];
    html.push("<table width='100%' cellpadding='0' cellspacing='0' border='0'>");
    for (var i = 0; i < records.length; i++){
        if (i >= TagAutoComplete.MAX_SUGGESTIONS) {
            html.push("<tr><td>");
            html.push("<div ");
            html.push("class='" + TagAutoComplete.MORE_ROW_CSS_CLASS+"'");
            html.push(">");
            html.push(LC.getLabel('TagHeader','auto_complete_more'));
            html.push("</div>");
            html.push("</td></tr>");
            break;
        }

        var record = records[i];
        html.push("<tr><td>");
        html.push("<div ");
        html.push("onmouseover='");
        html.push("window."+this.id+TagAutoComplete.MOUSE_OVER_HANDLER+"("+i+");'");
        html.push("class='"+TagAutoComplete.ROW_CSS_CLASS+"' ");
        html.push("id='"+this.getRowId(i)+"'>");
        html.push("<span>");
        html.push(record);
        html.push("</span>");
        html.push("</div>");
        html.push("</td></tr>");
    }
    html.push("</table>");

    var recordsShown = (records.length > TagAutoComplete.MAX_SUGGESTIONS) ?
                        TagAutoComplete.MAX_SUGGESTIONS + 1: records.length;
    if (!this.box){ // need to create auto complete box
        // IE6 returns the wrong element position if we call getObjX() right after calling makeBox() so we save coordinates from before.
        var y = getObjY(this.element) + this.element.offsetHeight;
        var x = getObjX(this.element);
        this.makeBox();
        this.moveBox(y, x);
    }
    this.box.div.innerHTML = html.join('');
    this.showBox(true);
    this.updateSelection(0); // pick the first one by default
}

TagAutoComplete.prototype.resizeLocationUpdater = function() {
    if (this.box) // box already created
        this.updateBoxLocation();
}

TagAutoComplete.prototype.updateBoxLocation = function() {
    this.moveBox(getObjY(this.element) + this.element.offsetHeight, getObjX(this.element));
}

/**
 * Connects to the servlet to grab the list tags for the current user.
 * This list is only grabbed once, and cached.
 */
TagAutoComplete.prototype.doLookup = function() {
    if (this.IS_PROCESSING) return;
    if (this.cache || this.doneCaching) return;

    var qs = new QueryString("");
    qs.add(TagConstants.pTAG_SCOPE_MODE, this.tagMode);
    var servlet = TagConstants.LOOKUP_TAGS_PAGE + qs.toString();
    this.IS_PROCESSING = true;
    var self = this;

    var requestHandler = function(request) {
        var resp = request.responseText;
        if (resp) {
            self.cache = resp.split(', ');
            self.filterDisplayResults();
        }
        self.doneCaching = true;
        self.IS_PROCESSING = false;
    }

    XBrowser.getHttpResponse(servlet, requestHandler);
}

/**
 * Hide the suggestion box and deselection suggestion.
 */
TagAutoComplete.prototype.doClear = function(){
    this.selection = false;
    this.results = false;
    this.lastSearched = false;
    this.showBox(false);
}

/**
 * Update the selected suggestion. Updates highlighing on suggestion rows accordingly.
 */
TagAutoComplete.prototype.updateSelection = function(index) {
    if (this.getRow(this.selection)) { // if something previously selected, unselect
        this.getRow(this.selection).className = TagAutoComplete.ROW_CSS_CLASS;
    }
    var row = this.getRow(index);
    if (!row) return;
    this.selection = index;
    row.className = TagAutoComplete.SELECTED_ROW_CSS_CLASS;
}

/**
 * Return the last word in the comma seperated list of tags from the text area.
 * Trims the whitespace around this element.
 */
TagAutoComplete.prototype.getCurrentWord = function() {
    if (!this.element || !this.element.value) return;
    var tags = this.element.value.split(",");
    return tags[tags.length-1].replace(/^\s+|\s+$/g,""); // trim spaces before/after word
}

/**
 * Search the cache for tags starting with the current word (see getCurrentWord)
 * If the new search string matches beginning of the last search string, it will
 * do an incremental search on the results of the last search
 * If not, it will do a brute force search.
 *
 * With 500 tags, this is not a very big issue, but might become an issue in the future.
 * Might want to use a data structure like a trie to  easily narrow down results and
 * backtrack as necessary.
 */
TagAutoComplete.prototype.filterDisplayResults = function() {
    if (!this.cache) {
        this.results = false;
        return; // need stuff in the cache
    }
    var val = this.getCurrentWord();
    if (this.results && this.lastSearched && TagAutoComplete.isMatch(this.lastSearched, val)) {
        var newresults = [];
        for (var i = 0; i < this.results.length; i++) {
            var string = this.results[i];
            if (TagAutoComplete.isMatch(val, string)) {
                newresults.push(this.results[i]);
            }
        }
        this.results = newresults;
    } else {
        this.results = [];
        for (var i = 0; i < this.cache.length; i++) {
            var string = this.cache[i];
            if (TagAutoComplete.isMatch(val, string)) {
                this.results.push(string);
            }
        }
        this.results.sort(function(a,b) { // case insensitive compare
                var aNorm = a.toLowerCase();
                var bNorm = b.toLowerCase();
                if (aNorm == bNorm) return 0;
                return (aNorm > bNorm) ? 1 : -1;
            });
    }

    this.lastSearched = val;
    this.displayResults(this.results);
}

/**
 * Get the id of the suggestion row with index
 */
TagAutoComplete.prototype.getRowId = function(index) {
    return this.id + TagAutoComplete.ROW_ID + index;
}

/**
 * Get the DOM node for the suggestion row
 */
TagAutoComplete.prototype.getRow = function(index) {
    return document.getElementById(this.getRowId(index));
}

// EVENTS (called from within the context of this class)

/**
 * Called by the (yes, you guessed it) key up listener.
 * Calls the enter/tab/esc keys accordingly, or updates the suggestions for the
 * new string.
 */
TagAutoComplete.prototype.onKeyUp = function(event){
    if (!event || !event.keyCode) return;

    this.captureKeyPress(event);

    var inIME = this.inKeyIME;
    this.inKeyIME = false;

    var val = this.element.value;
    if (this.IS_PROCESSING) {
        return;
    } else if (!inIME && TagAutoComplete.isComplete(event)) {
        this.complete();
        return;
    } else if (TagAutoComplete.isNavigation(event)) {
        this.handleNav(event);
        return;
    } else if (TagAutoComplete.isEscape(event) || !this.checkCursorAtEnd()) {
        this.doClear();
        return;
    } else if (TagAutoComplete.isIgnore(event)) {
        return;
    } else if (inIME && event.keyCode != KEY_ENTER) {
        return;
    }

    if (!this.cache) {
        this.doLookup();
    }

    this.resizeTextArea();

    if (val != null && val.length >= TagAutoComplete.MIN_LENGTH_THRESHOLD){
        this.filterDisplayResults();
    } else if (val == null || val.length < TagAutoComplete.prototype.MIN_LENGTH_THRESHOLD || TagAutoComplete.EMPTY.exec(val)){
        this.doClear();
    }
}

/**
 * Auto-complete with the current suggestion: replace the partially entered
 * suggestion with the text of the chosen suggestion and close suggestion box.
 */
TagAutoComplete.prototype.complete = function() {
    if (this.selection === null || this.selection === false) return;
    if (this.selection < 0 || this.selection >= this.results.length) return;

    var suggestion = this.results[this.selection];
    this.completeText(suggestion);
    this.doClear();
    this.element.focus();

    if (XBrowser.userAgent.isSafari) {
        this.element.selectionStart = this.element.value.length;
        this.element.selectionEnd = this.element.value.length;
    }
}

/**
 * Handles the string substitution for completing the partially typed
 * tag with the chosen suggestion.
 */
TagAutoComplete.prototype.completeText = function(text) {
    var values = this.element.value.split(',');
    if (values.length <= 1) {
        values = [text];
    } else {
        values[values.length-1] = ' '+text;
    }
    this.element.value = values.join(',')+', ';
    this.resizeTextArea();
}

/**
 * Called when focus moves away from our text area. Closes the suggestion box.
 * There's a delay associated with this to allow clicks to be processed on the
 * suggestion box, otherwised it's closed before the event can be caught.
 */
TagAutoComplete.prototype.onBlur = function() {
    var self = this;
    var handler = function() { self.doClear(); }
    setTimeout(handler, 200);
}

/**
 * Handle the up and down navigation keys. Wraps around the suggestion box (going up at the top
 * will go back to the bottom).
 */
TagAutoComplete.prototype.handleNav = function(event) {
    if (!event || !event.keyCode) return;
    if (!this.results || (this.results.length == 0)) return;

    var lastIndex = (this.results.length > TagAutoComplete.MAX_SUGGESTIONS) ?
                        TagAutoComplete.MAX_SUGGESTIONS - 1: this.results.length - 1;

    var keyCode = event.keyCode;
    var newSelect = this.selection;
    if (keyCode == KEY_ARROW_U) {
        if (newSelect === false) { // nothing selected yet
            newSelect = lastIndex;
        } else {
            newSelect--;
        }
    } else if (keyCode == KEY_ARROW_D) {
        if (newSelect === false) {
            newSelect = 0;
        } else {
            newSelect++;
        }
    }

    if (newSelect > lastIndex) {
        newSelect = 0;
    } else if (newSelect < 0) {
        newSelect = lastIndex;
    }

    this.updateSelection(newSelect);
}

// BOXES
TagAutoComplete.prototype.makeBox = function() {
    // div for the contents
    this.box = document.createElement("div");
    this.box.id = this.id+TagAutoComplete.BOX_ID;
    this.box.className = TagAutoComplete.BOX_CSS_CLASS;
    document.body.appendChild(this.box);
    // add event handler
    var self = this;
    addEvent(this.box, 'click', function() { self.complete(); });
    this.box = new iframeShim(this.box);
    return this.box;
}

TagAutoComplete.prototype.moveBox = function(top, left){
    if (this.box){
        this.box.setStyle('top', top + "px");
        this.box.setStyle('left', left + "px");
    }
}

TagAutoComplete.prototype.showBox = function(isVisible){
    var disp = isVisible ? "block" : "none";

    if (this.box){
        this.box.setStyle('display', disp);
    }
}

/**
 * Prevent the navigation and tab/enter keys from being handled
 * @param event event object for the key/up/down/press
 * @param boolean set to true, if you want to execute keyPressCallback as necessary
 */
TagAutoComplete.prototype.captureKeyPress = function(event, isKeyPress) {
    if (!event || (!event.charCode && !event.keyCode)) {
        return;
    }
    var code = event.charCode ? event.charCode : event.keyCode;
    // If we get a KEY_PROCESS in a keydown, then the user is using
    // IME to input characters like Japanese Hiragana, and therefore
    // we'll need to ignore the ending enter as it's part of character entry
    // http://bugforce.soma.salesforce.com/bug/bugDetail.jsp?id=100000000000qY0
    if (!isKeyPress && code == KEY_PROCESS) {
        this.inKeyIME = true;
    }
    if (this.selection === false) {
        if (isKeyPress && this.keyPressCallback) this.keyPressCallback(event);
        return;
    }

    if (code == KEY_ENTER || code == KEY_TAB || code == KEY_ARROW_U || code == KEY_ARROW_D || code == KEY_ESC) {
        TagAutoComplete.stopBubble(event);
    }
}

/**
 * Return true if there is no text after cursor in input element (excluding spaces).
 * If 1 or more characters are selected, returns false.
 * Note: Behavior is undefined if the element does not have focus, so make sure it does.
 */
TagAutoComplete.prototype.checkCursorAtEnd = function() {
    if (!this.element) return false;
    var afterCaret;
    if (XBrowser.userAgent.isIE) {
        var selRange = document.selection.createRange().duplicate();
        if (selRange.text && (selRange.text.length > 0)) return false; // text selected
        var textRange = selRange.duplicate();
        textRange.moveToElementText(this.element);
        try { // setEndPoint is known throw exceptions on bad days
            selRange.setEndPoint("EndToEnd", textRange);
            afterCaret = selRange.text;
        } catch (e) {
            return true;
        }
    } else { // life's so much better with Firefox
        if (this.element.selectionStart != this.element.selectionEnd) return false; // text selected
        afterCaret = this.element.value.substring(this.element.selectionStart);
    }
    return TagAutoComplete.EMPTY.exec(afterCaret);
}

// STATIC METHODS
TagAutoComplete.isNavigation = function(event){
    var code = event.keyCode;
    return (code == KEY_ARROW_U || code == KEY_ARROW_D);
}

// 9 is TAB; 16 is SHIFT-TAB
TagAutoComplete.isIgnore = function(event){
    var code = event.keyCode;
    return (code == 16 || (code >= 33 && code <= 46) || (code >= 112 && code <= 123));
}

TagAutoComplete.isEscape = function(event){
    var code = event.keyCode;
    return code == KEY_ESC;
}

/**
 * Tab/enter keys execute auto complete.
 * Checks if the current keystroke is tab or enter.
 */
TagAutoComplete.isComplete = function(event){
    var code = event.keyCode;
    return (code == KEY_ENTER || code == KEY_TAB);
}

/**
 * Return the normalized version of the given tag.
 */
TagAutoComplete.normalize = function(tag) {
    return tag.replace(/\s|-|_/g,"").toLowerCase()
}

/**
 * Return true if substring matches the beginning of string. Case insensitive.
 * Ex. if substring='abc' and string='AbCdef' then this will return true.
 */
TagAutoComplete.isMatch = function(substring, string) {
    if (!substring || !string) return false;
    substring = TagAutoComplete.normalize(substring);
    string = TagAutoComplete.normalize(string);
    if (substring.length > string.length) return false;
    return (string.indexOf(substring) === 0);
}

/**
 * Stops bubbling on the event and prevents default browser behavior at the same time.
 */
TagAutoComplete.stopBubble = function(event) {
    if (XBrowser.userAgent.isIE) {
        event.returnValue = false;
        event.cancelBubble = false;
    } else {
        event.preventDefault();
        event.stopPropagation();
    }
}

/*
    This controls the greying out of certain checkboxes on the user edit page according to
    the license type that's picked by the user.

    @param picklistID. 	String.  The ID of the picklist that controls the user's license types.
    @param dataMap.		Map.     The control data.  It should be a map from picklist values to
                                 an array of the dom ids of checkboxes that should be disabled if that
                                 picklist values is checked.  For instance, if the 'mktUser'
                                 and 'offline' should be disabled when the option in picklistID with the
                                 value '0' is selected, the checkbox 'other' should be disabled when
                                 '1' is selected, and nothing should be greyed when '2' is selected,
                                 then the map should look like this:

                                {
                                  '0' : ['mktUser', 'offline'],
                                  '1' : ['other'],
                                  '2' : []
                                }
    @author emoses
    @since 144
*/
function UserEdit(picklistId, dataMap){
    var self = this;

    self.picklist = document.getElementById(picklistId);
    self.controlMap = dataMap;

    if (!(self.picklist && self.controlMap)) return;
    self.allCheckboxes = null;

    function initAllChecks(){
        self.allCheckboxes = {};
        for (var val in self.controlMap){
            for (var i = 0; i < self.controlMap[val].length; i++){
                var controlId = self.controlMap[val][i];
                var control = (document.getElementById(controlId));
                if (control){
                    self.allCheckboxes[controlId] = true;
                }
            }
        }
    }

    this.handleSelectChange = function(e){
        var curr = self.picklist.options[self.picklist.selectedIndex];
        if (curr.value && curr.value.length > 0){
            self.setChecksTo(curr.value);
        } else {
            self.resetChecks();
        }
    }

    initAllChecks();
    addEvent(self.picklist, "change", this.handleSelectChange, false);
    self.handleSelectChange(null);
}

UserEdit.prototype.resetChecks = function(){
    for (var id in this.allCheckboxes){
        document.getElementById(id).disabled = false;
    }
}

UserEdit.prototype.setChecksTo = function(setTo){
    this.resetChecks();
    if (!(setTo in this.controlMap)) return;
    var idsToDisable = this.controlMap[setTo];
    for (var i = 0; i < idsToDisable.length; i++){
        var control = document.getElementById(idsToDisable[i]);
        if (control) {
            control.disabled = true;
            if (control.checked){
                control.checked = false;
            }
        }
    }
}
/*
 * History Storage for ajax based states
 */
/** 
   Material Copyrighted  2005, Brad Neuberg, bkn3@columbia.edu  
   Modified by salesforce.com 2007
   --------------------------------STARTS HERE-----------------------------------------

   Copyright (c) 2005, Brad Neuberg, bkn3@columbia.edu
   http://codinginparadise.org
   
   Permission is hereby granted, free of charge, to any person obtaining 
   a copy of this software and associated documentation files (the "Software"), 
   to deal in the Software without restriction, including without limitation 
   the rights to use, copy, modify, merge, publish, distribute, sublicense, 
   and/or sell copies of the Software, and to permit persons to whom the 
   Software is furnished to do so, subject to the following conditions:
   
   The above copyright notice and this permission notice shall be 
   included in all copies or substantial portions of the Software.
*/ 
DhtmlHistory.POLLING_FREQUENCY = 300;
DhtmlHistory.WAIT_FREQUENCY = 500;
 function DhtmlHistory(storageMap, listenerFunction, parentObject) {
   this.locationOfBlankPage = "/back_blank.html?";
	/** Our current hash location, without the "#" symbol. */
   this.currentLocation = null;
   this.listener = listenerFunction;
   /** A hidden IFrame we use in Internet Explorer to detect history
       changes. */
   this.iframe = null;
   /** Indicates to the browser whether to ignore location changes. */
   this.ignoreLocationChange = false;
   /** The amount of time in milliseconds an add request has to wait in line before being
       run on a window.setTimeout. */
   this.currentWaitTime = 0;
   this.historyStorage = storageMap;
   // initialization
   this.parentObject = parentObject;
   this.create();
}

DhtmlHistory.prototype.add = function(newLocation, historyData) {	
	// most browsers require that we wait a certain amount of time before changing the
	// location, such as 200 milliseconds; thus we internally handle this
	// detail by using a 'currentWaitTime' variable and have requests wait in line
	var self = this;
	var addImpl = function() {
	   // indicate that the current wait time is now less
	   if (self.currentWaitTime > 0) {
	      self.currentWaitTime = self.currentWaitTime - DhtmlHistory.WAIT_FREQUENCY;
	   }
	   // remove any leading hash symbols on newLocation
	   newLocation = self.removeHash(newLocation);
	   var idCheck = document.getElementById(newLocation);
	   if (idCheck) {
	      Gack.sendGack("History locations can not have the same value as any id's that might be in the document");
	      return; 
	   }
	   self.historyStorage[newLocation] = historyData;
	   // indicate to the browser to ignore this upcomming 
	   // location change
	   self.ignoreLocationChange = true;
	   // save this as our current location
	   self.currentLocation = newLocation;
	   // change the browser location
	   window.location.hash = newLocation;
	   // change the hidden iframe's location if on IE
	   if (XBrowser.userAgent.isIE){
	   		// write out a hidden iframe for IE and
	   		if(!self.iframe) {
		      	var b = document.getElementsByTagName('body')[0];
		      	if(!b){ return; }
		        var divElem = document.createElement('div');
		       	b.appendChild(divElem);
		       	divElem.style.display = 'none';
		        divElem.innerHTML = "<iframe class='dhtmlHistoryFrame' name='DhtmlHistoryFrame' id='DhtmlHistoryFrame' "
		                               + "src='"+ self.locationOfBlankPage + newLocation + "'></iframe>";
		         self.iframe = document.getElementById("DhtmlHistoryFrame");
	   	  } else {	
	      	self.iframe.src = self.locationOfBlankPage + newLocation;
	   	  }
	   }
	};
	// now execute this add request after waiting a certain amount of time, so as to
	// queue up requests
	 window.setTimeout(addImpl, this.currentWaitTime);
	 // indicate that the next request will have to wait for awhile
	 this.currentWaitTime = this.currentWaitTime + DhtmlHistory.WAIT_FREQUENCY;
}

/** Gets the current hash value that is in the browser's
       location bar, removing leading # symbols if they are present. */
DhtmlHistory.prototype.getCurrentLocation = function() {
	return this.removeHash(window.location.hash);
}
   
DhtmlHistory.prototype.create = function() {

      var initialHash = this.getCurrentLocation();
      this.currentLocation = initialHash;
      this.ignoreLocationChange = true;
      if(!XBrowser.userAgent.isIE){
      	var self = this;
      	var locationHandler = function() {
       	 	self.checkLocation();
      	};
      	setInterval(locationHandler, DhtmlHistory.POLLING_FREQUENCY);
      }
}
   
DhtmlHistory.prototype.fireHistoryEvent = function(oldHash, newHash) {
    this.listener.call(this.parentObject, oldHash, newHash);
}

DhtmlHistory.prototype.shouldProceedWithHistoryEvent = function () {
	if (this.ignoreLocationChange) {
       this.ignoreLocationChange = false;
       return false;
    } else {
    	return true;
    }
}

DhtmlHistory.prototype.checkLocation = function() {
   	if (XBrowser.userAgent.isIE || !this.shouldProceedWithHistoryEvent()){ return; }
    var hash = this.getCurrentLocation();
    if (hash == this.currentLocation) { return; }
    // save this new location
    var oldHash = this.currentLocation;
    this.currentLocation = hash;
    this.fireHistoryEvent(oldHash, hash);
}  
   
DhtmlHistory.prototype.removeHash = function(hashValue) {
    if (!hashValue){return null;}
    else if (hashValue == "" ||  (hashValue.length == 1 && hashValue.charAt(0) == "#")) { return ""; } 
    else if (hashValue.length > 1 && hashValue.charAt(0) == "#") { return hashValue.substring(1);} 
    else { return hashValue; }     
}          
   
DhtmlHistory.prototype.iframeLoaded = function(newLocation) {
    if (!XBrowser.userAgent.isIE || !this.shouldProceedWithHistoryEvent()){ return; }
    // get the new location
    var hash = new String(newLocation.search);
    if (!hash || (hash.length == 1 && hash.charAt(0) == "?")) {
       hash = "";
    } else if (hash.length >= 2 && hash.charAt(0) == "?") {
       hash = hash.substring(1);
    }
    
   	var oldHash = this.removeHash(window.location.hash);
    window.location.hash = hash;
    this.fireHistoryEvent(oldHash, hash);
}
/**
 * Material Copyrighted  2005, Brad Neuberg, bkn3@columbia.edu 
 * Modified by salesforce.com 2007
 * 
 * --------------------------------ENDS HERE-----------------------------------------
 */

function SchedulePageUtil() {}

SchedulePageUtil.clickExpand = function() {
	Animation.rollIn(document.getElementById(SchedulePage.pDuelOuter), function() {});
}

SchedulePageUtil.clickCollapse = function() {
	Animation.rollOut(document.getElementById(SchedulePage.pDuelOuter), function() {});
}

SchedulePageUtil.disableTime = function(suffix) {
	document.getElementById(ScheduleElement.pPrefTime + suffix).value = '';
	document.getElementById(ScheduleElement.pPrefTime + suffix).style.display = 'none';
	document.getElementById(ScheduleElement.pPrefTime + suffix).disabled = true;

	document.getElementById(ScheduleElement.pOtherPrefTimeLabelDiv + suffix).style.display = 'none';
	document.getElementById(ScheduleElement.pPrefTimeLabelDiv + suffix).style.display = 'block';
}

SchedulePageUtil.enableTime = function(suffix) {
	document.getElementById(ScheduleElement.pPrefTimeLabelDiv + suffix).style.display = 'none';
	document.getElementById(ScheduleElement.pOtherPrefTimeLabelDiv + suffix).style.display = 'none';

	//start loading
	document.getElementById(ScheduleElement.pPrefTimeLoadingDiv + suffix).style.display = 'block';

	var saveData = SchedulePageUtil.buildPost(suffix);
	XBrowser.postHttpResponse(BlowoutServlet.SERVLETURL,
                                  function(response) { SchedulePageUtil.handleResponse(suffix, response.responseText); },
                                  XBrowser.buildPost(saveData),
                                  // check the errorMsg??
                                  null
                                  );
	return false;
}

SchedulePageUtil.buildPost = function(suffix) {
	var saveData = {};
	saveData[BlowoutServlet.SUFFIX] = suffix;
	saveData[SchedulePage.pBlowout] = document.forms['editPage'].elements[SchedulePage.pBlowout].value;
	saveData[ScheduleElement.pFreq + suffix] = SchedulePageUtil.getCheckedValue(ScheduleElement.pFreq + suffix);
	saveData[ScheduleElement.pStartDate + suffix] = document.forms['editPage'].elements[ScheduleElement.pStartDate + suffix].value;
	saveData[ScheduleElement.pEndDate + suffix] = document.forms['editPage'].elements[ScheduleElement.pEndDate + suffix].value;
	saveData[ScheduleElement.pDailyRec + suffix] = SchedulePageUtil.getCheckedValue(ScheduleElement.pDailyRec + suffix);
	//saveData[ScheduleElement.pDailyEveryNDays + suffix] = document.forms['editPage'].elements[ScheduleElement.pDailyEveryNDays + suffix].value;

	for (var i = 0; i < 7; i++) {
		saveData[ScheduleElement.pDayOfWeek + i + suffix] = document.forms['editPage'].elements[ScheduleElement.pDayOfWeek + i + suffix].checked ? '1' : '0';
	}

	saveData[ScheduleElement.pMonthlyRec + suffix] = SchedulePageUtil.getCheckedValue(ScheduleElement.pMonthlyRec + suffix);
	saveData[ScheduleElement.pMonthlyOnDayN + suffix] = document.forms['editPage'].elements[ScheduleElement.pMonthlyOnDayN + suffix].value;
	saveData[ScheduleElement.pMonthlyOnNthDay + suffix] = document.forms['editPage'].elements[ScheduleElement.pMonthlyOnNthDay + suffix].value;
	saveData[ScheduleElement.pMonthlyOnNDayOfWeek + suffix] = document.forms['editPage'].elements[ScheduleElement.pMonthlyOnNDayOfWeek + suffix].value;
    saveData[SchedulePage.pJobType] = document.forms['editPage'].elements[SchedulePage.pJobType].value;

    return saveData;
}

SchedulePageUtil.getCheckedValue = function(paramName) {
	var params = document.forms['editPage'].elements[paramName];

	if (params.length == null) {
		if (params.checked) return params.value;
	} else {
		for (var i = 0; i < params.length; i++) {
			if (params[i].checked) return params[i].value;
		}
	}
	return '';
}

SchedulePageUtil.handleResponse = function(suffix, responseText) {
    var response = null;
    try {
    	response = Util.evalAjaxServletOutput(responseText);
    } catch (err) {
		if (window.location.replace){
			window.location.replace(window.location);
		} else {
			window.location.href = window.location.href;
		}
    	return;
    }

    //stop loading
	document.getElementById(ScheduleElement.pPrefTimeLoadingDiv + suffix).style.display = 'none';

    if (response[BlowoutServlet.SUCCESS]) {
    	SchedulePageUtil.setTimePicklist(suffix, response[BlowoutServlet.BLOWOUT]);
    	document.getElementById(ScheduleElement.pPrefTime + suffix).disabled = false;
    	document.getElementById(ScheduleElement.pPrefTime + suffix).style.display = 'block';
    } else {
    	document.getElementById(ScheduleElement.pPrefTimeLabelDiv + suffix).style.display = 'block';
    }
    SchedulePageUtil.handleErrors(response);
}

SchedulePageUtil.setTimePicklist = function(suffix, values) {
	var options = document.getElementById(ScheduleElement.pPrefTime + suffix).options;

	//remove everything
	options.length = 0;

	if (values.length == 0) {
		options[0] = new Option(LC.getLabel('SelectElement', 'Required'), '');
	} else {
		for (var i = 0; i < values.length; i++) {
			options[i] = new Option(values[i], values[i]);
		}
	}
}

SchedulePageUtil.handleErrors = function(response) {
    var specific = response[AjaxServlet.ERROR_MSG_KEY];

    if (specific instanceof Array) {
    	if (specific.length > 3) {
    		document.getElementById(DetailElement.DEFAULT_ERROR_DIV_ID).style.display = 'block';
    	} else {
    		document.getElementById(DetailElement.DEFAULT_ERROR_DIV_ID).style.display = 'none';
    	}
	    for (var i = 0; i < specific.length; i++) {
	        var idAndVal = SchedulePageUtil.getIdAndVal(specific[i]);
	        SchedulePageUtil.setError(idAndVal[0], idAndVal[1]);
	    }
    } else {
    	//this is bad
    	//there are by default 3 elements in the array
    }
}

SchedulePageUtil.getIdAndVal = function(idVal) {
	return idVal.split(',');
}

SchedulePageUtil.setError = function(id, message) {
	//I have to get the div that this element is contained in.
	//Then search through that div and look for an errorMsg class
	//This is incrediby hacky and prone to error.
	var elem = null;
	if (document.getElementById(id).nodeName == "DIV") {
		elem = document.getElementById(id).parentNode
	} else {
		elem = document.getElementById(id).parentNode.parentNode;
	}
	var isErrorPresent = false;
	var errorLoc;
	for (var i = 0; i < elem.childNodes.length; i++) {
		if (elem.childNodes[i].className != null && elem.childNodes[i].className == "errorMsg") {
			isErrorPresent = true;
			errorLoc = i;
		}
	}

	//if the error is not there and we should be putting an error on the page, then create a new error div
    if (!isErrorPresent) {
    	if(message != '') {
	        var errorDiv = document.createElement("div");
		    errorDiv.className = "errorMsg";
		    errorDiv.innerHTML = message;
		    elem.appendChild(errorDiv);
    	}
    } else {
    	//if the error already exists on the page then simply show it
    	if(message != null) {
	        elem.childNodes[errorLoc].innerHTML = message;
	        elem.childNodes[errorLoc].style.display = "block";
    	} else {
    		elem.childNodes[errorLoc].style.display = "none";
    	}
    }
}



/**
* @author: mpolcari
* @since: 144
*/
function DeveloperNameInputElement() {}

DeveloperNameInputElement.setName = function(labelElement, developerNameElement, defaultName) {
  var ov = labelElement.value;
  var v =""
  var hasFirstChar = false;
  var lastCharIsUnderscore = false;
  if (developerNameElement.value.length == 0 && ov.length > 0) {
    for (i = 0; i < ov.length; i++) {
      var ch = ov.charAt(i);
      if ((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || (ch >= '0' && ch <= '9')) {
          //                copy char if alphanumeric
        if (!hasFirstChar && (ch >= '0' && ch <= '9')) {
          //                  first char must be letter
          v += 'X';
        }
        v += ch;
        hasFirstChar = true;
        lastCharIsUnderscore = false;
      } else if (hasFirstChar && !lastCharIsUnderscore) {
          //                convert non-alphanumeric char to underscore, except that first char must not be underscore, and no consecutive underscores
        v += '_';
        lastCharIsUnderscore = true;
      }
    }
    if (!hasFirstChar) {
          //              if there is no alphanumeric chars, use the default
      developerNameElement.value = defaultName ;
    } else if (lastCharIsUnderscore) {
          //              make sure the last char is not an underscore
      developerNameElement.value = v.substring(0, v.length-1);
    } else {
      developerNameElement.value = v;
    }
  }
  return true;
}


SfdcElement = function() {};

SfdcElement.prototype.getElements = function(ids) {
    var elements = [];
    for (var n = 0; n < ids.length; n++) {
         elements.push(document.getElementById(ids[n]))
    }
    return elements;
}

SfdcElement.prototype.setVisibleElementsById = function(ids, show) {
    SfdcElement.prototype.setVisibleElements(SfdcElement.prototype.getElements(ids), show);
}

SfdcElement.prototype.setVisibleElements = function(elements, show) {
    for (var n = 0; n < elements.length; n++) {
        elements[n].style.visibility = (show) ? 'visible' : 'hidden'
    }
}

SfdcElement.prototype.setDisplayElementsById = function(ids, display) {
    SfdcElement.prototype.setDisplayElements(SfdcElement.prototype.getElements(ids), display);
}

SfdcElement.prototype.setDisplayElements = function(elements, display) {
    for (var n = 0; n < elements.length; n++) {
        elements[n].style.display = (display) ? 'block' : 'none'
    }
}

SfdcElement.prototype.setDisabledById = function(ids, disabled){
    SfdcElement.prototype.setDisabled(SfdcElement.prototype.getElements(ids), disabled);
}

SfdcElement.prototype.setDisabled = function(elements, disabled){
    for (var n = 0; n < elements.length; n++) {
        elements[n].disabled = disabled;
    }
}


/**
 * JS for Page Layout Asssignment Page
 */

/**
 * @param pagePLAUrl paginated Page Layout assignment URL
 * @param rtPLAUrl jump to a specific record type
 */
function LayoutMapping(pagePLAUrl, rtPLAUrl, pageLayoutType, pageLayoutDetailUrl, viewProfileId, isEdit, pageNum,
	recordTypeFieldsUrl, sysAdminQS) {
	this.pagePLAUrl = pagePLAUrl;
	this.rtPLAUrl = rtPLAUrl;
	this.pageLayoutType = pageLayoutType;
	this.pageNum = pageNum;
	this.isEdit = isEdit;
	this.pageSize = Cookies.prototype.GetCookie(LayoutMapping.PAGE_SIZE_COOKIE_NAME);
	if (!this.pageSize) {
		this.pageSize = LayoutMapping.DEFAULT_PAGE_SIZE;
	}
	this.profiles = null;
	this.recordTypes = null;
	this.pageLayouts = null;
	this.pageLayoutsMap = new Object();
	this.mapping = new Object();
	this.beginIndex = 0; // inclusive on recordtypes
	this.endIndex = 0; // exclusive on recordtypes
	this.pageLayoutQS = new QueryString(pageLayoutDetailUrl.substring(pageLayoutDetailUrl.indexOf('?') + 1));
	this.pageLayoutDetailUrl = pageLayoutDetailUrl.substring(0, pageLayoutDetailUrl.indexOf('?'));
	this.recordTypeFieldsQS = new QueryString(recordTypeFieldsUrl.substring(recordTypeFieldsUrl.indexOf('?') + 1));
	this.recordTypeFieldsUrl = recordTypeFieldsUrl.substring(0, recordTypeFieldsUrl.indexOf('?'));
	this.viewProfileId = viewProfileId; // profile and all its pla cells to highlight in view mode
	this.sysAdminQS = new QueryString(sysAdminQS.substring(sysAdminQS.indexOf('?') + 1));

	// mouse move cell selection
	this.cellMouseDown = false;
	this.origCell = null;
	this.curTarget = null;
	// click/ctrl+click/shift+click cell selection
	this.curCell = null;
	// select rows, click/ctrl+click/shift+click
	this.curRow = null;
	this.selectedRows = new Map();
	// select cols, click/ctrl+click/shift+click
	this.curCol = null;
	this.selectedCols = new Map();
	// selected cells and changed cells
	this.selected = new Map();
	this.profileRecordTypeSelected = new Map();
	this.recordTypeProfileSelected = new Map();
	this.changed = new Map();
}

LayoutMapping.CELLS_LIMIT = 2000;

LayoutMapping.DEFAULT_PAGE_SIZE = 4;

LayoutMapping.PAGE_SIZE_COOKIE_NAME = 'plaPageSize';

LayoutMapping.CELL_EVENT_HANDLER_HTML = " onmousedown=\"if(layoutMapping){layoutMapping.resetPageLayoutSelector(); layoutMapping.cellHandleMouseDown(event,this);}\" "
	+ "onmousemove=\"if(layoutMapping){layoutMapping.cellHandleMouseMove(event,this);}\" "
	+ "onmouseup=\"if(layoutMapping){layoutMapping.cellHandleMouseUp(event, this);}\" ";

LayoutMapping.PROFILE_HEADER_EVENT_HANDLER_HTML = " onclick=\"if(layoutMapping){layoutMapping.resetPageLayoutSelector(); layoutMapping.handleClickProfileHeader(event, this);}\" ";

LayoutMapping.RT_HEADER_EVENT_HANDLER_HTML = " onclick=\"if(layoutMapping){layoutMapping.resetPageLayoutSelector(); layoutMapping.handleClickRTHeader(event, this);}\" ";

LayoutMapping.EMPTY_KEY = "000000000000000";

LayoutMapping.PROFILE_HEADER_BASE_CLASS_NAME = " profileHeader ";

LayoutMapping.RT_HEADER_BASE_CLASS_NAME = " rtHeader ";

LayoutMapping.MASTER_RT_HEADER_BASE_CLASS_NAME = " pHeader rtHeader ";

LayoutMapping.prototype.getPageLayoutAssignment = function (profileId, recordTypeId) {
	if (!this.mapping) {
		return null;
	}
	var key = profileId + "_" + recordTypeId;
	var mappingVal = this.mapping[key];
	var changedMappingVal = this.changed.map[key];
	if (changedMappingVal) {
		mappingVal = changedMappingVal;
	}
	if (!mappingVal || !this.pageLayoutsMap) {
		return null;
	}
	return this.pageLayoutsMap[mappingVal.plId];
}

LayoutMapping.prototype.fetchMappingPage = function (showLoadingOverlay) {
	var qs = new QueryString("");
	qs.add('type', this.pageLayoutType);
	qs.add('pageNum', this.pageNum);
	qs.add('pageSize', this.pageSize);

	if (showLoadingOverlay) {
		var plaContainerEl = document.getElementById('plaContainer');
		this.drawLoadingOverlay(plaContainerEl);
	}

	var lm = this;
	XBrowser.getHttpResponse(this.getUrl(this.pagePLAUrl, qs), function(req) {lm.processMappingData(req);});
}

LayoutMapping.prototype.getChunk = function (direction) {
	this.resetSelectionStartPoints();
	if (direction < 0) { // previous
		if (this.pageNum == 0)
			return;
		this.pageNum = this.pageNum - 1;
	} else { // next
		this.pageNum =  this.pageNum + 1;
	}
	this.fetchMappingPage(true);
}

LayoutMapping.prototype.processMappingData = function (request) {
	// json
	var response = Util.evalAjaxServletOutput(request.responseText);

	// page number
	this.pageNum = response.pageNum;

	// profile
	this.profiles = response.profiles;

	// record type
	this.recordTypes = response.recordTypes;
	this.beginIndex = this.pageNum * this.pageSize;
	this.endIndex = this.beginIndex + this.pageSize;
	if (this.endIndex > this.recordTypes.length) {
		this.endIndex = this.recordTypes.length;
	}

	// page layout
	this.pageLayouts = response.pageLayouts;
	for (var i = 0; i < this.pageLayouts.length; i++) {
		this.pageLayoutsMap[this.pageLayouts[i].id] = this.pageLayouts[i];
	}

	// mapping
	for (var i = 0; i < response.mapping.length; i++) {
		var key = response.mapping[i].pId + '_' + response.mapping[i].rtId;
		this.mapping[key] = response.mapping[i];
	}

	// hide loading indicator if needed
	var loadingDivEl = document.getElementById('loadingDiv');
	if (loadingDivEl) {
		if (loadingDivEl.style.display != 'none') {
			loadingDivEl.style.display = 'none';
		}
	}

	// rendering
	if (this.isEdit) {
		var pageLayoutSelectorSpan = document.getElementById('pageLayoutSelectorSpan');
		pageLayoutSelectorSpan.innerHTML = this.getPageLayoutSelectorHTML();
	}
	this.selectInitProfileRow();
	this.drawTable();
	this.setHeadersWidth();
	var lm = this;
	window.onresize = function(event) { lm.setHeadersWidth(); };
}

LayoutMapping.prototype.switchToEditMode = function () {
	var qs = new QueryString("");
	qs.add("type", this.pageLayoutType);
	qs.add("e", 1);
	qs.add("pageNum", this.pageNum);
	if (this.viewProfileId) {
		qs.add("pid", this.viewProfileId);
	}

	var url = location.href.substring(0, location.href.indexOf('?'));
	location.href = url + qs.toString();
}

//---------------------------------//
// Rendering                       //
//---------------------------------//
LayoutMapping.prototype.drawTable = function () {
	var w = [];

	w.push("<div id=\"plaHeaderDiv\" class=\"plaHeader\">");
	w.push("<table id=\"plaHeaderTable\" cellpadding=\"0\" cellspacing=\"0\">");
	this.drawTableHeader(w);
	w.push("</table></div>");
	w.push("<div id=\"plaBodyDiv\" class=\"plaBody\">");
	w.push("<table id=\"plaBodyTable\" cellpadding=\"0\" cellspacing=\"0\" width=\"100%\">");
	w.push("<tbody>");
	for (var i = 0; i < this.profiles.length; i++) {
		w.push("<tr>");
		w.push(this.getProfileHTML(this.profiles[i]));
		for (var j = this.beginIndex; j < this.endIndex; j++) {
			var pageLayout = this.getPageLayoutAssignment(this.profiles[i].id, this.recordTypes[j].id);
			var highLight = (this.profiles[i].id == this.viewProfileId);
			if (!highLight) {
				highLight = (LayoutMappingHelper.getCellId(this.profiles[i].id, this.recordTypes[j].id) in this.selected.map);
			}
			this.drawPageLayoutCell(w, this.profiles[i].id, this.recordTypes[j].id, pageLayout, highLight);
		}
		w.push("</tr>");
	}
	w.push("</tbody>");
	w.push("</table>");
	w.push("</div>");
	var containerElem = document.getElementById("plaContainer");
	containerElem.innerHTML = w.join('');
}

LayoutMapping.prototype.drawLoadingOverlay = function (el) {
	if (!el) {
		return;
	}

	var loadingOpacityEl = this.createLoadingDivEl(el);
	loadingOpacityEl.className = "loadingOverlayDiv loadingOverlayDivOpacity";

	var loadingClearEl = this.createLoadingDivEl(el);
	loadingClearEl.className = "loadingOverlayDiv";

	var description = LC.getLabel("Global", "loading");

	var loadingHolder = document.createElement('span');
	loadingClearEl.appendChild(loadingHolder);
	loadingHolder.className = 'loadingHolder';

	var loadingImage = document.createElement('img');
	loadingHolder.appendChild(loadingImage);
	loadingImage.src = '/img/loading.gif';
	loadingImage.className  = 'loadingImage';

	var loadingDescription = document.createElement('span');
	loadingHolder.appendChild(loadingDescription);
	loadingDescription.innerHTML =  description;
	loadingDescription.className  = 'loadingDescription';
}

LayoutMapping.prototype.createLoadingDivEl = function (el) {
	var loadingDivEl = document.createElement('div');
	el.appendChild(loadingDivEl);
	var height = el.offsetHeight;
	if (XBrowser.userAgent.isIE) {
		height = el.offsetHeight - 15;
	}
	loadingDivEl.style.width = el.offsetWidth + "px";
	loadingDivEl.style.height = height + "px";

	return loadingDivEl;
}

LayoutMapping.prototype.drawPageLayoutCell = function (w, profileId, recordTypeId, pageLayout, highLight) {
	var isChanged = this.changed.map[profileId + "_" + recordTypeId];
	w.push("<td id=\"" + LayoutMappingHelper.getCellId(profileId, recordTypeId) + "\" class=\""
		+ (isChanged ? " changedCell ": "") + (highLight ? " selectedCell " : "") + "\" "
		+ (this.isEdit ? LayoutMapping.CELL_EVENT_HANDLER_HTML : "") + ">");
	if (pageLayout == undefined) {
		w.push(LC.getLabel("LayoutMap", "NotAssigned"));
	} else {
		if (!this.isEdit) {
			this.pageLayoutQS.add("type", this.pageLayoutType);
			this.pageLayoutQS.add("lid", pageLayout.id);
			w.push("<a href=\"" +  (this.pageLayoutDetailUrl + this.pageLayoutQS.toString()) + "\">"
				+ pageLayout.name + "</a>");
		} else {
			w.push(pageLayout.name);
		}
	}
	w.push("</td>");
}

LayoutMapping.prototype.drawTableHeader = function (w) {
	if (this.recordTypes.length > 1) { // has record types other than just master
		w.push("<thead><tr><th id=\"emptyHeader\" class=\"prtHeader\"><div/></th>");
		this.drawRecordTypeHeader(w);
		w.push("</tr>");
		w.push("<tr><th class=\"prtHeader\"><div>" + LC.getLabel("LayoutMap", "Profiles") + "</div></th>");
		for (var i = this.beginIndex; i < this.endIndex; i++) {
			w.push(this.getRecordTypeHTML(this.recordTypes[i]));
		}
		w.push("</tr></thead>");
	} else {
		w.push("<thead><tr><th class=\"\prtHeader\"><div>" + LC.getLabel("LayoutMap", "Profiles")
			+ "</div></th>");
		this.drawRecordTypeHeader(w);
		w.push("</tr></thead>");
	}
}

LayoutMapping.prototype.getRecordTypeHTML = function (recordType) {
	var className = this.getRecordTypeHeaderClassName(recordType.id);
	var rtHTML = [];
	rtHTML.push('<th' + (this.isEdit ? LayoutMapping.RT_HEADER_EVENT_HANDLER_HTML : "")
		+ " id=\"" + recordType.id + "\" class=\"rtHeader " + className + "\"><div title=\"" + recordType.name + "\">");
	if (!this.isEdit && recordType.id != LayoutMapping.EMPTY_KEY) {
		this.recordTypeFieldsQS.add('id', recordType.id);
		this.recordTypeFieldsQS.add('type', this.pageLayoutType);
		rtHTML.push('<a href=\"' + this.recordTypeFieldsUrl + this.recordTypeFieldsQS.toString() + '\">'
			+ recordType.name + '</a>');
	} else {
		rtHTML.push(recordType.name);
	}
	rtHTML.push('</div></th>');
	return rtHTML.join('');
}

LayoutMapping.prototype.getProfileHTML = function (profile) {
	var className = this.getProfileHeaderClassName(profile.id, this.viewProfileId);
	var profileHTML = [];
	profileHTML.push("<td class=\"profileHeader " + className + "\""
			+ (this.isEdit ? LayoutMapping.PROFILE_HEADER_EVENT_HANDLER_HTML : "")
			+ " id=\"" + profile.id + "\">");
	if (!this.isEdit) {
		profileHTML.push("<a href=\"" + this.getUrl('/' + profile.id, this.sysAdminQS) + "\">" + profile.name + "</a>");
	} else {
		profileHTML.push(profile.name);
	}
	profileHTML.push("</td>");
	return profileHTML.join('');
}

LayoutMapping.prototype.drawRecordTypeHeader = function(w) {
	if (this.recordTypes.length > 1) {
		w.push("<th id=\"recordTypesHeader\" colspan=\"" + (this.endIndex - this.beginIndex)
			+ "\"><table width=\"100%\" id=\"recordTypeHeader\"><thead><tr><th class=\"prtHeader alignLeft\">"
			+ LC.getLabel("LayoutMap", "RecordTypes")
			+ "</th><th class=\"navigationHeaderNormal\">");
		this.drawPrevNext(w);
		w.push("</th></tr></thead></table></th>");
	} else {
		var className = this.getRecordTypeHeaderClassName(this.recordTypes[0].id);
		w.push("<th class=\"pHeader rtHeader " + className + "\""
			+ (this.isEdit ? LayoutMapping.RT_HEADER_EVENT_HANDLER_HTML : "")
			+ " id=\"" + this.recordTypes[0].id + "\"><div>" + LC.getLabel("FLSLayout", "Layout") + "</div></th>");
	}
}

LayoutMapping.prototype.drawPrevNext = function(w) {
	if (this.pageNum > 0) {
		w.push("<a href=\"javascript: layoutMapping.getChunk(-1);\" id=\"plaPrevLink\">&lt;Prev</a>");
	} else {
		w.push("");
	}
	w.push(" (" + (this.beginIndex + 1) + "-" + this.endIndex + " of " + this.recordTypes.length + ") ");
	if (this.endIndex >= this.recordTypes.length) {
		w.push("");
	} else {
		w.push("<a href=\"javascript: layoutMapping.getChunk(1);\" id=\"plaNextLink\">Next&gt;</a>");
	}
}

LayoutMapping.prototype.getPageLayoutSelectorHTML = function () {
	var pageLayoutSelectorHTML = "<select id=\"pageLayoutSelector\" name=\"pageLayoutSelector\" onchange=\"layoutMapping.onChangePLA(this);\">";
	pageLayoutSelectorHTML += "<option selected=\"selected\" value=\"000000000000000\">"
		+ LC.getLabel("LayoutMap", "SelectOne") + "</option>";
	for (var i = 0; i < this.pageLayouts.length; i++) {
		pageLayoutSelectorHTML += "<option value=\"" + this.pageLayouts[i].id + "\">" + this.pageLayouts[i].name
			+ "</option>";
	}
	pageLayoutSelectorHTML += "</select>";
	return pageLayoutSelectorHTML;
}

//------------------------------------------//
// Fixed column header, Scrollable body     //
//------------------------------------------//
LayoutMapping.prototype.setHeadersWidth = function () {
	var plaBodyTableEl = document.getElementById('plaBodyTable');
	if (!plaBodyTableEl) {
		return;
	}
	var plaBodyDivEl = document.getElementById('plaBodyDiv');
	if (plaBodyDivEl) {
		if (plaBodyTableEl.clientHeight < 450) {
			plaBodyDivEl.style.height = plaBodyTableEl.clientHeight + "px";
		} else {
			plaBodyDivEl.style.height = "450px";
		}
	}

	var plaBodyTableBodyEl = plaBodyTableEl.getElementsByTagName('tbody')[0];
	var plaBodyTableFirstRowEl = plaBodyTableBodyEl.firstChild;
	var firstRowCells = plaBodyTableFirstRowEl.childNodes;
	var profileHeaderCell = firstRowCells[0];

	var plaHeaderTableEl = document.getElementById('plaHeaderTable');
	plaHeaderTableEl.style.display = "none";

	var plaHeaderTableHeaderEl = plaHeaderTableEl.getElementsByTagName('thead')[0];
	if (this.recordTypes.length > 1) {
		var emptyHeaderEl = document.getElementById('emptyHeader');
		emptyHeaderEl.firstChild.style.width = profileHeaderCell.clientWidth + "px";
		var recordTypeHeaderRowEl = plaHeaderTableHeaderEl.childNodes[1];
		var recordTypeCells = recordTypeHeaderRowEl.childNodes;
		for (var i = 0; i < firstRowCells.length; i++) {
			recordTypeCells[i].firstChild.style.width = firstRowCells[i].clientWidth + "px";
		}
	} else {
		var pageLayoutHeaderRowEl = plaHeaderTableHeaderEl.childNodes[0];
		var pageLayoutHeaderCells = pageLayoutHeaderRowEl.childNodes;
		for (var i = 0; i < firstRowCells.length; i++) {
			pageLayoutHeaderCells[i].firstChild.style.width = firstRowCells[i].clientWidth + "px";
		}
	}

	plaHeaderTableEl.style.display="";
}

//---------------------------------//
// Selection                       //
//---------------------------------//
// cell onmousedown
LayoutMapping.prototype.cellHandleMouseDown = function (ev, el) {
	this.clearTextSelection();
	this.curRow = null;
	this.curCol = null;

	this.cellMouseDown = true;
	this.curTarget = el;
	if (ev.shiftKey && this.curCell) { // shift+click following a click
		this.clearSelection();
		this.selectRange(el, this.curCell);
	} else {
		if (ev.ctrlKey) { // toggle selection, ctrl+click
			this.curCell = null;
			this.origCell = el; // start point for holding mouse down and move
			this.toggleCell(el.id);
		} else { // click or shift+click not following a click
			this.clearSelection();
			this.curCell = el; // for shift+click later
			this.origCell = el; // for cellHandleMouseMove
			this.selectCell(el.id);
		}
	}
	this.updateNumSelected();
}

// cell onmousemove
LayoutMapping.prototype.cellHandleMouseMove = function(ev,el) {
	if(this.cellMouseDown && el != this.curTarget) {
		this.curTarget = el;
		this.clearTextSelection();
		if( !ev.ctrlKey )
			this.clearSelection();
		this.selectRange(el, this.origCell);
		this.updateNumSelected();
	}
}

// cell onmouseup
LayoutMapping.prototype.cellHandleMouseUp = function () {
	this.cellMouseDown = false;
	this.origCell = null;
	this.curTarget = null;
	this.clearTextSelection();
	this.setStylesOfAllHeaders();
}

LayoutMapping.prototype.handleClickProfileHeader = function (ev, el) {
	this.clearTextSelection();
	this.curCell = null;
	this.curCol = null;

	if (ev.shiftKey && this.curRow) {
		this.clearSelection();
		this.selectRows(el.id, this.curRow.id);
	} else {
		if (ev.ctrlKey) {
			this.curRow = null;
			this.toggleRow(el.id);
		} else {
			this.clearSelection();
			this.curRow = el;
			this.selectRow(el.id);
		}
	}
	this.setStylesOfAllHeaders();
	this.updateNumSelected();
}

LayoutMapping.prototype.handleClickRTHeader = function (ev, el) {
	this.clearTextSelection();
	this.curCell = null;
	this.curRow = null;

	if (ev.shiftKey && this.curCol) {
		this.clearSelection();
		this.selectColumns(el.id, this.curCol.id);
	} else {
		if (ev.ctrlKey) {
			this.curCol = null;
			this.toggleColumn(el.id);
		} else {
			this.clearSelection();
			this.curCol = el;
			this.selectColumn(el.id);
		}
	}
	this.setStylesOfAllHeaders();
	this.updateNumSelected();
}

LayoutMapping.prototype.selectRange = function (elFrom, elTo) {
	if (!elFrom || !elTo) {
		return;
	}

	var fromRecordTypeId = LayoutMappingHelper.getCellRecordTypeId(elFrom);
	var fromProfileId = LayoutMappingHelper.getCellProfileId(elFrom);
	var toRecordTypeId = LayoutMappingHelper.getCellRecordTypeId(elTo);
	var toProfileId = LayoutMappingHelper.getCellProfileId(elTo);

	var rtIndex1 = LayoutMappingHelper.getIndex(this.recordTypes, fromRecordTypeId);
	var rtIndex2 = LayoutMappingHelper.getIndex(this.recordTypes, toRecordTypeId);
	var pIndex1 = LayoutMappingHelper.getIndex(this.profiles, fromProfileId);
	var pIndex2 = LayoutMappingHelper.getIndex(this.profiles, toProfileId);

	var beginRTIndex = Math.min(rtIndex1, rtIndex2);
	var endRTIndex = Math.max(rtIndex1, rtIndex2) + 1;
	var beginPIndex = Math.min(pIndex1, pIndex2);
	var endPIndex = Math.max(pIndex1, pIndex2) + 1;

	for (var i = beginRTIndex; i < endRTIndex; i++) {
		for (var j = beginPIndex; j < endPIndex; j++) {
			this.selectCell(LayoutMappingHelper.getCellId(this.profiles[j].id, this.recordTypes[i].id));
		}
	}
}

LayoutMapping.prototype.selectColumn = function (recordTypeId) {
	this.selectedCols.put(recordTypeId, recordTypeId);
	for (var i = 0; i < this.profiles.length; i++) {
		this.selectCell(LayoutMappingHelper.getCellId(this.profiles[i].id, recordTypeId));
	}
}

LayoutMapping.prototype.selectColumns = function (fromRecordTypeId, toRecordTypeId) {
	var rtIndex1 = LayoutMappingHelper.getIndex(this.recordTypes, fromRecordTypeId);
	var rtIndex2 = LayoutMappingHelper.getIndex(this.recordTypes, toRecordTypeId);
	var beginRTIndex = Math.min(rtIndex1, rtIndex2);
	var endRTIndex = Math.max(rtIndex1, rtIndex2) + 1;
	for (var i = beginRTIndex; i < endRTIndex; i++) {
		this.selectColumn(this.recordTypes[i].id);
	}
}

LayoutMapping.prototype.selectInitProfileRow = function () {
	if (!this.viewProfileId) {
		return;
	}

	this.selectedRows.put(this.viewProfileId, this.viewProfileId);
	for (var i = 0; i < this.recordTypes.length; i++) {
		this.populateDataForSelectedCell(this.viewProfileId, this.recordTypes[i].id);
	}

	if (this.isEdit) {
		this.updateNumSelected();
	}
}

LayoutMapping.prototype.selectRow = function (profileId) {
	this.selectedRows.put(profileId, profileId);
	for (var i = 0; i < this.recordTypes.length; i++) {
		this.selectCell(LayoutMappingHelper.getCellId(profileId, this.recordTypes[i].id));
	}
}

LayoutMapping.prototype.selectRows = function (fromProfileId, toProfileId) {
	var pIndex1 = LayoutMappingHelper.getIndex(this.profiles, fromProfileId);
	var pIndex2 = LayoutMappingHelper.getIndex(this.profiles, toProfileId);
	var beginPIndex = Math.min(pIndex1, pIndex2);
	var endPIndex = Math.max(pIndex1, pIndex2) + 1;
	for (var i = beginPIndex; i < endPIndex; i++) {
		this.selectRow(this.profiles[i].id);
	}
}

LayoutMapping.prototype.selectCell = function (id) {
	LayoutMappingHelper.selectCellById(id);
	var recordTypeId = id.substring(id.indexOf("_") + 1);
	var profileId = id.substring(0, id.indexOf("_"));

	this.populateDataForSelectedCell(profileId, recordTypeId);
}

LayoutMapping.prototype.populateDataForSelectedCell = function (profileId, recordTypeId) {
	var id = profileId + "_" + recordTypeId;
	var val = this.mapping[id];
	if (!val) {
		val = new Object();
		val.rtId = recordTypeId;
		val.pId = profileId;
	}
	this.selected.put(id, val);

	var recordTypeSelected = this.profileRecordTypeSelected.map[profileId];
	if (!recordTypeSelected) {
		recordTypeSelected = new Map();
		this.profileRecordTypeSelected.put(profileId, recordTypeSelected);
	}
	recordTypeSelected.put(recordTypeId, val);

	var profileSelected = this.recordTypeProfileSelected.map[recordTypeId];
	if (!profileSelected) {
		profileSelected = new Map();
		this.recordTypeProfileSelected.put(recordTypeId, profileSelected);
	}
	profileSelected.put(profileId, val);
}

LayoutMapping.prototype.deselectColumn = function(recordTypeId) {
	for (var i = 0; i < this.profiles.length; i++) {
		this.deselectCell(LayoutMappingHelper.getCellId(this.profiles[i].id, recordTypeId));
	}
	this.selectedCols.remove(recordTypeId);
}

LayoutMapping.prototype.deselectRow = function (profileId) {
	for (var i = 0; i < this.recordTypes.length; i++) {
		this.deselectCell(LayoutMappingHelper.getCellId(profileId, this.recordTypes[i].id));
	}
	this.selectedRows.remove(profileId);
}

LayoutMapping.prototype.deselectCell = function (id) {
	LayoutMappingHelper.deselectCellById(id);
	this.selected.remove(id);

	var profileId = id.substring(0, id.indexOf("_"));
	var recordTypeId = id.substring(id.indexOf("_") + 1);
	this.selectedRows.remove(profileId);
	this.selectedCols.remove(recordTypeId);

	var recordTypeSelected = this.profileRecordTypeSelected.map[profileId];
	if (recordTypeSelected) {
		recordTypeSelected.remove(recordTypeId);
		if (recordTypeSelected.size == 0) {
			this.profileRecordTypeSelected.remove(profileId);
		}
	}

	var profileSelected = this.recordTypeProfileSelected.map[recordTypeId];
	if (profileSelected) {
		profileSelected.remove(profileId);
		if (profileSelected.size == 0) {
			this.recordTypeProfileSelected.remove(recordTypeId);
		}
	}
}

LayoutMapping.prototype.toggleRow = function (id) {
	if (id in this.selectedRows.map) {
		this.deselectRow(id);
	} else {
		this.selectRow(id);
	}
}

LayoutMapping.prototype.toggleColumn = function (id) {
	if (id in this.selectedCols.map) {
		this.deselectColumn(id);
	} else {
		this.selectColumn(id);
	}
}

LayoutMapping.prototype.toggleCell = function (id) {
	if (id in this.selected.map) {
		this.deselectCell(id);
	} else {
		this.selectCell(id);
	}
}

LayoutMapping.prototype.resetSelectionStartPoints = function () {
	this.curRow = null;
	this.curCol = null;
	this.cellMouseDown = false;
	this.origCell = null;
	this.curTarget = null;
	this.curCell = null;
}

LayoutMapping.prototype.clearSelection = function () {
	for (var key in this.selected.map) {
		this.deselectCell(key);
	}
	this.selectedRows = new Map();
	this.selectedCols = new Map();
	this.selected = new Map();
	this.profileRecordTypeSelected = new Map();
	this.recordTypeProfileSelected = new Map();
}

LayoutMapping.prototype.clearTextSelection = function (){
    if (document.selection && document.selection.empty) {
        document.selection.empty();
    } else {
		if (window.getSelection().removeAllRanges)
	    	window.getSelection().removeAllRanges();
	}
}

LayoutMapping.prototype.updateNumSelected = function () {
	var numSelectedEl = document.getElementById("selectedCellsSpan");
	if (numSelectedEl) {
		numSelectedEl.innerHTML = this.selected.size + " " + LC.getLabel("LayoutMap", "Selected");
	}
}

LayoutMapping.prototype.updateNumChosen = function () {
	var numChangedEl = document.getElementById("changedCellsSpan");
	if (numChangedEl) {
		numChangedEl.innerHTML = this.changed.size + " " + LC.getLabel("LayoutMap", "Changed");
	}
}

//-----------------------//
// Change                //
//-----------------------//
LayoutMapping.prototype.onChangePLA = function (plaSelectorEl) {
	var newPageLayoutId = plaSelectorEl.options[plaSelectorEl.selectedIndex].value;
	if (newPageLayoutId == LayoutMapping.EMPTY_KEY || this.selected.size == 0) {
		return;
	}

	if (this.isChangedOverLimit()) {
		alert(LC.getLabel("LayoutMap", "PLAChangesAboveLimit", LayoutMapping.CELLS_LIMIT));
		return;
	}

	for (var profileRTId in this.selected.map) {
		var origPLA = this.mapping[profileRTId];
		var newPLA = new Object();
		if (!origPLA) {
			newPLA.pId = profileRTId.substring(0, profileRTId.indexOf("_"));
			newPLA.rtId = profileRTId.substring(profileRTId.indexOf("_") + 1);
			newPLA.plId = newPageLayoutId;
		} else {
			var newPLA = new Object();
			newPLA.id = origPLA.id;
			newPLA.pId = origPLA.pId;
			newPLA.rtId = origPLA.rtId;
			newPLA.plId = newPageLayoutId;
		}
		this.changed.put(profileRTId, newPLA);
		LayoutMappingHelper.changeCellById(profileRTId);
		var cellEl = getElementByIdCS(profileRTId);
		if (cellEl) {
			cellEl.innerHTML = this.pageLayoutsMap[newPageLayoutId].name;
		}
	}

	this.updateNumChosen();
	this.setHeadersWidth();
}

LayoutMapping.prototype.resetPageLayoutSelector = function () {
	var pageLayoutSelectorEl = document.getElementById('pageLayoutSelector');
	if (pageLayoutSelectorEl) {
		pageLayoutSelectorEl.selectedIndex = 0;
	}
}

LayoutMapping.prototype.isChangedOverLimit = function () {
	if (this.selected.size == 0 || (this.selected.size + this.changed.size) <= LayoutMapping.CELLS_LIMIT) {
		return false;
	}

	var totalToBeChanged = this.changed.size;
	for (var profileRTId in this.selected.map) {
		if (!(profileRTId in this.changed.map)) {
			totalToBeChanged++;
		}
	}
	if (totalToBeChanged > LayoutMapping.CELLS_LIMIT) {
		return true;
	}
	return false;
}

//-----------------------//
// Header Style          //
//-----------------------//
LayoutMapping.prototype.setStylesOfAllHeaders = function () {
	for (var i = 0; i < this.profiles.length; i++) {
		var recordTypeSelected = this.profileRecordTypeSelected.map[this.profiles[i].id];
		var profileHeaderEl = getElementByIdCS(this.profiles[i].id);
		this.setHeaderStyle(LayoutMapping.PROFILE_HEADER_BASE_CLASS_NAME, profileHeaderEl, recordTypeSelected,
			 this.selectedRows);
	}

	var rtHeaderBaseClassName = (this.recordTypes.length > 1) ? LayoutMapping.RT_HEADER_BASE_CLASS_NAME :
		LayoutMapping.MASTER_RT_HEADER_BASE_CLASS_NAME;

	for (var j = this.beginIndex; j < this.endIndex; j++) {
		var profileSelected = this.recordTypeProfileSelected.map[this.recordTypes[j].id];
		var recordTypeHeaderEl = getElementByIdCS(this.recordTypes[j].id);
		this.setHeaderStyle(rtHeaderBaseClassName, recordTypeHeaderEl, profileSelected, this.selectedCols);
	}
}

LayoutMapping.prototype.setHeaderStyle = function (baseClassName, el, selectedMap, selectedHeaders) {
	if (!el) {
		return;
	}
	if (!selectedMap || selectedMap.size == 0) {
		if (el.className.indexOf('selectedHeader') > 0 || el.className.indexOf('highlightedHeader') > 0) {
			el.className = baseClassName;
		}
		// el.className = baseClassName;
	} else {
		if (el.id in selectedHeaders.map) {
			if (el.className.indexOf('selectedHeader') < 0) {
				el.className =	baseClassName + ' selectedHeader';
				// el.style.backgroundColor = '#8E9DBE';
				// el.style.color = '#FFFFFF';
			}
		} else {
			if (el.className.indexOf('highlightedHeader') < 0) {
				el.className =	baseClassName + ' highlightedHeader';
				// el.style.backgroundColor = '#D0D0FF';
			}
		}
	}
}

LayoutMapping.prototype.getProfileHeaderClassName = function (headerProfileId, profileId) {
	var isSelectedRow = (this.viewProfileId == headerProfileId);
	if (this.isEdit && !isSelectedRow) {
		isSelectedRow = (headerProfileId in this.selectedRows.map);
	}
	if (isSelectedRow) {
		return " selectedHeader ";
	}
	var recordTypeSelected = this.profileRecordTypeSelected.map[headerProfileId];
	if (recordTypeSelected && recordTypeSelected.size > 0) {
		return " highlightedHeader ";
	}
	return " ";
}

LayoutMapping.prototype.getRecordTypeHeaderClassName = function (recordTypeId) {
	if (this.isEdit && (recordTypeId in this.selectedCols.map)) {
		return " selectedHeader ";
	}
	var profileSelected = this.recordTypeProfileSelected.map[recordTypeId];
	if (profileSelected && profileSelected.size > 0) {
		return " highlightedHeader ";
	}
	return " ";
}

//---------------------------------//
// Save                            //
//---------------------------------//
LayoutMapping.prototype.save = function() {
	var changedPLAsEl = document.getElementById('changedPLAs');
	if (!changedPLAsEl) {
		return;
	}
	changedPLAsEl.value = this.toXML();
}

LayoutMapping.prototype.toXML = function () {
	var xml = [];
	xml.push('<changedPLAs>');
	for (var profileRTId in this.changed.map) {
		var val = this.changed.map[profileRTId];
		xml.push('<item ');
		xml.push('id="' + (val.id ? val.id : LayoutMapping.EMPTY_KEY) + '" ');
		xml.push('pId="' + val.pId + '" ');
		xml.push('rtId="' + val.rtId + '" ');
		xml.push('plId="' + val.plId + '" ');
		xml.push('/>');
	}
	xml.push('</changedPLAs>');
	return xml.join('');
}

LayoutMapping.prototype.cancel = function () {
	var qs = new QueryString("");
	qs.add("type", this.pageLayoutType);
	qs.add("pageNum", this.pageNum);
	if (this.viewProfileId) {
		qs.add("pid", this.viewProfileId);
	}
	var url = location.href.substring(0, location.href.indexOf('?'));
	location.href = url + qs.toString();
}

LayoutMapping.prototype.getUrl = function (url, qs) {
	if (!url || !qs) {
		return "";
	}

	// query string is empty
	var qsStr = qs.toString();
	if (qsStr.length == 0) {
		return url;
	}

	// question mark in url
	if (url.indexOf('?') >= 0) {
		if (url.indexOf('?') == (url.length - 1)) {
			// no params after question mark
			return url + qs.toString().substring(1);
		} else {
			// params after question mark
			return url + '&' + qs.toString().substring(1);
		}
	}

	// no question mark in url
	return url + qs.toString();
}



/**
 * multiforce!
 */
function AppPicker(appExchangeUrl, appStoreUrl, developerUrl, pick, urlMap, btn) {
    this.appExchangeUrl = appExchangeUrl;
    this.appStoreUrl = appStoreUrl;
    this.developerUrl = developerUrl;
    this.picker = pick;
    this.originalIndex = pick.selectedIndex;
    this.urlMap = urlMap;

    var self = this;
    if (btn) {
        addEvent(btn, 'click', function() { self.handleChange(); }, false);
        addEvent(pick, 'change', function() { self.changeAlt(); }, false);
    } else {
        addEvent(pick, 'change', function() { self.handleChange(); }, false);
    }
    this.changeAlt();
}

AppPicker.prototype.changeAlt = function() {
    this.picker.title = this.picker[this.picker.selectedIndex].text;
}

AppPicker.prototype.handleChange = function() {
    if (this.picker.options[this.picker.selectedIndex].value == "AppExchange") {
        var newWindow = window.open(this.appExchangeUrl, "AppExchangePopup");
        this.picker.selectedIndex = this.originalIndex;
        newWindow.focus();
    } else if(this.picker.options[this.picker.selectedIndex].value == "AppStore") {
        var newWindow = window.open(this.appStoreUrl, "AppStorePopup");
        this.picker.selectedIndex = this.originalIndex;
        newWindow.focus();
    } else if(this.picker.options[this.picker.selectedIndex].value == "DeveloperForce") {
        var newWindow = window.open(this.developerUrl, "DeveloperForcePopup");
        this.picker.selectedIndex = this.originalIndex;
        newWindow.focus();
    } else if(this.picker.options[this.picker.selectedIndex].value == "EMPTY") {
        this.picker.selectedIndex = this.originalIndex;
    } else {
    	var url = this.urlMap[this.picker.options[this.picker.selectedIndex].value];
    	if(url.length >= 4 && url.substring(0, 4) == '/sfc') {
    		this.handleSFCTabSwitch(url);
    		return;
    	}
		else if (url.indexOf("?") >= 0 ){  // If there are parameters in the URL
			url = this.parseUrlParamsIntoHiddens(url);
    	}
    	this.picker.form.action = this.urlMap[this.picker.options[this.picker.selectedIndex].value];
        this.picker.form.submit();
    }
}

AppPicker.prototype.parseUrlParamsIntoHiddens = function( url ){
	var urlWithoutParams = url.split('?')[0]
    var paramString = url.split('?')[1];
	var params = paramString.split('&');
	for (var i=0;i<params.length;i++){
		var newHidden = document.createElement("INPUT");
		newHidden.type = "hidden";
		newHidden.name = params[i].split('=')[0];
		newHidden.id = params[i].split('=')[0];
		newHidden.value = params[i].split('=')[1];
		this.picker.form.appendChild(newHidden);
	}
	return urlWithoutParams;
}

AppPicker.prototype.handleSFCTabSwitch = function(url) {
	var tsidParam = this.picker.name + '=' + this.picker.options[this.picker.selectedIndex].value;
	if(url.indexOf('?') > -1) {
		url += '&';
	}
	else {
		url += '?';
	}
	url += tsidParam;
	document.location.href = url;
}

/**
  CustomMotifDefinition is instantiated on (you guessed it) CustomMotifDefinitionPage.java

  @author polcari
  @since 144


  @parentMotifId  This id for the parent's motifElement.  It is passed as a QS var to CustomMotifDefinitionPage

*/

function CustomMotifDefinition(parentMotifId) {

  this.parentMotifInputObject = window.opener.document.getElementById(parentMotifId).motifInputElement;
  this.motifObject = document.getElementById(CustomMotifDefinitionPageConst.COLOR_ELEMENT).motifInputElement;
  this.iconObject = document.getElementById(CustomMotifDefinitionPageConst.MOTIF_ICON_PARAM).imageSelectElement;
}


//this has dependancies on a number of global JS vars
//see CustomMotifDefinitionPage.getVariablesForJS()
CustomMotifDefinition.prototype.returnSelections = function() {
  if (this.motifObject.isNull()) {
    alert(noMotifErrorMsg);  //It would be nice to load these from LC
    return false;
  } else if (this.iconObject.isNull()) {
    alert(noIconErrorMsg);
    return false;
  } else {
   //copy Motif key
    this.parentMotifInputObject.motifElement.className = this.motifObject.motifElement.className.replace("motifColorElement","customDefinedMotif");
    this.parentMotifInputObject.setMotifKey(this.motifObject.motifKeyInput.value);
   //copy text
    this.parentMotifInputObject.setDescription(userDefinedDescription);
   //copy image
    this.parentMotifInputObject.setIconSrc(this.iconObject.image.src);
    this.parentMotifInputObject.setIconValue(this.iconObject.inputElement.value);

    window.blur();
    window.close();
    return true;
  }
}


//helper function
CustomMotifDefinition.prototype.copyInputVal = function(fromID, toID) {
  window.opener.document.getElementById(toID).value = document.getElementById(fromID).value;
}
//helper function
CustomMotifDefinition.prototype.copyInput = function(fromInput, toInput) {
  toInput.value = fromInput.value;
}



/*
 * @author pburstein
 * @since 150
 * Lookup input element
 *
 */

function LookupElement() {
    var self=this;
    this.lookupPick = function (formName, parentIdElementName, parentEditElementName, relatedFieldName, id, display, relatedFieldValue, extraNameElementName) {
        setTimeout(function() { self.closeLookup(); }, 1);
        lookupPick(formName, parentIdElementName, parentEditElementName, relatedFieldName, id, display, relatedFieldValue, extraNameElementName);
    }
    
    this.lookupPick2 = function(formName, parentIdElementName, parentEditElementName, id, display, extraNameElementName, extraName, extraIdElementName, extraId, allowOverwrite) {
        setTimeout(function() { self.closeLookup(); }, 1);
        lookupPick2(formName, parentIdElementName, parentEditElementName, id, display, extraNameElementName, extraName, extraIdElementName, extraId, allowOverwrite)
    }
    this.lookupPhonePick = function(parentId, newValue) {
        setTimeout(function() { self.closeLookup(); }, 1);
        lookupPhonePick(parentId, newValue)
    }
}

LookupElement.prototype.openLookup = function(baseURL, width, modified, searchParam) {
    if (modified == '1') baseURL = baseURL + searchParam;
    this.initOverlay(baseURL).show();
}

LookupElement.prototype.closeLookup = function() {
    this.getOverlay().hide();
    this.redirectIframe(IFrameElement.BLANK_SRC);
}

LookupElement.prototype.getOverlay = function() {
    return sfdcPage.getDialogById(LookupInputElement.DIALOG_ID);
}

LookupElement.prototype.redirectIframe = function(url) {
    this.getOverlay().getContentElement().firstChild.src = url;
}

LookupElement.prototype.initOverlay = function (baseURL) {
    var ret = this.getOverlay();
    if (ret) {
        this.redirectIframe(baseURL);
    } else {
        var iframeHtml=[]
        iframeHtml.push('<iframe ');
        iframeHtml.push('src="');
        iframeHtml.push(baseURL);
        iframeHtml.push('" class="pageMaskIFrame" scrolling="no" ');
        iframeHtml.push('id="');
        iframeHtml.push(LookupInputElement.LOOKUP_IFRAME);
        iframeHtml.push('" name="');
        iframeHtml.push(LookupInputElement.LOOKUP_IFRAME);
        iframeHtml.push('"></iframe>');
        iframeHtml = iframeHtml.join('');
    
        ret = new FunctionalDialog(LookupInputElement.DIALOG_ID, true, LC.getLabel('Lookup', 'Title'));
        ret.setWidth(900);
        ret.setMaxHeight(700);
        ret.hideSummaryElement();
        ret.clearButtons();
        sfdcPage.registerDialog(ret);
        ret.setContentInnerHTML(iframeHtml);
    }
    return ret;
}


/*
 * @author ldelascurain
 * @since 150
 *
 */

function FieldTreeNode( key, isLeaf, children, labelName, showLabel, attributes) {
    this.key = key;
    this.isLeaf = isLeaf;
    this.labelName = labelName;
    this.showLabel = showLabel;
    this.attributes = attributes;
    if (children)
	    this.setChildren(children);
}

FieldTreeNode.prototype.setChildren = function(children){
	this.isLeaf = false;
	this.children = children;
	for (var i=0;i<children.length;i++){
    	children[i].parent = this;
    }
}

FieldTreeNode.prototype.getLabelToInsert = function(ignoreShowLabel){
	
    if (!(this.parent && (this.parent.showLabel || ignoreShowLabel)))
        return this.key;
    return this.parent.getLabelToInsert(ignoreShowLabel) + "." + this.key;
}

FieldTreeNode.prototype.getExtraAttributes = function(){

	var attributeArr = ["<table class='fieldPickerAttributeTable'>"];
	for (var key in this.attributes){
		attributeArr.push("<tr><td class='fieldPickerAttributeCategory'>");
		attributeArr.push(key);
		attributeArr.push("&nbsp;")
		attributeArr.push(this.attributes[key]);
		attributeArr.push("</td></tr>");
	}
    attributeArr.push("</table>");

    return attributeArr.join("");
}
/**
 * @author zzhou
 * since 148
 * CrtLayout javascript code; also see AvailableSection.js, AvailableField.js, Lookups.js
 */

     CrtLayoutElement.layoutSections = {};
     CrtLayoutElement.layoutSecPos = [];
     MoveableItem.selectedBucket = [];
     LayoutSection.currentSelectedObj = null;
     MoveableItem.currentSelectedObj = null;
     CrtLayoutElement.mouseDown = false;
     CrtLayoutElement.dragMove = false;
     CrtLayoutElement.CSS_CLASS_SELECTED_SECTION = 'sectionSelected';
     CrtLayoutElement.CSS_CLASS_LAYOUT_SECTION = 'layoutSecHeaderLeft';
     CrtLayoutElement.CSS_CLASS_SELECTED_ITEM = 'itemSelected';
     CrtLayoutElement.CSS_CLASS_LAYOUT_ITEM_SEPARATOR_HIGHLIGHT = 'sepCellHighlight';
     CrtLayoutElement.CSS_CLASS_LAYOUT_SECTION_SEPARATOR_HIGHLIGHT = 'sepSectionHighlight';
     CrtLayoutElement.CSS_CLASS_LAYOUT_SECTION_SEPARATOR = 'sepSection';
     LayoutItemSeparator.highlightSep = null;
     LayoutSection.NEW_SECTION_ID_PREFIX = "newSectionId";
     LayoutSection.NEW_SECTION_SEP_ID_PREFIX = "newSectionSepId";
     LayoutSection.sectionIdInterator = 0;
     CrtLayoutElement.FIELD_SEP = '$';
     CrtLayoutElement.COL_SEP = '|';
     CrtLayoutElement.DIV_SEP = '_';
     CrtLayoutElement.sectionNameIdMap = {};
     CrtLayoutElement.initialStateColIdMap = null;
     CrtLayoutElement.lookupItemPosMap = {};
     CrtLayoutElement.currentDisplayedSec = null;
     CrtLayoutElement.NUM_ROWS_PER_AVAILABLE_SECTION = 8;
     CrtLayoutElement.disableButtons = false;
     CrtLayoutElement.HOVER_TIME_OUT = 1000;
     CrtLayoutElement.availableSectionPosInited = false;
     CrtLayoutElement.availableSectionInitPosY = 0;
     CrtLayoutElement.sectionsToReformat = {};

     LayoutItem.prototype.createNewCellId = function() {
        return this.sectionId + 'r'+this.rowPos+'c'+(this.colPos+1);
     }

     LayoutItemSeparator.prototype.createNewCellId = function() {
        return 'rp_'+this.sectionId + 'r'+this.rowPos+'c'+(this.colPos+1);
     }

     CrtLayoutElement.init = function() {
         document.onmousemove = function(evt) {CrtLayoutElement.handleMouseMove(evt)};
         document.onmouseup = function(evt) {CrtLayoutElement.handleMouseUp(evt)};
         window.onscroll = function(evt) {CrtLayoutElement.scrollAvailableSection(evt)};
         sfdcPage.appendToOnloadQueue(CrtLayoutElement.onLoad,"onLoad Scripts for the CrtLayout Page");
     }

     CrtLayoutElement.onLoad = function() {
        setTimeout('CrtLayoutElement.initLoad()',10);
     }

     CrtLayoutElement.handleMouseOver = function() {

     }

    CrtLayoutElement.openPropertiesEdit = function(evt) {
        if (!MoveableItem.currentSelectedObj) {
            alert(LC.getLabel("CrtLayout","mustSelectField"));
            return;
        }
        if (MoveableItem.currentSelectedObj.isSection) {
            CrtLayoutElement.openSectionPopup(evt,MoveableItem.currentSelectedObj.fieldObj.sectionId);
            return;
        }

        evt = getEvent(evt);
        setLastMousePosition(evt);


        var url = MoveableItem.currentSelectedObj.inLayout ? CrtLayoutElement.CRT_FIELD_EDIT_URL : "";
        var h = (MoveableItem.selectedBucket.length > 2) ? 400 : 200;
        openPopup(url, 'sectionEdit', 450, h, 'width=450,height='+h+',scrollbars=yes,toolbar=no,status=no,directories=no,menubar=no,resizable=yes', true);
        return false;

    }

     CrtLayoutElement.swapAvailableType = function(sel,fromPageNum,toPageNum) {
        if (CrtLayoutElement.currentDisplayedSec) {
            CrtLayoutElement.currentDisplayedSec.swapFromPage(fromPageNum);
        }
        var secId = sel.options[sel.selectedIndex].value;
        CrtLayoutElement.availableSections[secId].swapToPage(toPageNum);
     }

    CrtLayoutElement.getPrimObjMetaMap = function() {
        return CrtLookups.primaryObjects;
    }

    CrtLayoutElement.getLookupIdFromPrimObjId = function(primaryObjId) {
        return primaryObjId+'_'+LookupsUi.LOOKUPS;
    }

    CrtLayoutElement.setLookupItemPostion = function(fieldValue, fieldObj) {
        if (CrtLayoutElement.lookupItemPosMap == null) {
            CrtLayoutElement.lookupItemPosMap = {};
        }
        CrtLayoutElement.lookupItemPosMap[fieldValue] = fieldObj;
    }

    CrtLayoutElement.clearTextSelection = function(){
        if (isIE) {
            document.selection.empty();
        } else {
          if (window.getSelection().removeAllRanges) {
              window.getSelection().removeAllRanges();
          }
        }
    }

    CrtLayoutElement.deleteSection = function(sectionId) {
        var section = CrtLayoutElement.layoutSections[sectionId];
        if (!section.isEmpty && !window.confirm(LC.getLabel("LayoutDND", "confirmDeleteSectionPrompt") + '\n\n' + LC.getLabel("Global", "are_you_sure"))) {
            return;
        }

        section.remove();

        CrtLayoutElement.layoutSections[sectionId].numFields = 0;
        CrtLayoutElement.checkDisableSave();
        //delete
        delete CrtLayoutElement.layoutSections[sectionId];
        //this name no longer exists for lookup fields
        delete CrtLayoutElement.sectionNameIdMap[section.labelName];

    }

    CrtLayoutElement.createNewSection = function(sectionName, evt) {
        if (sectionName) {
            var sec = initSectionTable(null,null, null, 'H', sectionName);
            sec.reformatSection();
            sec.attachItemEvents();
            return sec;
        }
    }

    CrtLayoutElement.openSectionPopup = function(evt,sectionId) {
        var url = CrtLayoutElement.CRT_SECTION_EDIT_URL;
        if (sectionId) {
          url += '?sectionId=' + sectionId;
        }
        evt = getEvent(evt);
        setLastMousePosition(evt);
        openPopup(url, 'sectionEdit', 450, 245, 'width=450,height=245,scrollbars=yes,toolbar=no,status=no,directories=no,menubar=no,resizable=yes', true);
    }

    CrtLayoutElement.handleMouseUp = function(evt) {
        if (CrtLayoutElement.dragMove) {
            document.getElementById('dragDummy').style.visibility = 'hidden';
             //Shouldn't be handling mouseup here but on the element itself but that seems broken (broken on FIREFOX) - for now...so handle it here
            CrtLayoutElement.handleSelectedItems();
            MoveableItem.clearSelectedItems();
            CrtLayoutElement.clearHighlights();
            CrtLayoutElement.dragMove = false;
        }
        CrtLayoutElement.mouseDown = false;
     }

     CrtLayoutElement.clearHighlights = function() {
        if (CrtLayoutElement.highlightAvailSection) {
            CrtLayoutElement.highlightAvailSection.handleMouseUp(null);

        }
        if (CrtLayoutElement.highlightSec) {
            CrtLayoutElement.highlightSec.setHighlighted(false);
        }
        if (LayoutItemSeparator.highlightSep) {
            LayoutItemSeparator.highlightSep.setHighlighted(false);
        }
     }

     CrtLayoutElement.handleMouseMove = function(evt) {
        var evt = getEvent(evt);
        if (MoveableItem.currentSelectedObj && CrtLayoutElement.mouseDown) {
            CrtLayoutElement.dragMove = true;
            CrtLayoutElement.clearTextSelection();
            var scrollX = getScrollX();
            var scrollY = getScrollY();
            var dragDummy = document.getElementById('dragDummy');
            var dragDummyValue = document.getElementById('dragDummyValue');
            dragDummy.style.visibility = 'visible';
            if (MoveableItem.currentSelectedObj.isSection) {
                dragDummyValue.innerHTML =  MoveableItem.selectedBucket.length > 1 ? LC.getLabel("CrtLayout","dragMultiSelect") : MoveableItem.currentSelectedObj.fieldName;
            } else {
                dragDummyValue.innerHTML = MoveableItem.selectedBucket.length > 1 ? LC.getLabel("CrtLayout","dragMultiSelect") : MoveableItem.currentSelectedObj.fieldName;
            }

            var parentX = 0;
            var parentY = 0;
            if (dragDummy.offsetParent) {
               var dummyParent = dragDummy.offsetParent;
               parentX = getObjX(dummyParent);
               parentY = getObjY(dummyParent);
            }
            dragDummy.style.left = (getMouseX(evt) - parentX) + "px";
            dragDummy.style.top = (getMouseY(evt) - parentY) + "px";
            var currentX = getObjX(dragDummy) - scrollX;
            var theWidth = 500;
            if (document.documentElement && document.documentElement.clientWidth)
                theWidth = document.documentElement.clientWidth;
            else if (document.body) {
                theWidth = document.body.clientWidth;
                if (currentX > theWidth) {
                    if (isIE) document.body.scrollLeft = document.body.scrollLeft + 10;
                    //else window.scroll(10, 0);
                } else if (currentX < 0) {
                    if (isIE) document.body.scrollLeft = document.body.scrollLeft - 10;
                    //else window.scroll(-10, 0);
                }
            }
            else {

            }
            var currentY = getObjY(dragDummy) - scrollY;
            var theHeight = 500;
            if (document.documentElement && document.documentElement.clientHeight)
                theHeight = document.documentElement.clientHeight;
            else if (document.body) {}
                theHeight = document.body.clientHeight;
                if (currentY > theHeight - 50) {
                    //if (isIE) document.documentElement.scrollTop = document.body.scrollTop + 50;
                    window.scrollBy(0, 50);
                } else if (currentY < 50) {
                    // if (isIE) document.documentElement.scrollTop = document.body.scrollTop - 50;
                    window.scrollBy(0, -50);
                }
            }
            else {
            }
     }

     function initSectionTable(sectionId,sectionHeaderId, sectionTableId, sortOrder, masterLabel) {
         var section = new LayoutSection(sectionId,sectionHeaderId, sectionTableId, sortOrder,masterLabel);
         CrtLayoutElement.layoutSections[section.sectionId] = section;
         //position map to keep track of the positions of the layout sections
         CrtLayoutElement.layoutSecPos.push(section.sectionId);

        //some section name handling
        //for now handle section names so that we place the lookups in the appropriate buckets
        CrtLayoutElement.sectionNameIdMap[masterLabel] = section;
        return section;
     }

     //init the innerHTML on constructing a new table;
     LayoutSection.prototype.initSectionInnerHtml = function() {
        var secDiv = document.createElement("DIV");
        var innerHTML = '';
        secDiv.id = this.sectionId;
        secDiv.className = "layoutSection";
        innerHTML += '<div class="layoutSecHeader"><table  border="0" cellpadding="0" cellspacing="0"><tr><td class="layoutSecHeaderLeft" ';
        innerHTML += 'id="' + this.sectionHeaderId  +'">' + this.labelName + '</td><td class="layoutSecHeaderLink">';
        innerHTML += '<span class="sectionHeadLink" onclick="CrtLayoutElement.openSectionPopup(event,\'' + this.sectionId + '\');">'+LC.getLabel("CrtLayout","sectionEdit")+'</span>';
        innerHTML += '&nbsp;|&nbsp;<span class="sectionHeadLink" onclick="CrtLayoutElement.deleteSection(\'' + this.sectionId + '\');">'+LC.getLabel("CrtLayout","sectionDelete")+'</span></td></table></div>';
        innerHTML += '<div><table id="' + this.sectionTableId + '"class="layoutSectionTable">';
        innerHTML += '</table></div>';
        secDiv.innerHTML = innerHTML;
        return secDiv;
     }

     //init the innerHTML for a new table separator
     LayoutSection.prototype.initSectionSepInnerHtml = function() {
        var sepDiv = document.createElement("DIV");
        sepDiv.id = this.getSectionSepId();
        sepDiv.className = "sepSection";
        return sepDiv;
     }

     LayoutSection.prototype.createSectionId = function() {
        return LayoutSection.NEW_SECTION_ID_PREFIX + '_' + LayoutSection.sectionIdInterator++;
     }

     LayoutSection.prototype.getSectionTableId = function() {
        return this.sectionId + "_layoutItemSection";
     }

     LayoutSection.prototype.getSectionHeaderId = function() {
         return "sec_" + this.sectionId;
     }

     LayoutSection.prototype.getLastSectionSepId = function() {
        return CrtLayoutElement.SECTION_SEP_DIV_PREFIX +CrtLayoutElement.LAST_SEC_SEP_DIV;
     }


     function LayoutSection(sectionId,sectionHeaderId, sectionTableId, sortOrder, masterLabel) {
         this.labelName = masterLabel;
         if (sectionId == null) {
             this.sectionId = this.createSectionId();
             this.sectionHeaderId = this.getSectionHeaderId();
             this.sectionTableId = this.getSectionTableId();
             var parentNode = document.getElementById("mainTableDiv");
             var lastSecSep = document.getElementById(this.getLastSectionSepId());
             var sepDiv = this.initSectionSepInnerHtml();
             parentNode.insertBefore(sepDiv,lastSecSep);
             parentNode.insertBefore(this.initSectionInnerHtml(),lastSecSep);
             new LayoutSectionSeparator(sepDiv.id, this.sectionId);
             this.sectionValue = "";
             this.attachEvents();
         } else {
             this.sectionId = sectionId;
             this.sectionHeaderId = sectionHeaderId;
             this.sectionTableId = sectionTableId;
             this.sectionValue = sectionId;
         }

         this.sortOrder = sortOrder;
         this.isSelected = false;
         this.numCols = CrtLayoutElement.NUM_LAYOUT_COLS;
         this.numRows = 0;
         this.layoutItems = [];
         //only here to keep the separator objects alive
         this.layoutSeparators = [];
         this.fieldsMap = {};
         this.isEmpty = true;
     }

    //move cell -- or more precisely move contents of fromField to the contents of toField
    LayoutSection.prototype.moveCell = function(toField,fromField) {
            toField.sectionId = this.sectionId;
            toField.customName = fromField.customName;
            toField.displayName = fromField.displayName;
            toField.fieldName = fromField.fieldName;
            toField.fieldId = fromField.fieldId;
            toField.isEmpty = fromField.isEmpty;
            toField.type = fromField.type;
            toField.isLookup = fromField.isLookup;
            toField.defaultChecked = fromField.defaultChecked;
            fromField.isEmpty = true;
    }

    LayoutSection.prototype.insertCell = function(toField,moveableItem) {
        toField.fieldName = moveableItem.fieldName;
        toField.displayName = moveableItem.displayName;
        toField.customName = moveableItem.customName;
        toField.type = moveableItem.type;
        toField.fieldId = moveableItem.itemId;
        toField.isLookup = moveableItem.isLookup;
        toField.defaultChecked = moveableItem.defaultChecked;
        toField.isEmpty = false;
    }

    LayoutItem.prototype.setCellToEmpty = function() {
        this.itemElem.innerHTML = '';
    }


     //insert a table row in the html for this layout section
     //update internal object references
     LayoutSection.prototype.insertSectionRow = function() {
        var tableElem = document.getElementById(this.sectionTableId);
        var row = tableElem.insertRow(-1);
        var numRows = this.numRows;
        for (var i=0; i<this.numCols; i++) {
            setSeparatorAttributes(this.sectionId,null,numRows,i,row);
            setEmptyFieldAttributes(this.sectionId,null,numRows,i,row);
        }
     }

    //delete an extra empty row in a section
    LayoutSection.prototype.deleteSectionRow = function() {
        var tableElem = document.getElementById(this.sectionTableId);
        tableElem.deleteRow(-1);
        this.layoutItems.splice(this.numRows-1,1);
        this.layoutSeparators.splice(this.numRows-1,1);
        this.numRows--;
    }

    //reformat section after putting in cells from selected bucket
    //alignment is from left to right; cells automatically align as far left on their row as possible
    //@ param isLoad specifies whether we are calling this on loading the page or not -- if we are loading, we don't do most of the formatting for speed
    LayoutSection.prototype.reformatSection = function(isLoad) {
        var columnSize = this.numCols;
        var pos =0;
        var lastEmpty= -1; //assume non cells Empty at start
        var row, col;
        for (var lastEmpty = -1, pos = 0; Math.floor(pos / columnSize) < this.numRows; pos++) {
            row = Math.floor(pos / columnSize);
            col = (pos % columnSize);
            //if we see a nonEmptyCell, copy it over
            if (!this.layoutItems[row][col].isEmpty) {
                 if (lastEmpty == -1) {
                     continue;
                 }
                 this.moveCell(this.layoutItems[Math.floor(lastEmpty/columnSize)][lastEmpty%columnSize],
                             this.layoutItems[row][col]);

                 //move lastEmptyPosition
                 lastEmpty++;
            }
            else {
                if (lastEmpty == -1) {
                    lastEmpty = pos;
                }
            }
        }

        var lastNonEmpty = lastEmpty-1;
        this.isEmpty = true;

        if (lastEmpty >= 0 && (pos-columnSize) > lastNonEmpty) {
            var emptyRows = Math.floor((pos-1-lastNonEmpty)/columnSize);
            //if we have more than one empty row, delete the extras
            while (emptyRows > 1) {
               this.deleteSectionRow();
               emptyRows--;
            }
        }
        else {
            //else we have no empty rows, so add one here
            this.insertSectionRow();
        }
        this.numFields = 0;

        //set cell style
        for (var j = 0; j < this.numRows; j++) {
            for (var k = 0; k < this.numCols; k++) {
                var field = this.layoutItems[j][k];
                this.fieldsMap[field.itemId] = field;
                var sep = this.layoutSeparators[j][k];
                if (!isLoad) {
                    sep.setHighlighted(false);
                }
                if (!isLoad || field.isEmpty) {
                    field.formatField();
                }
                if (!field.isEmpty) {
                    this.isEmpty = false;
                    this.numFields++;
                    //set lookup positioning
                    if (field.isLookup) {
                        CrtLayoutElement.setLookupItemPostion(field.fieldId,field);
                    }
                }

            }
        }

        //attach the the event handlers that would handle the events on the LayoutItems
        if (isLoad) {
            this.attachItemEvents();
        }
    }

    //theorically it will make more sense to attach event handlers to the individual field element themselves
    //however setting all the event handlers on each of the fields would take too long on a page with many fields
    //thus we attach events to the parent element and then delegate to the appropriate event handler during events
    LayoutSection.prototype.attachItemEvents = function() {
         var self = this;
         var tableElem = document.getElementById(self.sectionTableId);
         addEvent(tableElem, 'click', function(evt) {self.handleItemMouseClick(evt);}, false);
         addEvent(tableElem, 'mousedown', function(evt) {self.handleItemMouseDown(evt);}, false);
         addEvent(tableElem, 'mouseover', function(evt) {self.handleItemMouseOver(evt);}, false);
         addEvent(tableElem, 'dblclick', function(evt) {self.handleItemMouseDblClick(evt);}, false);
         addEvent(tableElem, 'mouseout', function(evt) {self.handleItemMouseOut(evt);}, false);
    }

    LayoutSection.prototype.handleItemMouseClick = function(evt) {
        var elem = getEventTarget(evt);
        var field = this.fieldsMap[elem.id];
        if (field) {
            if (!field.elem) {
                field.itemElem = elem;
            }
            field.handleMouseClick(evt);
        }
    }

    LayoutSection.prototype.handleItemMouseDown = function(evt) {
        var elem = getEventTarget(evt);
        var field = this.fieldsMap[elem.id];
        if (field) {
            if (!field.elem) {
                field.itemElem = elem;
            }
            field.handleMouseDown(evt);
        }
    }

    LayoutSection.prototype.handleItemMouseOver = function(evt) {
        var elem = getEventTarget(evt);
        var field = this.fieldsMap[elem.id];
        if (field) {
            if (!field.elem) {
                field.itemElem = elem;
            }
            field.handleMouseOver(evt);
        }
    }

    LayoutSection.prototype.handleItemMouseDblClick = function(evt) {
        var elem = getEventTarget(evt);
        var field = this.fieldsMap[elem.id];
        if (field) {
            if (!field.elem) {
                field.itemElem = elem;
            }
            field.handleMouseDblClick(evt);
        }
    }

    LayoutSection.prototype.handleItemMouseOut = function(evt) {
        var elem = getEventTarget(evt);
        var field = this.fieldsMap[elem.id];
        if (field) {
            if (!field.elem) {
                field.itemElem = elem;
            }
            field.handleMouseOut(evt);
        }
    }

    CrtLayoutElement.disableLayoutButtons = function(disableButton) {
        if (disableButton) {
            //if there are empty sections, disable both save and preview layout buttons
            for (var i=0; i<2; i++) {
                if (document.getElementsByName("saveAndCloseButton")[i]) {
                    document.getElementsByName("saveAndCloseButton")[i].className = 'btnDisabled';
                    document.getElementsByName("saveAndCloseButton")[i].disabled = true;
                    document.getElementsByName("previewButton")[i].className = 'btnDisabled';
                    document.getElementsByName("previewButton")[i].disabled = true;
                    CrtLayoutElement.disableButtons = true;
                }
            }
        }
        else {
        //else, enable buttons
           for (var i=0; i<2; i++) {
              if (document.getElementsByName("saveAndCloseButton")[i]) {
                  document.getElementsByName("saveAndCloseButton")[i].className = 'btn';
                  document.getElementsByName("saveAndCloseButton")[i].disabled = false;
                  document.getElementsByName("previewButton")[i].className = 'btn';
                  document.getElementsByName("previewButton")[i].disabled = false;
                  CrtLayoutElement.disableButtons = false;
              }
          }
        }
    }

    LayoutItem.prototype.handleMoved = function() {
        this.isEmpty = true;
        //reformat any sections as needed
        CrtLayoutElement.sectionsToReformat[this.sectionId] = CrtLayoutElement.getLayoutSection(this.sectionId);
    }

    /*move the cells around the layout
     *param rowPos, colPos specifies position to move these cells to
     */
     LayoutSection.prototype.moveCells = function(rowPos, colPos) {
         //first set the old positions to empty for all the cells being moved
         for (var i=0; i < MoveableItem.selectedBucket.length; i++) {
              MoveableItem.selectedBucket[i].fieldObj.handleMoved();
         }

        var shiftSize = MoveableItem.selectedBucket.length;
        var columnSize = this.numCols;
        //leftmost cell that needs to be moved
        var start = rowPos * columnSize + colPos;

        //rightmost element
        var lastElement = this.numRows * columnSize - 1;
        var lastNonEmptyPos = lastElement;
        if (!this.isEmpty) {
            while (lastNonEmptyPos >= 0 && this.layoutItems[Math.floor(lastNonEmptyPos/columnSize)][lastNonEmptyPos%columnSize].isEmpty) {
                lastNonEmptyPos--;
            }
        } else {
            lastNonEmptyPos = -1;
        }

        //farthest element that can be shifted but still be kept on screen
        var end = lastElement - shiftSize;

        //if we are moving to the very end, then we should just move it right after the lastNonEmptyPos if possible
        start = Math.min(start,lastNonEmptyPos+1);

       //if there are elements that we can't keep on the screen, we might have to increase the row size
       if (lastNonEmptyPos > end) {
            var moreRows = Math.ceil((lastNonEmptyPos + shiftSize - lastElement)/columnSize);
            while (moreRows > 0) {
                this.insertSectionRow();
                moreRows--;
            }
       }

       //shift all elements to the right one by one, starting from the rightmost until we reach the leftmost cell to be moved
       while (lastNonEmptyPos >= start) {
               this.moveCell(this.layoutItems[Math.floor((lastNonEmptyPos+shiftSize)/columnSize)][(lastNonEmptyPos+shiftSize)%columnSize],
                          this.layoutItems[Math.floor(lastNonEmptyPos/columnSize)][lastNonEmptyPos%columnSize]);
              lastNonEmptyPos--;
       }

       //now move all selected cells into vacated spot
       //starting from leftmost moving right
       for (var i =0 ; i < MoveableItem.selectedBucket.length; i++) {
              var selItem = MoveableItem.selectedBucket[i];
              this.insertCell(this.layoutItems[Math.floor((start+i)/columnSize)][(start+i)%columnSize],
                        selItem);
       }
        CrtLayoutElement.sectionsToReformat[this.sectionId] = this;
        CrtLayoutElement.reformatSections();
    }

    CrtLayoutElement.reformatSections = function() {
        for (var sId in CrtLayoutElement.sectionsToReformat) {
            CrtLayoutElement.sectionsToReformat[sId].reformatSection();
        }
        CrtLayoutElement.sectionsToReformat = {};

        CrtLayoutElement.checkDisableSave();

    }

    CrtLayoutElement.checkDisableSave = function() {

        var totalFields = 0;
        for (var sId in CrtLayoutElement.layoutSections) {
            totalFields += CrtLayoutElement.layoutSections[sId].numFields;
        }

        //check for fields limits
        var counter = document.getElementById('fieldsCounterInner');
        var counter2 = document.getElementById('fieldsCounterInner2');
        counter.innerHTML = totalFields;
        counter2.innerHTML = totalFields;
        if (totalFields > CrtLayoutElement.LAYOUT_FIELDS_LIMIT) {
            counter.style.color = '#CC0000';
            counter2.style.color = '#CC0000';
            if (document.getElementById('fieldsLimitError').style.display == 'none') {
                alert(LC.getLabel("CrtLayout","fieldsLimitErrorMsg",CrtLayoutElement.LAYOUT_FIELDS_LIMIT));

                //there's something weird with the order these statements are being run -- hide the dragDummy again because this alert clears the execution of the prior hiding of this dragDummy
                document.getElementById('dragDummy').style.visibility = 'hidden';
            }
            document.getElementById('fieldsLimitError').style.display = 'block';
            document.getElementById('fieldsLimitError2').style.display = 'block';
            CrtLayoutElement.disableLayoutButtons(true);
        } else {
            counter.style.color = 'green';
            counter2.style.color = 'green';
            document.getElementById('fieldsLimitError').style.display = 'none';
            document.getElementById('fieldsLimitError2').style.display = 'none';

            //if all fields are empty then we also disable the layout buttons
            if (totalFields > 0) {
                CrtLayoutElement.disableLayoutButtons(false);
            } else {
                CrtLayoutElement.disableLayoutButtons(true);
            }
        }
    }

    CrtLayoutElement.handleSelectedItems = function() {
        if (CrtLayoutElement.highlightSec) {
            CrtLayoutElement.moveSections();
        }
        else if (CrtLayoutElement.highlightAvailSection) {
            CrtLayoutElement.highlightAvailSection.moveCells();
        }
        else if (LayoutItemSeparator.highlightSep) {
            var itemSep = LayoutItemSeparator.highlightSep;
            CrtLayoutElement.getLayoutSection(itemSep.sectionId).moveCells(itemSep.rowPos, itemSep.colPos);
        } else {
        }
   }

   //move layout sections around in drag and drop
   CrtLayoutElement.moveSections = function() {
        //find the highlighted sec separator and insert all selected sections after this separator
        //find the of the section position we are inserting before
        var moveSecPos;
        var highlightSec = CrtLayoutElement.highlightSec;

        var moveToSep = document.getElementById(highlightSec.divId);
        var parentNode = document.getElementById(highlightSec.divId).parentNode;
        for (var i=0; i < MoveableItem.selectedBucket.length; i++) {
            if (MoveableItem.selectedBucket[i].isSection) {
                var sectionObj = MoveableItem.selectedBucket[i].fieldObj;
                var secDiv = document.getElementById(sectionObj.sectionId);
                var sepDivId = sectionObj.getSectionSepId();
                var sepDiv = document.getElementById(sepDivId);
                //insert both the section Div and the sep div that separates it from the next section
                parentNode.insertBefore(sepDiv,moveToSep);
                parentNode.insertBefore(secDiv,moveToSep);

                //remove the section
                for (var k=0; k<CrtLayoutElement.layoutSecPos.length;k++) {
                    if (sectionObj.sectionId == CrtLayoutElement.layoutSecPos[k]) {
                        CrtLayoutElement.layoutSecPos.splice(k,1);
                        break;
                    }
                }
            }
        }

        if (highlightSec.sectionId != CrtLayoutElement.LAST_SEC_SEP_DIV) {
            for (moveSecPos=0; moveSecPos<CrtLayoutElement.layoutSecPos.length; moveSecPos++) {
                if (highlightSec.sectionId == CrtLayoutElement.layoutSecPos[moveSecPos]) {
                    break;
                }
            }
        } else {
            //if we are inserting before the last section separator, we are inserting at the end
            moveSecPos = -1;
        }

        //insert the section into its new position
        for (var l=0; l<MoveableItem.selectedBucket.length; l++) {
            if (MoveableItem.selectedBucket[l].isSection) {
                //insert at the end
                if (moveSecPos < 0) {
                   CrtLayoutElement.layoutSecPos.push(MoveableItem.selectedBucket[l].fieldObj.sectionId);
                } else {
                   CrtLayoutElement.layoutSecPos.splice(moveSecPos,0,MoveableItem.selectedBucket[l].fieldObj.sectionId);
                }
            }
        }

   }


    LayoutSection.prototype.getSectionSepId = function() {
        return CrtLayoutElement.SECTION_SEP_DIV_PREFIX + this.sectionId;
    }


     LayoutSection.prototype.insertSepItemRow = function(itemObj){
        this.layoutSeparators[itemObj.rowPos] = [];
        if (itemObj.rowPos == this.numRows) {
            this.numRows++;
        }
     }

     LayoutSection.prototype.insertSeparatorCell = function(itemObj) {
         if (!this.layoutSeparators[itemObj.rowPos]) {
             this.insertSepItemRow(itemObj);
         }
         this.layoutSeparators[itemObj.rowPos][itemObj.colPos] = itemObj;
     }

     LayoutSection.prototype.insertItemRow = function(itemObj){
        this.layoutItems[itemObj.rowPos] = [];
        if (itemObj.rowPos == this.numRows) {
            this.numRows++;
        }
     }

     LayoutSection.prototype.insertField = function(itemObj) {
         if (!this.layoutItems[itemObj.rowPos]) {
             this.insertItemRow(itemObj);
         }
         this.layoutItems[itemObj.rowPos][itemObj.colPos] = itemObj;
     }

     LayoutSection.prototype.attachEvents = function() {
         var self = this;
         var tableElem = document.getElementById(self.sectionHeaderId);
         addEvent(tableElem, 'click', function(evt) {self.handleMouseClick(evt);}, false);
         addEvent(tableElem, 'mousedown', function(evt) {self.handleMouseDown(evt);}, false);
         addEvent(tableElem, 'mouseover', function(evt) {self.handleMouseOver(evt);}, false);
         addEvent(tableElem, 'dblclick', function(evt) {self.handleMouseDblClick(evt);}, false);
         addEvent(tableElem, 'mouseout', function(evt) {self.handleMouseOut(evt);}, false);
     }

     LayoutSection.prototype.handleMouseClick = function(evt) {
        var evt= getEvent(evt);
        if (evt.ctrlKey) {
            this.toggleSelected(true);
        } else {

        }
     }

     LayoutSection.prototype.handleMouseDblClick = function(evt) {
         CrtLayoutElement.openPropertiesEdit(evt);
     }

    LayoutSection.getSection = function(rowNum,colNum) {
        return LayoutSection.sections[rowNum][colNum];
    }

     LayoutSection.prototype.handleMouseUp = function(evt) {


     }

     LayoutSection.prototype.handleMouseDown = function(evt) {
       var evt = getEvent(evt);
       if (!evt.shiftKey && !evt.ctrlKey && !this.isSelected) {
            this.toggleSelected(false);
       }
       CrtLayoutElement.mouseDown = true;
    }

    LayoutSection.prototype.handleMouseOut = function(evt) {
        document.getElementById(CrtLayoutElement.HOVER_DIV).style.display = 'none';
        clearTimeout(this.timeOut);
        this.mousingOver = false;
    }


    LayoutSection.prototype.handleMouseOver = function(evt) {
        var evt = getEvent(evt);
        this.posX = getMouseX(evt);
        this.posY = getMouseY(evt);
        if (!CrtLayoutElement.dragMove && !this.mousingOver) {
            var self = this;
            this.timeOut = setTimeout(function() {self.setupMouseOverDiv();},CrtLayoutElement.HOVER_TIME_OUT)
            this.mousingOver = true;
        }

    }

    LayoutSection.prototype.setupMouseOverDiv = function(evt) {
        var moElem = document.getElementById(CrtLayoutElement.HOVER_DIV);
        var html = '';
        var posx = this.posX+10;
        var posy = this.posY-60;
        html += '<div class="mouseOverHeader">'+ this.labelName + '</div>';
        html += '<div class="mouseOverBody">' + LC.getLabel("CrtLayout","layoutSecHover");
        html += '</div>';
        moElem.innerHTML = html;

        moElem.style.left = posx+"px";
        moElem.style.top = posy+"px";
        moElem.style.display = 'block';
        return moElem;
    }

LayoutSection.prototype.toggleSelected = function(isCtrlSelect) {
        if (this.isSelected) {
            this.removeSelection(false);
        }
        else {
            if (!isCtrlSelect) {
                MoveableItem.clearSelectedItems();
            }
            this.addSelection();
        }
}

LayoutSection.prototype.createMoveableItem = function() {
    return new MoveableItem(this.sectionId, this.labelName, this.labelName, this.labelName, 'SECTION', this, true, true, false, false);
}

LayoutSection.prototype.removeSelection = function(noBucketRemove) {
    if (!noBucketRemove && this.moveableItem) {
        this.moveableItem.removeSelection();
    }
    this.moveableItem = null;
    this.removeSelectionFormatting();
}

LayoutSection.prototype.remove = function() {
    this.removeSelection();

    for (var j = 0; j < this.numRows; j++) {
        for (var k = 0; k < this.numCols; k++) {
            var field = this.layoutItems[j][k];
                if (!field.isEmpty) {
                    field.addSelection();
                }
        }
    }

    //move all the fields back
    if (CrtLayoutElement.currentDisplayedSec) {
        CrtLayoutElement.currentDisplayedSec.moveCells();
    }

    MoveableItem.clearSelectedItems();
    this.isEmpty = true;

    //reorder sections
    for (var i=0; i<CrtLayoutElement.layoutSecPos.length;i++) {
        if (this.sectionId == CrtLayoutElement.layoutSecPos[i]) {
            CrtLayoutElement.layoutSecPos.splice(i,1);
            break;
        }
    }

    //remove the element
    var parentNode = document.getElementById(this.sectionId).parentNode;
    parentNode.removeChild(document.getElementById(this.sectionId));
    //remove the section separator
    parentNode.removeChild(document.getElementById(this.getSectionSepId()));

}


LayoutSection.prototype.addSelection = function() {
    var addSelection;
    this.moveableItem = this.createMoveableItem();
    addSelection = this.moveableItem.addSelection();
    //are we mixing the selection Bucket?
    if (addSelection) {
        this.addSelectionFormatting();
    }
}

LayoutSection.prototype.removeSelectionFormatting = function() {
    this.isSelected = false;
    this.render();

}

LayoutSection.prototype.addSelectionFormatting = function() {
    this.isSelected = true;
    this.render();
}

LayoutSection.prototype.render = function() {
    var headerElem = document.getElementById(this.sectionHeaderId);
    headerElem.innerHTML = this.labelName;
    headerElem.className = CrtLayoutElement.CSS_CLASS_LAYOUT_SECTION;
    if (this.isSelected) {
        headerElem.className += ' '+CrtLayoutElement.CSS_CLASS_SELECTED_SECTION;
    }
}



     function setFieldAttributes(sectionId, elementId, fieldId, fieldName, displayName, customName, type, rowPos, colPos, inLayout, isLookup, defaultChecked) {
        var item = new LayoutItem(sectionId, elementId, fieldId, fieldName, displayName, customName, type, rowPos, colPos, inLayout, isLookup, false, null, defaultChecked);
        item.insertField();
     }

     function setEmptyFieldAttributes(sectionId,elementId,rowPos,colPos,rowObj) {
        new LayoutItem(sectionId,elementId,null,null,null,null,null,rowPos,colPos,true,false, true, rowObj,false).insertField();
     }


    function LayoutItem(sectionId, elementId, fieldId, fieldName, displayName, customName, type, rowPos, colPos, inLayout, isLookup, isEmpty, rowObj, defaultChecked) {
         this.sectionId = sectionId;
         this.rowPos = rowPos;
         this.colPos = colPos;
         if (elementId == null && fieldId == null) {
             this.itemElem  = rowObj.insertCell(rowObj.cells.length);
             this.itemId = this.createNewCellId();
             this.itemElem.id = this.itemId;
         }
         else {
             this.itemId = elementId;
         }

         this.isEmpty = isEmpty;
         this.fieldId = fieldId;
         this.customName = customName;
         this.fieldName = escapeHTML(fieldName);

         this.isSelected = false;

         this.type = type;
         this.inLayout = inLayout;
         this.isLookup = isLookup;
         this.defaultChecked = defaultChecked;

         //this takes too long to set for lookup fields -- set it when we actually hover
         this.displayName = this.isLookup ? null : displayName;
    }


    LayoutItem.prototype.setupMouseOverDiv = function(evt) {
        var moElem = document.getElementById(CrtLayoutElement.HOVER_DIV);
        var html = '';
        var posx = this.posX+10;
        var posy = this.posY-60;
        html += '<div class="mouseOverHeader">'+ this.fieldName + (this.isLookup ? ' ' + LC.getLabel("CRTLookupLayer","viaLookupParen") : '') + '</div>';
        if (!this.displayName) {
            this.displayName = CrtLayoutElement.getDisplayPath(this.fieldId,true);
        }
        html += '<div class="mouseOverBody">' + LC.getLabel("CrtLayout","CustomLabel") + ': '+ (this.customName ? this.customName : this.displayName) + '<br>';
        html += LC.getLabel("CrtLayout","defaultState") +' ';
        if (this.defaultChecked) {
              html += LC.getLabel("CrtLayout","checked");
        } else {
            html += LC.getLabel("CrtLayout","unchecked");
        }
        html += ' <br> ';
        html += LC.getLabel("CrtLayout","sourceObject") + ' ';
        //get source object
        var primObjId = this.isLookup ? CrtLayoutElement.getPrimObjId(this.fieldId,'.') : CrtLayoutElement.getPrimObjId(this.fieldId,CrtLayoutElement.FIELD_SEP);
        var sourceObject = CrtLayoutElement.getPrimObjMetaMap()[primObjId].label;
        if (this.isLookup) {
            html += CrtLayoutElement.getLookupFieldFromPath(CrtLayoutElement.getPath(this.fieldId)).lookupLabel + '<br>(' +LC.getLabel("CrtLayout","associatedWith")+' ' + sourceObject +')';
        } else {
            html += sourceObject;
        }
        html += '<br>';
        if (this.isLookup) {
            html += '<br>';
            html += LC.getLabel("CrtLayout","lookupPath") + ' ' + CrtLayoutElement.getDisplayPath(this.fieldId,false);
            html += '<br>';
        }
        moElem.innerHTML = html;

        moElem.style.left = posx+"px";
        moElem.style.top = posy+"px";
        moElem.style.display = 'block';
        return moElem;
    }

    function MoveableItem(itemId, fieldName, displayName, customName, type, fieldObj, inLayout, isSection, isLookup, defaultChecked) {
        this.itemId = itemId;
        this.fieldName = fieldName;
        this.displayName = displayName;
        this.customName = customName;
        this.type = type;
        this.fieldObj = fieldObj;
        this.inLayout = inLayout;
        this.isSection = isSection;
        this.isLookup = isLookup;
        this.defaultChecked = defaultChecked;
    }

    //insert a field into the Layout Section Object
    LayoutItem.prototype.insertField = function() {
        CrtLayoutElement.layoutSections[this.sectionId].insertField(this);
    }

    //format a field - set background color
    LayoutItem.prototype.formatField = function() {
        if (!this.itemElem) {
            this.itemElem = document.getElementById(this.itemId);
        }
        var className = CrtLayoutElement.CSS_CLASS_LAYOUT_CELL;
        if (!this.isEmpty) {
             className += ' ' + CrtLayoutElement.CSS_CLASS_LAYOUT_ITEM;
             if (this.isSelected) {
                className += ' ' + CrtLayoutElement.CSS_CLASS_SELECTED_ITEM;
             }
             var innerHTML = '';
             var formattedName = this.formatName(this.fieldName);
             if (this.defaultChecked) {
                 innerHTML += CrtLayoutElement.DFLT_CHECKED_ICON_URL;
             }
             if (this.isLookup) {
                innerHTML += CrtLayoutElement.LOOKUP_ICON_URL;
            }
            if (innerHTML != '') {
                innerHTML += ('&nbsp;' + formattedName);
            } else {
                innerHTML = formattedName;
            }
            this.itemElem.innerHTML = innerHTML;
        } else {
            this.setCellToEmpty();
        }
        this.itemElem.className = className;
    }

    LayoutItem.prototype.formatName = function(fieldName) {
        if (!fieldName) {
            return '';
        }
        //truncate more characters if we have the other icons on the tiles also
        var maxLength = CrtLayoutElement.MAX_DISPLAY_FIELD_LENGTH - (this.defaultChecked ? 3 : 0) - (this.isLookup ? 2 : 0);

        if (fieldName.length > maxLength) {
            return fieldName.substring(0,maxLength-2)+"...";
        }
        else {
            return fieldName;
        }
    }

    LayoutItem.prototype.handleMouseOut = function() {
        if (this.isEmpty) {
            return;
        }
        document.getElementById(CrtLayoutElement.HOVER_DIV).style.display = 'none';
        clearTimeout(this.timeOut);
        this.mousingOver = false;
    }

    LayoutItem.prototype.handleMouseDown = function(evt) {
       if (this.isEmpty) {
           return;
       }
       var evt = getEvent(evt);
       if (!evt.shiftKey && !evt.ctrlKey && !this.isSelected) {
            this.toggleSelected(false);
       }
       CrtLayoutElement.mouseDown = true;
    }

    LayoutItem.prototype.handleMouseOver = function(evt) {
        var evt = getEvent(evt);
        this.posX = getMouseX(evt);
        this.posY = getMouseY(evt);
        if (CrtLayoutElement.mouseDown && CrtLayoutElement.dragMove && !MoveableItem.currentSelectedObj.isSection) {
           var sectionObj = CrtLayoutElement.getLayoutSection(this.sectionId);
           CrtLayoutElement.clearHighlights();
           var sepObj = sectionObj.layoutSeparators[this.rowPos][this.colPos];
           sepObj.setHighlighted(true);
        } else {
            if (!this.isEmpty && !CrtLayoutElement.dragMove && !this.mousingOver) {
                 var self = this;
                 this.timeOut = setTimeout(function() {self.setupMouseOverDiv();},CrtLayoutElement.HOVER_TIME_OUT)
                 this.mousingOver = true;
            }
        }
    }

    LayoutSection.prototype.getSepCell = function(rowPos,colPos) {
        return this.layoutSeparators[rowPos][colPos];
    }

    CrtLayoutElement.getLayoutSection = function(sectionId) {
        return CrtLayoutElement.layoutSections[sectionId];
    }

    LayoutItem.prototype.handleMouseDblClick = function(evt) {
        if (this.isEmpty) {
            return;
        }
        CrtLayoutElement.openPropertiesEdit(evt);
    }


    LayoutItem.prototype.handleMouseClick = function(evt) {
        if (this.isEmpty) {
            return;
        }
        var evt = getEvent(evt);
        if (evt.shiftKey && MoveableItem.currentSelectedObj) {
            LayoutItem.multiSelect(this);
        } else if (evt.ctrlKey) {
            this.toggleSelected(true);
        } else {

        }
     }

     LayoutItem.prototype.toggleSelected = function(isCtrlSelect) {
        if (this.isSelected) {
            this.removeSelection(false);
        }
        else {
            if (!isCtrlSelect) {
                MoveableItem.clearSelectedItems();
            }
            this.addSelection();
        }
     }

    //remove all selected elements
    MoveableItem.clearSelectedItems = function() {
        var selB = MoveableItem.selectedBucket;
        for (var i = 0; i < MoveableItem.selectedBucket.length; i++) {
            MoveableItem.selectedBucket[i].fieldObj.removeSelection(true);
        }
        MoveableItem.selectedBucket = [];
        MoveableItem.currentSelectedObj = null;
    }

    LayoutItem.prototype.removeSelectionFormatting = function() {
        this.isSelected = false;
        this.formatField();
    }

    LayoutItem.prototype.createMoveableItem = function() {
        return new MoveableItem(this.fieldId, this.fieldName, this.displayName, this.customName, this.type, this, true, false, this.isLookup, this.defaultChecked)
    }

    LayoutItem.prototype.removeSelection = function(noBucketRemove) {
        if (!noBucketRemove && this.moveableItem) {
            this.moveableItem.removeSelection();
        }
        this.moveableItem = null;
        this.removeSelectionFormatting();
    }

    LayoutItem.prototype.addSelectionFormatting = function() {
        this.isSelected = true;
        this.formatField();
    }

    LayoutItem.prototype.addSelection = function() {
        var addSelection;
        if (this.isEmpty) {
            return;
        }
        this.moveableItem = this.createMoveableItem();
        addSelection = this.moveableItem.addSelection();
        //are we mixing the selection Bucket?
        if (addSelection) {
            this.addSelectionFormatting();
        }
    }

    MoveableItem.prototype.addSelection = function() {
        //make sure we are not mixing sections and items
        if (MoveableItem.currentSelectedObj && (this.isSection != MoveableItem.currentSelectedObj.isSection)) {
            return false;
        }
        if (isIE5) {
            MoveableItem.selectedBucket = MoveableItem.selectedBucket.concat(this);
        } else {
            MoveableItem.selectedBucket.push(this);
        }

        MoveableItem.currentSelectedObj = this;
        return true;
    }

    MoveableItem.prototype.removeSelection = function() {
         for (var i = 0; i < MoveableItem.selectedBucket.length; i++) {
            if (MoveableItem.selectedBucket[i].itemId == this.itemId) {
                MoveableItem.selectedBucket.splice(i, 1);
            }
        }
        if (MoveableItem.currentSelectedObj == this) {
            MoveableItem.currentSelectedObj = null;
            if (MoveableItem.selectedBucket.length > 0) {
                MoveableItem.currentSelectedObj = MoveableItem.selectedBucket[MoveableItem.selectedBucket.length-1];
            }
        }
    }


    //handleMultiSelect with shift key
    LayoutItem.multiSelect = function(itemObj) {
        //if in different sections, return
        if (MoveableItem.currentSelectedObj.fieldObj.sectionId != itemObj.sectionId) {
            return;
        }
        var previousSelectedItem = MoveableItem.currentSelectedObj;
        var rowNum1 = previousSelectedItem.fieldObj.rowPos;
        var rowNum2 = itemObj.rowPos;
        var colNum1 = previousSelectedItem.fieldObj.colPos;
        var colNum2 = itemObj.colPos;
        var startRow = Math.min(rowNum1, rowNum2);
        var endRow =  Math.max(rowNum1, rowNum2);
        var startCol =  Math.min(colNum1, colNum2);
        var endCol =  Math.max(colNum1, colNum2);
        if (startRow == endRow && startCol == endCol) {
            itemObj.removeSelection(false);
            return;
        }
        var moving = MoveableItem.selectedBucket;
        MoveableItem.clearSelectedItems();
        CrtLayoutElement.clearTextSelection();
        for (var i = startRow; i <= endRow; i++ ) {
            for (var j = startCol; j <= endCol; j++) {
                 CrtLayoutElement.layoutSections[itemObj.sectionId].getItem(i,j).addSelection();
            }
        }

        MoveableItem.currentSelectedObj = previousSelectedItem;
    }

   CrtLayoutElement.save = function() {
        var xml = CrtLayoutElement.toXML();
        var submitForm = document.forms[CrtLayoutElement.XML_FORM_NAME];
        submitForm.val.value = xml;
        submitForm.submit();
   }

   CrtLayoutElement.toXML = function() {
        var xml = '<' + CrtLayoutElement.ROOT_CONTAINER + '>\n';

       for (var i=0; i<CrtLayoutElement.layoutSecPos.length; i++) {
            xml += CrtLayoutElement.layoutSections[CrtLayoutElement.layoutSecPos[i]].toXml();
        }

        xml += '</' + CrtLayoutElement.ROOT_CONTAINER + '>\n';
        return xml;
    }


    CrtLayoutElement.escapeXML = function(v) {
        v = v.replace(/&/g, '\&amp;');
        v = v.replace(/"/g, '\&quot;');
        v = v.replace(/'/g, "\'");
        v = v.replace(/</g, '&lt;');
        v = v.replace(/>/g, '&gt;');

        return v;
    }

   LayoutSection.prototype.toXml = function() {
        var xml = '<' + CrtLayoutElement.SECTION + ' ';
        //add sectionId
        xml += CrtLayoutElement.SECTION_ID + '=' + '"' + CrtLayoutElement.escapeXML(this.sectionValue) + '" ';
       //add sectionName
        xml += CrtLayoutElement.SECTION_NAME + '=' + '"' + CrtLayoutElement.escapeXML(this.labelName) + '" >\n';
        //iterate over all layout items and add them to xml
        for (var i=0; i < this.numRows; i++) {
            for (var j=0; j< this.numCols; j++) {
                if (!this.getItem(i,j).isEmpty) {
                    xml += '\t';
                    xml += this.getItem(i,j).toXml();
                }
            }
        }

        xml += '</' + CrtLayoutElement.SECTION + '>\n';
        return xml;
   }

   LayoutItem.prototype.toXml = function() {
        var xml = '<' + CrtLayoutElement.ITEM + ' ';
        //add itemId
        xml += CrtLayoutElement.ITEM_ID + '=' + '"' + CrtLayoutElement.escapeXML(this.fieldId) + '" ';
        //add itemName
        xml += CrtLayoutElement.ITEM_NAME + '=' + '"' + CrtLayoutElement.escapeXML(this.fieldName) + '" ';
        //add default selected
        xml += CrtLayoutElement.ITEM_DEFAULT_CHECKED + '=' + '"' + this.defaultChecked + '" ';
        //add custom label
        if (this.customName != null) {
            xml += CrtLayoutElement.ITEM_CUSTOMLABEL + '=' + '"' + CrtLayoutElement.escapeXML(this.customName) + '" ';
        }
        //add itemType
        xml += CrtLayoutElement.ITEM_TYPE + '=' + '"' + this.type + '" >';

        xml += '</' + CrtLayoutElement.ITEM + '>\n';
        return xml;
   }

   LayoutSection.prototype.getItem = function(rowNum,colNum) {
        return this.layoutItems[rowNum][colNum];
    }

    CrtLayoutElement.isMouseDown = function() {
        return CrtLayoutElement.mouseDown;
    }

     function LayoutSectionSeparator(divId, sectionId) {
         this.divId = divId;
         this.sectionId = sectionId;
         this.attachEvents();
         this.setHighlighted(false);
     }

     LayoutSectionSeparator.prototype.setHighlighted = function(isHighlighted) {
           this.isHighlighted = isHighlighted;
           this.formatSeparator();
           if (isHighlighted) {
                   CrtLayoutElement.highlightSec = this;
           } else {
                   CrtLayoutElement.highlightSec = null;
           }
     }

    LayoutSectionSeparator.prototype.attachEvents = function() {
         var self = this;
         addEvent(document.getElementById(self.divId), 'mouseover', function(evt) {self.handleMouseOver(evt);}, false);
    }

    LayoutSectionSeparator.prototype.handleMouseOver = function() {
        if (CrtLayoutElement.mouseDown && CrtLayoutElement.dragMove && MoveableItem.currentSelectedObj.isSection) {
            if (CrtLayoutElement.highlightSec) {
                CrtLayoutElement.highlightSec.setHighlighted(false);
            }
            this.setHighlighted(true);
        }
    }

    //format a section separator
    LayoutSectionSeparator.prototype.formatSeparator = function() {
        var itemElem = document.getElementById(this.divId);
        var className = CrtLayoutElement.CSS_CLASS_LAYOUT_SECTION_SEPARATOR;
        if (this.isHighlighted) {
            className += ' ' + CrtLayoutElement.CSS_CLASS_LAYOUT_SECTION_SEPARATOR_HIGHLIGHT;
        }
        itemElem.className = className;
    }

     function setSeparatorAttributes(sectionId,elementId, rowPos, colPos, rowObj) {
        new LayoutItemSeparator(sectionId,elementId, rowPos,colPos, rowObj).insertField();
     }


     function LayoutItemSeparator(sectionId, elementId, rowPos, colPos, rowObj) {
         this.sectionId = sectionId;
         this.rowPos = rowPos;
         this.colPos = colPos;
         if (elementId == null) {
             this.itemElem  = rowObj.insertCell(rowObj.cells.length);
             this.id = this.createNewCellId();
             this.itemElem.id = this.id;
         }
         else {
            this.id = elementId;
         }
    }

    //insert a field into the Layout Section Object
    LayoutItemSeparator.prototype.insertField = function() {
        CrtLayoutElement.layoutSections[this.sectionId].insertSeparatorCell(this);
    }

    LayoutItemSeparator.prototype.handleMouseUp = function(evt) {
        if (CrtLayoutElement.mouseDown && CrtLayoutElement.dragMove) {
            var evt = getEvent(evt);
            CrtLayoutElement.layoutSections[this.sectionId].moveCells(this.rowPos,this.colPos);
            this.setHighlighted(false);
        }
    }

    LayoutItemSeparator.prototype.handleMouseOver = function() {
        if (CrtLayoutElement.mouseDown && CrtLayoutElement.dragMove && !MoveableItem.currentSelectedObj.isSection) {
            if (LayoutItemSeparator.highlightSep) {
                LayoutItemSeparator.highlightSep.setHighlighted(false);
            }
            this.setHighlighted(true);
        }
      }

       LayoutItemSeparator.prototype.setHighlighted = function(isHighlighted) {
           this.isHighlighted = isHighlighted;
           this.formatSeparator();
           if (isHighlighted) {
                   LayoutItemSeparator.highlightSep = this;
           } else {
                   LayoutItemSeparator.highlightSep = null;
           }
       }


    //format a separator
    LayoutItemSeparator.prototype.formatSeparator = function() {
        var className = CrtLayoutElement.CSS_CLASS_LAYOUT_ITEM_SEPARATOR;
        if (this.isHighlighted) {
            className += ' ' + CrtLayoutElement.CSS_CLASS_LAYOUT_ITEM_SEPARATOR_HIGHLIGHT;
        }
        if (!this.itemElem) {
            this.itemElem = document.getElementById(this.id);
        }
        this.itemElem.className = className;
    }

    function escapeQuotes(v) {
        if (v && v.replace){
            v = v.replace(/'/g, "\'");
            v = v.replace(/"/g, '&quot;');
        }
        return v;
    }

    function doNothing(evt) {
        evt = getEvent(evt);
        eventCancelBubble(evt);
    }

   CrtLayoutElement.preview = function(url) {
        document.submitForm.val.value = CrtLayoutElement.toXML();
        openPopupFocus('', 'crtlayoutpreview', 700, 500,'location=no,dependent=no,resizable=yes,toolbar=no,status=no,directories=no,menubar=no,scrollbars=yes', true, false, false);
        borrowForm('submitForm', url, 'crtlayoutpreview');
   }

   CrtLayoutElement.getLookupFieldFromPath = function(path) {
    var primObjMData = CrtLookups.primaryObjects;
    var fieldsMData = CrtLookups.fields;

    var iFieldSep = path.lastIndexOf('.');
    var iSep = path.indexOf('.');
    var table = primObjMData[path.substring(0,iSep)].table;
    var lookup;
    while (iSep != iFieldSep) {
        lookup = path.substring(iSep+1,path.indexOf('.',iSep+1));
        table = fieldsMData[table][lookup].lookup;
        iSep = path.indexOf('.',iSep+1);
    }
    lookup = path.substring(iSep+1);
    return fieldsMData[table][lookup];
}



    CrtLayoutElement.getPath  = function(value) {
        return value.substring(0,value.indexOf(CrtLayoutElement.FIELD_SEP));
    }

    //if isDisplayName, we use ":" separator notation, ">>" otherwise
    CrtLayoutElement.getDisplayPath = function(value, isDisplayName) {
        var path = '';
        path += CrtLayoutElement.getPrimObjMetaMap()[CrtLayoutElement.getPrimObjId(value,'.')].label + (isDisplayName ? ': ' : ' >> ');
        var table = CrtLayoutElement.getPrimObjMetaMap()[CrtLayoutElement.getPrimObjId(value,'.')].table;
        value = value.substring(value.indexOf('.')+1);
        var separator = isDisplayName ? ': ' : ' > ';
        var pathLabel;
        while (value.indexOf('.') > -1) {
            table = CrtLookups.fields[table];
            path += table[value.substring(0,value.indexOf('.'))].label + separator;
            table = table[value.substring(0,value.indexOf('.'))].lookup;
            value = value.substring(value.indexOf('.')+1);
        }
        table = CrtLookups.fields[table];
        path += table[value.substring(0,value.indexOf(CrtLayoutElement.FIELD_SEP))].label + separator;
        table = table[value.substring(0,value.indexOf(CrtLayoutElement.FIELD_SEP))].lookup;

        path += CrtLookups.fields[table][value.substring(value.indexOf(CrtLayoutElement.FIELD_SEP)+1,value.indexOf(CrtLayoutElement.COL_SEP))].label;
        return path;
    }

    //return the AvailabaleSection based on the fieldValue we are given
CrtLayoutElement.getSectionFromFieldValue = function(fieldValue) {
    //kind of HACK way of knowing whether something is a lookup item for not...looking for path separator
    if (fieldValue.indexOf('.') > -1) {
        var primId = CrtLayoutElement.getPrimObjId(fieldValue,'.');
        return CrtLayoutElement.availableSections[CrtLookupSection.getSectionIdFromPrim(primId)];
    } else {
        var primId = CrtLayoutElement.getPrimObjId(fieldValue,CrtLayoutElement.FIELD_SEP);
        return CrtLayoutElement.availableSections[primId];
    }
}

CrtLayoutElement.getPrimObjId = function(path,separator) {
    if (!path) {
        return;
    }
    var iSep= path.indexOf(separator);
    if (iSep > 0) {
        path = path.substring(0,iSep);
        return path;
    } else {
        return null;
    }
}

   CrtLayoutElement.scrollAvailableSection = function(evt){
        var cru = document.getElementById(CrtLayoutElement.SECTION_AVAIL_WRAPPER_ID);
        if (cru) {
            var topValue;
             if(!CrtLayoutElement.availableSectionPosInited) {
                CrtLayoutElement.availableSectionInitPosY = getObjY(cru);
                cru.style.top = '0px';
                CrtLayoutElement.availableSectionPosInited = true;
                return;
            }
            var initLeftHeight = document.getElementById(CrtLayoutElement.LEFT_SECTION_ID).offsetHeight;
            var initRightHeight = document.getElementById(CrtLayoutElement.SECTION_AVAIL_WRAPPER_ID).offsetHeight;
            maxTopValue = initLeftHeight;
            //don't scroll it till it goes offscreen
            if(CrtLayoutElement.availableSectionInitPosY+5 < getScrollY()){
                topValue = getScrollY();
                if (topValue + initRightHeight - 295 < initLeftHeight) {
                   cru.style.top = topValue - 295 + "px";
                //if we are at the bottom of the layout sections, then no more scrolling
                } else {
                    cru.style.top = initLeftHeight-initRightHeight + "px";
                }
            } else {
                cru.style.top = "0px";
            }
        }

    }


// Display the div the corresponds to the selectd value of the SelectElement.  Hide the divs for
// all unselected values.
// The divIds should be provided in the same order that the SelectElement values are generated.
function SelectElementDependency(selectElementId, /* array */ divIds) {
	this.divIds = divIds;
	this.selectElementId = selectElementId;

    var self = this;

	this.changeVisibleDiv = function() {
		var selectedIndex = document.getElementById(self.selectElementId).selectedIndex;

		for (var i = 0; i < divIds.length; i++) {
			var displayValue;
			if (i == selectedIndex)
				displayValue = 'block';
			else
				displayValue = 'none';

			document.getElementById(self.divIds[i]).style.display = displayValue;
		}
	}

	// initialize so the correct the element is shown on the page
    this.changeVisibleDiv();

    addEvent(document.getElementById(this.selectElementId), 'change', this.changeVisibleDiv, false);
}

/**
  Used for delete confirmations on related lists
  Implemented primarily as a demo of the js/localization binding

  @author polcari
  @since 144
*/

function confirmDelete(msg) {
  if (!msg) {
      msg = LC.getLabel("Global", "are_you_sure");
  }
  return Modal.confirm(msg);
}
/**
 * CRT Object selection UI
 *
 * @author tkim
 * @since 148
 */
 
/**
 * This JS class manages the object selection picklists
 */
CrtObjects.DOT_SEPARATOR = CrtConstants.PICKLIST_VALUE_TABLE_FIELD_SEPARATOR;
CrtObjects.ID_SEPARATOR = CrtConstants.PICKLIST_VALUE_ID_SEPARATOR;

CrtObjects.init = function(relationships) {
    var picks = new Array();
    for(var iPicklist = 0; iPicklist < CrtConstants.MAX_OBJECTS; iPicklist++) {
        var pick = document.getElementById(CrtConstants.OBJECT_PREFIX + iPicklist);
        picks[iPicklist] = pick;
    }
    return new CrtObjects(relationships, picks);
}

/**
  we require a map, given as JSON:

  Map<String, Array of Relationship> map from Object to Array of Relationship
  Relationship = tuple (name/value, label)

    var relationships = {
        "Account" : [
            { value : "Contact.Account", label: "Contacts" },
            { value : "Opportunity.Account", label: "Opportunities } ],
        "Contact": [
        ]
    };

For a given relationship value, for example, "Contact.Account", the substring
preceding the dot is necessarily another element in the map.

*/
function CrtObjects(relationships, picks) {
    this.relationships = relationships;
    this.picks = picks;
    this.originalValues = CrtObjects.getSelectedValues(picks);

// for debugging:
/*
    var self = this;
    for(var iPicklist = 0; iPicklist < picks.length; iPicklist++) {
        addEvent(this.picks[iPicklist], 'change', this.getUpdatePicklistsClosure(iPicklist), false);
    } */
}

// public
CrtObjects.prototype.getPicklist = function(iPicklist) {
    return this.picks[iPicklist];
}

// public
CrtObjects.prototype.getValue = function(iPicklist) {
    return CrtObjects.getSelectedValue(this.picks[iPicklist]);
}

/** this is necessary to make iPicklist effectively like a final variable
    by taking a snapshot of the stack frame */
CrtObjects.prototype.getUpdatePicklistsClosure = function(iPicklist) {
    var self = this;
    return function() { self.updatePicklists(iPicklist) };
}

/**
 if picklist i changes, then:
     if this is not the last picklist:
         - set all picklists j > i to null value (or maybe to a previous value?)
         - set the options for the next picklist i+1 to the relationship values
 */
CrtObjects.prototype.updatePicklists = function(iPicklist) {
    // clear all picklists j > i
    for(var j = iPicklist + 1; j < CrtConstants.MAX_OBJECTS; j++) {
       this.picks[j].options.length = 1; // leave the --None-- option
    }

    if (iPicklist < (CrtConstants.MAX_OBJECTS - 1)) {
        // set the options for the next picklist i+1 to the relationships
        var value = CrtObjects.getSelectedValue(this.picks[iPicklist]);
        if (value != '') {
	        var object = this.parseObject(CrtObjects.getSelectedValue(this.picks[iPicklist]));
	        var rels = this.relationships[object];
            for(var iRel = 0; iRel < rels.length; iRel++) {
                var rel = rels[iRel];
                var relValue = this.swapOriginalValue(iPicklist + 1, rel.value);
                var options = this.picks[iPicklist + 1].options;
                options[options.length] = new Option(rel.label, relValue);
            }
        }
    }
}

/* restore the original value that includes the ID, if this is the same as the original value */
CrtObjects.prototype.swapOriginalValue = function(iChildPicklist, relationshipValue) {
    var ret = relationshipValue;
    // is the parent set to the original value?  only do the swap if the parent
    // is also set to an original value.  if the parent set to a new value then
    // the child never corresponds to the original value.
    var parentPicklistValue = CrtObjects.getSelectedValue(this.picks[iChildPicklist - 1]);
    if (parentPicklistValue.indexOf(CrtObjects.ID_SEPARATOR) >= 0) {
        // if the parent has an ID, then it must be an original value
        // so test this child relationship for swap
        var originalChildValue = this.originalValues[iChildPicklist];
        originalChildValue = originalChildValue.substring(0, originalChildValue.indexOf(CrtObjects.ID_SEPARATOR)); // strip the ID for the test
        if (relationshipValue == originalChildValue) {
            ret = this.originalValues[iChildPicklist];
        }
    }
    return ret;
}

// private
// get the selected value of a select element
CrtObjects.getSelectedValue = function(selectElement) {
    return selectElement.selectedIndex < 0 ? null : selectElement.options[selectElement.selectedIndex].value;
}

// private
CrtObjects.getSelectedValues = function(picks) {
    var originalValues = new Array();
    for(var iPick = 0; iPick < picks.length; iPick++) {
        originalValues[iPick] = CrtObjects.getSelectedValue(picks[iPick]);
    }
    return originalValues;
}

// private
// grab the object from a string like "Contact.Account" or "Contact.Account|071xxxxxx"
CrtObjects.prototype.parseObject = function(picklistValue) {
    var value;
    var iDot = picklistValue.indexOf(CrtObjects.DOT_SEPARATOR);
    var iPipe = picklistValue.indexOf(CrtObjects.ID_SEPARATOR);
    if (iDot >= 0) {
        value = picklistValue.substring(0, iDot);
    } else if (iPipe >= 0) {
        // No dot (first picklist of root objects) so just take the value, minus the pipe-ID part
        value = picklistValue.substring(0, iPipe);
    } else {
        // Not even a pipe, so take the whole thing
        value = picklistValue;
    }
    return value;
}
    /** @author zzhou
     *  @since 150
     * Used for ForecastRoleUserPage to enable/disable the Forecast Share options for a FM */

	function ForecastRoleUser() {};
    ForecastRoleUser.checkDisplayAllowSharing = function() {
        var selectedElement = document.getElementById(ForecastRoleUser.pUSER)
        //if no user is selected, we hide the Forecast Sharing div and disable the checkboxes
        if (selectedElement.options[selectedElement.selectedIndex].value == '') {
            document.getElementsByName(ForecastRoleUser.pCAN_SHARE)[0].disabled=true;
            document.getElementsByName(ForecastRoleUser.pCAN_SHARE)[1].disabled=true;
            document.getElementById(ForecastRoleUser.FORECAST_SHARE_RADIO).style.visibility = 'hidden';
        } else {
            document.getElementsByName(ForecastRoleUser.pCAN_SHARE)[0].disabled=false;
            document.getElementsByName(ForecastRoleUser.pCAN_SHARE)[1].disabled=false;
            document.getElementById(ForecastRoleUser.FORECAST_SHARE_RADIO).style.visibility = 'visible';
        }
    }

    //confirm fct share removal
    ForecastRoleUser.confirmRemoveShares = function(hadMgr) {
        var selectedElement = document.getElementById(ForecastRoleUser.pUSER);
        return selectedElement.options[selectedElement.selectedIndex].value != '' || !hadMgr || window.confirm(LC.getLabel("ForecastSharingPref","confirmAssignNoMgr"));
    }
/** 
 * 
 * Auto-Complete Lookup functionality using script injection technique.
 * To use this script, create a layout section header name with the value:
 * 
 *     <script src="/appex/autocomplete/ac.js"></script>AutoComplete
 *     
 * Presuming, of course, that the file exists in the specified directory.
 * This script also relies on the following scripts to be available:
 * 
 *     /soap/ajax/8.0/connection.js
 *
 * These scripts are included dynamically. (See the code below for more 
 * information.
 *
 */

//////////////////////////////////////////
// AutoComplete object handles query for Entities
// matching lookup type and partial string.
//////////////////////////////////////////

AutoComplete = function(el){

    this.baseName = this.getBaseName(el);
    this.type = this.getLookupType(el);
    this.lookupInput = this.getLookupInput(el);

    this.lookupInput.onkeyup = AutoComplete.prototype.onKeyUp;
    this.lookupInput.onfocus = AutoComplete.prototype.onFocus;
    this.lookupInput.onblur = AutoComplete.prototype.onBlur;
    this.hasFocus = false;

    this.valQueried = null;
    this.records;
    this.selected = -1;
    
    this.entityName;
    this.entityNameFields;
    
    if (this.type == '001'){
        this.entityName = 'Account';
        this.entityNameFields = ['Name'];
    } else if (this.type == '003') {
        this.entityName = 'Contact';
        this.entityNameFields = ['FirstName', 'LastName'];
    } else if (this.type == '005') {
        this.entityName = 'User';
        this.entityNameFields = ['FirstName', 'LastName', 'Alias'];
    }
    
}

// static variables
AutoComplete.prototype.RECORD_HEIGHT = 17;
AutoComplete.prototype.MIN_LENGTH_THRESHOLD = 3;
AutoComplete.prototype.TYPING_THRESHOLD_MILLIS = 200;
AutoComplete.prototype.HIGHLIGHT_COLOR = "#AACCFF";
AutoComplete.prototype.IS_IE = document.all;

// class variables
AutoComplete.prototype.AUTOCOMPLETE_MAP = [];
AutoComplete.prototype.IS_PROCESSING = false;
AutoComplete.prototype.FORM_NAME = 'editPage';

AutoComplete.prototype.getBaseName = function(el){
    if (!el) return this.baseName;
    var name = el.name;
    var idx = name.indexOf('_');
    if (idx > -1){
        return name.substring(0, idx);
    } else {
        return name;
    }
}

AutoComplete.prototype.isLookup = function(el){
    return el.name.indexOf('_lkid') > 0;
}

AutoComplete.prototype.getLookupInput = function(el){
    if (!el) return this.lookupInput;
    var base = this.getBaseName(el);
    return document.getElementById(base);
}

AutoComplete.prototype.getLookupType = function(el){
    if (!el) return this.type;
    var type;
    var base = this.getBaseName(el);
    var name = base +  "_lktp";
    var el = document.getElementById(name);
    if (el){
        type = el.value;
    }    
    return type;
}

AutoComplete.prototype.doLookup = function(val){

    if (!this.hasFocus || AutoComplete.prototype.IS_PROCESSING) return;

    // validate name parts before doing query
    var nameParts = this.parseName(val);
    if (!nameParts || nameParts.length == 0){
        return;
    }

    // mark as processing so we don't run multiple queries at a time
    AutoComplete.prototype.IS_PROCESSING = true;

    // keep last queried so we can do client-side subfiltering
    this.valQueried = val;
    
    var soql = "SELECT Id";

    for (var i = 0; i < this.entityNameFields.length; i++){
        soql += ", " + this.entityNameFields[i];
    }

    soql += " FROM " + this.entityName + " WHERE ";

    // for single-name entities, query single field as complete string
    if (this.entityNameFields.length == 1){
    
        soql += this.entityNameFields[0] + " like '" + val + "%' ";
    
    // for person-name entities, query for variations on the name
    } else {
        for (var i = 0; i < this.entityNameFields.length; i++){
            for (var j = 0; j < nameParts.length; j++){
                var part = nameParts[j];
                if (part){
                    soql += this.entityNameFields[i] + " like '" + part + "%' ";
                    if (i != this.entityNameFields.length - 1 || j != nameParts.length - 1){
                        soql += " OR "
                    }
                }
            }
        }
    }

    this.records = AutoComplete.prototype.query(soql).records;
    this.displayResults(this.records, val);
    
    AutoComplete.prototype.IS_PROCESSING = false;
    
}

AutoComplete.prototype.parseName = function(val){
    var partsTemp;
    if (val){
        partsTemp = val.split(' ');
    } else {
        partsTemp = [];
    }
    
    var parts = [];
    for (var i = 0; i < partsTemp.length; i++){
        var part = partsTemp[i];
        part = part.replace(' ', '');
        if (part){
            parts.push(part);
        }
    }
    return parts;
}

AutoComplete.prototype.displayResults = function(records, value){

    if (records && records.length > 0){

        var baseName = this.getBaseName();

        var html = [];
        html.push("<table width='100%' cellpadding='0' cellspacing='0' border='0'>");
        for (var i = 0; i < records.length; i++){
            var record = records[i];
            var id = ApiUtils.getId(record);
            html.push("<tr><td style='cursor: pointer;' onmouseover='AutoComplete.prototype.setSelected(\""+baseName+"\", "+i+");this.style.backgroundColor=\""+AutoComplete.prototype.HIGHLIGHT_COLOR+"\";' onmouseout='this.style.backgroundColor=\"\";'>");
            html.push("<div style='height:"+AutoComplete.prototype.RECORD_HEIGHT+"px;' id='"+id+"'>");
            var name = this.getName(record);
            html.push(this.highlightMatch(name, value));
            html.push("</div>");
            html.push("</td></tr>");
        }
        html.push("</table>");

        var boxName = this.getBaseName();
        var box = AutoComplete.prototype.getBox(boxName);
        if (!box){
            box = AutoComplete.prototype.makeBox(boxName, records.length * AutoComplete.prototype.RECORD_HEIGHT, 200);
    	    var inputEl = this.getLookupInput();
    	    var top = getObjY(inputEl) + 20;
    	    var left = getObjX(inputEl);
    	    AutoComplete.prototype.moveBox(boxName, top, left);
        } else {
            AutoComplete.prototype.resizeBox(baseName, records.length * AutoComplete.prototype.RECORD_HEIGHT, 200);
        }
        box.innerHTML = html.join('');    
        this.displaySuggestions(true);
    }    

}

AutoComplete.prototype.getName = function(record){
    var name = "";
    for (var i = 0; i < this.entityNameFields.length; i++){
        var value = record.get(this.entityNameFields[i]);
        if (value){
            name += value + " ";
        }
    }
    return name;
}

AutoComplete.prototype.highlightMatch = function(name, value){
    if (!name || !value) return "";
    
    var nameLower = name.toLowerCase();
    var valueLower = value.toLowerCase();
    
    var idx = nameLower.indexOf(valueLower);
    if (idx == -1){
        return name;
    } else {
        var before = name.substring(0, idx);
        var middle = name.substring(idx, idx + value.length);
        var after = name.substring(idx + value.length);
        var match = before + "<b>" + middle + "</b>" + after;
        return match;
    }
}

AutoComplete.prototype.doFilter = function(val){

    var filteredRecords = [];
    for (var i = 0; i < this.records.length; i++){
        var record = this.records[i];
        if (this.isMatch(record, val)){
            filteredRecords.push(record);
        }
    }
    
    if (filteredRecords && filteredRecords.length > 0){
        this.displayResults(filteredRecords, val);
    } else {
        this.doClear();
    }
	        
}

// similar to doLookup() code
AutoComplete.prototype.isMatch = function(record, val){

    var value = null;

    // for single-name entities, match single field as complete string
    if (this.entityNameFields.length == 1){
        value = record.get(this.entityNameFields[0]);
    // for person-name entities, query for variations on the name
    } else {
        value = this.getName(record);
    }
    
    return (value && value.toLowerCase().indexOf(val.toLowerCase()) > -1);
    
}

AutoComplete.prototype.doClear = function(){
    this.displaySuggestions(false);
    this.selected = -1;
}

AutoComplete.prototype.displaySuggestions = function(isVisible){
    AutoComplete.prototype.showBox(this.getBaseName(), isVisible);    
}

AutoComplete.prototype.selectItem = function(selectedIndex){

    var baseName = this.getBaseName();
    var id = null;
    var name = null;
            
    var box = AutoComplete.prototype.getBox(baseName);
    if (box && selectedIndex >= 0){
         var content = box.childNodes[0].childNodes[0];
     	 if (content && content.rows && selectedIndex < content.rows.length){
            var row = content.rows[selectedIndex];
			if (row){
			    var cell = row.cells[0];
                var div = cell.getElementsByTagName("div")[0];
                if (div){
                    id = div.id;
                }
			}
    	}
    }
    
    if (id){
        for (var i = 0; i < this.records.length; i++){
            var rec = this.records[i];
            if (id == ApiUtils.getId(rec)){
                name = this.getName(rec);
                break;
            } 
        }
    }

    // found an ID and a name; load the picklist
    if (id && name){
        lookupPick(AutoComplete.prototype.FORM_NAME, baseName+'_lkid', baseName, '', id, name, '', '');
    }    

    // item selected; clear the suggestion box
    var autoComplete = AutoComplete.prototype.AUTOCOMPLETE_MAP[baseName];
    if (autoComplete){
        autoComplete.doClear();
    }
    
}

//////////////////////////////
// Event hooks on lookup input element.
//////////////////////////////

AutoComplete.prototype.onKeyUp = function(event){

    if (!event){
        event = window.event;
    }

    var autoComplete = AutoComplete.prototype.AUTOCOMPLETE_MAP[this.name];
    if (!autoComplete){
        return;
    }

    var val = this.value;
    
    var isKeyPress = (event && event.keyCode);
    if (AutoComplete.prototype.IS_PROCESSING) {
        return;
    } else if (isKeyPress && AutoComplete.prototype.isEnter(event)) {
        // BUGBUG: how do we avoid submitting form on [ENTER] before
        // executing the onBlur()?
        return;
    } else if (isKeyPress && AutoComplete.prototype.isNavigation(event)) {
        AutoComplete.prototype.handleNav(this.name, event);
        return;
    } else if (isKeyPress && AutoComplete.prototype.isTypingFast(this.name, event)){
        return;
    } else if (isKeyPress && AutoComplete.prototype.isIgnore(event)) {
    	return;
    } else if (isKeyPress && AutoComplete.prototype.isEscape(event)){
        autoComplete.doClear();
    	return;
    }

    if (val != null && val.length >= AutoComplete.prototype.MIN_LENGTH_THRESHOLD){
    
        // initial query
        if (autoComplete.valQueried == null || val.toLowerCase().indexOf(autoComplete.valQueried.toLowerCase()) == -1){
            autoComplete.doLookup(val);
        // subquery; filter results
        } else {
            autoComplete.doFilter(val);
        }
            
   } else if (val == null || val.length <= AutoComplete.prototype.MIN_LENGTH_THRESHOLD){
       autoComplete.valQueried = null;
       autoComplete.doClear();
   }

}

AutoComplete.prototype.onFocus = function(event){

    var autoComplete = AutoComplete.prototype.AUTOCOMPLETE_MAP[this.name];
    if (!autoComplete){
        return;
    }
    autoComplete.hasFocus = true;

}

AutoComplete.prototype.onBlur = function(event){

    if (!event){
        event = window.event;
    }

    var autoComplete = AutoComplete.prototype.AUTOCOMPLETE_MAP[this.name];
    if (!autoComplete){
        return;
    }

    autoComplete.hasFocus = false;

    if (AutoComplete.prototype.TIMEOUT_ID){    
        clearTimeout(AutoComplete.prototype.TIMEOUT_ID);
    }
    
    // leaving input and is NOT ignore and NOT escape: select the highlighted item
    if (event && !AutoComplete.prototype.isIgnore(event) && !AutoComplete.prototype.isEscape(event) && autoComplete.selected >= 0){
        autoComplete.selectItem(autoComplete.selected);
        
    // otherwise: clear the complete suggestion w/ slight delay to allow
    // possible onclick to pass through to the suggestion div
    } else {
        setTimeout("AutoComplete.prototype.AUTOCOMPLETE_MAP['"+this.name+"'].doClear()", 200);
    }
    
}

//////////////////////////////
// Interaction with suggestion box.
//////////////////////////////

// sets selected index of a given auto-complete object. 
AutoComplete.prototype.setSelected = function(baseName, idx){
    var autoComplete = AutoComplete.prototype.AUTOCOMPLETE_MAP[baseName];
    if (!autoComplete){
        return;
    } else {
        autoComplete.selected = idx;
    }
    
}

// handle up/down for auto-complete
AutoComplete.prototype.handleNav = function(name, event){

    var autoComplete = AutoComplete.prototype.AUTOCOMPLETE_MAP[name];
    if (!autoComplete){
        return;
    }

    var code = event.keyCode;
    var isDown = (code == 40);
    
    var newSelected = autoComplete.selected;

      var box = AutoComplete.prototype.getBox(autoComplete.getBaseName());
      if (box){
      
          var content = box.childNodes[0].childNodes[0];
          if (content && content.rows){

              if (isDown){
                  if (autoComplete.selected < content.rows.length - 1){
                      newSelected++;
                  }
              } else {
                  if (autoComplete.selected > 0){
                      newSelected--;
                  }
              }
              
              if (autoComplete.selected >= 0){
                  var oldRow = content.rows[autoComplete.selected];
                  if (oldRow && oldRow.childNodes[0]){
                      oldRow.childNodes[0].onmouseout();
                  }
              }

			  if (newSelected >= 0){
                  var newRow = content.rows[newSelected];
                  if (newRow && newRow.childNodes[0]){
                      newRow.childNodes[0].onmouseover();
                  }
                  autoComplete.selected = newSelected;
		      }                  

		}           
     
    }
    
}

//////////////////////////
// Typing helpers.
//////////////////////////

// fast typing gets delayed complete
AutoComplete.prototype.LAST_DATE = null;
AutoComplete.prototype.TIMEOUT_ID = null;

// if typing fast, will delay onKeyUp() until after typing is slowed
AutoComplete.prototype.isTypingFast = function(name, event){
    
    // clear existing timeout to avoid flood of delayed onKeyUp calls
    if (AutoComplete.prototype.TIMEOUT_ID){    
        clearTimeout(AutoComplete.prototype.TIMEOUT_ID);
    }
    
	var d = new Date();
	if (AutoComplete.prototype.LAST_DATE == null){
	    AutoComplete.prototype.LAST_DATE = d;
	    return true;
	} else {
	    var diff = d.getTime() - AutoComplete.prototype.LAST_DATE.getTime();
	    AutoComplete.prototype.LAST_DATE = d;
	    if (diff < AutoComplete.prototype.TYPING_THRESHOLD_MILLIS){
	        var delayedExec = "document.getElementById('"+name+"').onkeyup();";
	        AutoComplete.prototype.TIMEOUT_ID = setTimeout(delayedExec, AutoComplete.prototype.TYPING_THRESHOLD_MILLIS);
	        return true;
	    } else {
	        return false;
	    }
	}
}

AutoComplete.prototype.isNavigation = function(event){
    var code = event.keyCode;
    return (code == 38 || code == 40);
}

// 9 is TAB; 16 is SHIFT-TAB
AutoComplete.prototype.isIgnore = function(event){
    var code = event.keyCode;
    return (code == 9 || code == 16 || (code >= 33 && code <= 46) || (code >= 112 && code <= 123));
}

AutoComplete.prototype.isEscape = function(event){
    var code = event.keyCode;
    return code == 27;
}

AutoComplete.prototype.isEnter = function(event){
    var code = event.keyCode;
    return code == 13;
}

/////////////////////////
// Query Helpers
/////////////////////////

AutoComplete.prototype.query = function(soql){

    try {
        var qr = sforce.connection.query(soql);
        var results = new Object();
        results.size = qr.size;
        results.records = qr.getArray("records");
        return results;
    } catch (fault){
        alert("error: " + fault);
    }
}

//////////////////////////
// Box helpers.
//////////////////////////

AutoComplete.prototype.makeBox = function(name, height, width) {

    // iframe shim b/c IE has input elements show throw plain DIVs
    if (AutoComplete.prototype.IS_IE){
        var iframe = document.createElement("iframe");
        iframe.id = name+"I";
        iframe.style.display = "block";
        iframe.style.position = "absolute";
        iframe.style.padding = "3px";
        iframe.style.height = height + "px";
        iframe.style.width = width + "px";
        iframe.style.backgroundColor = "#ffffCC";
        document.body.appendChild(iframe);
    }

    // div for the contents
    var div = document.createElement("div");
    div.id = name+"D";
    div.style.border = "1px solid #666";
    div.style.display = "block";
    div.style.position = "absolute";
    div.style.padding = "2px";
    div.style.height = height + "px";
    div.style.width = width + "px";
    div.style.backgroundColor = "#ffffCC";
    document.body.appendChild(div);
    
    return div;

}

AutoComplete.prototype.getBox = function(name){
    return document.getElementById(name+'D');

}

AutoComplete.prototype.resizeBox = function(name, height, width) {

    var iframe = document.getElementById(name+'I');
    if (iframe){
        iframe.style.height = height + "px";
        iframe.style.width = width + "px";
    }

    var box = document.getElementById(name+'D');
    if (box){
        box.style.height = height + "px";
        box.style.width = width + "px";
    }
}

AutoComplete.prototype.moveBox = function(name, top, left){

    var iframe = document.getElementById(name+'I');
    if (iframe){
        iframe.style.top = top + "px";
        iframe.style.left = left + "px";
        iframe.style.zIndex = 10;
    }

    var box = document.getElementById(name+'D');
    if (box){
        box.style.top = top + "px";
        box.style.left = left + "px";
        box.style.zIndex = 20;
    }

}

AutoComplete.prototype.showBox = function(name, isVisible){
    var disp = isVisible ? "block" : "none";
    var iframe = document.getElementById(name+'I');
    if (iframe){
        iframe.style.display = disp;
    }

    var box = document.getElementById(name+'D');
    if (box){
        box.style.display = disp;
    }
}

//////////////////////////
// Initialization helpers.
//////////////////////////

AutoComplete.prototype.loadAutoComplete = function(formName){

    if (!formName){
        AutoComplete.prototype.FORM_NAME = "editPage";
    }
    
    // initialize sforce connection
    var apiSession = getCookie("sid");
    var apiURL = ApiUtils.getApiURL(true, "7.0");
    sforce.connection.init(apiSession, apiURL, true);

    var els = document.getElementsByTagName("input");
    for (var i = 0; i < els.length; i++){
        var el = els[i];
        if (AutoComplete.prototype.isLookup(el)){
            var autoComplete = new AutoComplete(el);
            AutoComplete.prototype.AUTOCOMPLETE_MAP[autoComplete.getBaseName()] = autoComplete;
        }
    }
}






/**
 * SearchSettingsPage helper that provides check all functionality.
 * Keeps a counter on the number of checkboxes that are checked to prevent scanning all checkboxes on every click
 * @author mpaksoy
 * @since 154
 */
SearchSettingsPage = {
    totalCounts : {},
    currentCounts : {},

    toggleCheckboxes : function(checkboxid, suffix) {
        if (!checkboxid || !suffix) return;

        var editform = document.getElementById(EditPageConstants.pEDIT_PAGE);
        var checkbox = document.getElementById(checkboxid);

        if (checkbox && editform) {
            var cbVal = checkbox.checked;
            var total = 0;
            for (var i=0; i < editform.elements.length; i++) {
                var elem = editform.elements[i];
                if (elem && (elem != checkbox) && elem.id && (elem.type == 'checkbox')) {
                    var ind = elem.id.indexOf(suffix);
                    if ((ind >= 0) && ((ind + suffix.length) == elem.id.length)) {
                        elem.checked = cbVal;
                        total++;
                    }
                }
            }

            SearchSettingsPage.totalCounts[suffix] =  total;
            if (checkbox.checked) {
                SearchSettingsPage.currentCounts[suffix] =  total;
            } else {
                SearchSettingsPage.currentCounts[suffix] =  0;
            }
        }
    },

    updateParentCheckbox : function(thisCbId, parentCbId, suffix) {
        if (!thisCbId || !parentCbId || !suffix) return;

        var editform = document.getElementById(EditPageConstants.pEDIT_PAGE);
        var thisCb = document.getElementById(thisCbId);
        var parentCb = document.getElementById(parentCbId);

        if (editform && thisCb && parentCb) {
            // init values as necessary
            if (!SearchSettingsPage.isCountInitialized(suffix)) {
                SearchSettingsPage.initCounts(parentCb, suffix);
            } else {
                if (thisCb.checked) {
                    SearchSettingsPage.currentCounts[suffix] += 1;
                } else {
                    SearchSettingsPage.currentCounts[suffix] -= 1;
                }
            }
            // if change reaffirms current parent checkbox state, don't need to do anything else
            if (thisCb.checked != parentCb.checked) {
                // if I unchecked a box, but the parent is still checked, clear parent checkbox.
                if (!thisCb.checked) {
                    parentCb.checked = false;
                } else if(SearchSettingsPage.isAllChecked(suffix)) {
                    parentCb.checked = true;
                }
            }
        }
    },

    getCurCount : function(suffix) {
        var curcount = SearchSettingsPage.currentCounts[suffix];
        // Not found in hash;
        if (!curcount && (curcount !== 0)) return -1;
        return curcount;
    },

    getTotalCount : function(suffix) {
        var curcount = SearchSettingsPage.totalCounts[suffix];
        // Not found in hash;
        if (!curcount && (curcount !== 0)) return -1;
        return curcount;
    },

    isCountInitialized : function(suffix) {
        return ((SearchSettingsPage.getCurCount(suffix) != -1) && (SearchSettingsPage.getTotalCount(suffix) != -1));
    },

    initCounts : function(parentCbRef, suffix) {
        var editform = document.getElementById(EditPageConstants.pEDIT_PAGE);

        var totalCount=0;
        var checkedCount=0;
        for (var i=0; i < editform.elements.length; i++) {
            var elem = editform.elements[i];
            if (elem && (elem != parentCbRef) && elem.id && (elem.type == 'checkbox')) {
                var ind = elem.id.indexOf(suffix);
                if ((ind >= 0) && ((ind + suffix.length) == elem.id.length)) {
                    totalCount++;
                    if (elem.checked) checkedCount++;
                }
            }
        }

        SearchSettingsPage.totalCounts[suffix] = totalCount;
        SearchSettingsPage.currentCounts[suffix] = checkedCount;
    },

    isAllChecked : function(suffix) {
        return SearchSettingsPage.getCurCount(suffix) == SearchSettingsPage.getTotalCount(suffix);
    },
    
    toggleDefaultEntitySection : function() {
    	var parentCb = document.getElementById(SearchSettingsConstants['SIDEBAR_SEARCH_ENTITY_PICKER_ID']);
        var searchDefaultSettings = document.getElementById(SearchSettingsConstants['DEFAULT_SEARCH_ENTITY_CHECKBOX_ID']);
        
        if (parentCb && searchDefaultSettings) {
        	searchDefaultSettings.disabled = !parentCb.checked;
        	SearchSettingsPage.toggleDefaultEntityPicker();
        }
    },
    
    toggleDefaultEntityPicker : function() {
    	var checkbox = document.getElementById(SearchSettingsConstants['DEFAULT_SEARCH_ENTITY_CHECKBOX_ID']);
    	var picklist = document.getElementById(SearchSettingsConstants['DEFAULT_SEARCH_ENTITY_PICKLIST_ID']);
    	
    	if (checkbox && picklist) {
			picklist.disabled = !checkbox.checked || checkbox.disabled;
    	}
    }
}

/*
* @author axing
* @since 148
*/
function ApexPage() {}

ApexPage.prototype = new GenericSfdcPage();

/**
 * A simple overlay screen for displaying a loading/saving method during ajax calls.
 * Currently used in check syntax links for S-Controls and Validation rules, as
 * well as for tag headers on detail pages during saving.
 *
 * @author agusev, emoses, jbergan 
 */
function LoadingScreen(theDiv, waitingText, id){
    this.div = theDiv;
    this.text = waitingText;
    this.id = id;
}

LoadingScreen.prototype = {
    show : function() {
        if (!this.transparantElement){
            //Lazily create the div.
            this.createElements();
        }
        this.transparantElement.style.display = 'block';
        this.opaqueElement.style.display = 'block';
    },

    hide : function() {
        if (this.transparantElement) {
            this.transparantElement.style.display = 'none';
            this.opaqueElement.style.display = 'none';
        }
    },

    createElements : function() {
        // During construction in Safari, this is undefined, so it has
        // to be checked when show() is called.
        if (XBrowser.getCurrentStyle(this.div, "position") == "static"){
            this.div.style.position = 'relative';
        }

        // We have one overlay that is partially transparant, and one
        // that is not, so that the description will be opaque.
        this.transparantElement = this.createLoadingElement(this.div);
        this.transparantElement.className = 'waitingSearchDiv waitingSearchDivOpacity';
        this.opaqueElement = this.createLoadingElement(this.div);
        this.opaqueElement.className = 'waitingSearchDiv';
		if (this.id) {
	        this.opaqueElement.id = this.id;
		}

        // The loading description must be on a non-transparant div
        // because otherwise it will have the same opacity as the overlay,
        // and it doesn't look right to have semi-transparant text over text.
        this.addLoadingDescription(this.text, this.opaqueElement);
    },

    createLoadingElement : function(element) {
        var loading = document.createElement('div');

        // 100% is ideal, if it works, since it handles resizing correctly
        // and excludes the border of the element.
        loading.style.width = '100%';
        loading.style.height = '100%';
        if (XBrowser.userAgent.isIE) {
            // IE defaults to left being further left (-5 or so)
            loading.style.left = 0;
            // IE doesn't properly draw '100%' for height on the first try.
            loading.style.height = this.div.clientHeight + "px";
        }

        // Appending the overlay last helps work out the sizing done above
        element.appendChild(loading);
        return loading;
    },

    addLoadingDescription : function(description, element) {
        // On IE, a span ends up showing as two separate sections
        // (img and text) in some contexts.
        var newWaitingHolder = document.createElement('div');
        element.appendChild(newWaitingHolder);
        newWaitingHolder.className = 'waitingHolder';
        var limitedOffset = (element.offsetHeight)/5;
        if (limitedOffset > 100) {
            limitedOffset = 100;
        }
        newWaitingHolder.style.top =  limitedOffset + "px";

        var newWaitingImage = document.createElement('img');
        newWaitingHolder.appendChild(newWaitingImage);
        newWaitingImage.src = '/img/loading.gif';
        newWaitingImage.className  = 'waitingImage';

        var newWaitingDescription = document.createElement('span');
        newWaitingHolder.appendChild(newWaitingDescription);
        newWaitingDescription.innerHTML =  description;
        newWaitingDescription.className  = 'waitingDescription';

        // This is a bit kludgy, but given the variety of widths this is used in,
        // a straight percentage (as in the css) doesn't work.  Also, the extra 20
        // is for safari, which otherwise ends up with too small a value for some reason.
        newWaitingHolder.style.width = (newWaitingImage.offsetWidth + newWaitingDescription.offsetWidth + 20) + "px";
        return newWaitingHolder;
    }
}
/**
 * Simplified version of hash map
 * undefined value is not allowed, null or undefined key is not allowed
 * feel free to enhance it
 */
function Map() {
	this.size = 0;
	this.map = new Object();
}

Map.prototype.put = function (key, val) {
	// key not null or undefined, value is not undefined
	if (!key || typeof(val) == 'undefined' ) {
		return;
	}
	if (!(key in this.map)) {
		this.size++;
	}
	this.map[key] = val;
}

Map.prototype.remove = function (key) {
	if (key in this.map) {
		delete(this.map[key]);
		this.size--;
	}
}


SearchHistory.LIST_URL = 'listUrl';
SearchHistory.ACTION_URL = 'actionUrl';
SearchHistory.LIST_QS = 'listQS';
SearchHistory.LIST_ID = 'listId';

function SearchHistory() {
	
	this.actionUrl = null;
	this.listUrl = null;
	this.listQs = null;
	this.listId = null;
}
SearchHistory.prototype.readFromQs = function (queryString){
	this.actionUrl = SearchPage.prototype.decodeForSearch(queryString.get(SearchHistory.ACTION_URL));
	this.listUrl = SearchPage.prototype.decodeForSearch(queryString.get(SearchHistory.LIST_URL));
	this.listQs = SearchPage.prototype.decodeForSearch(queryString.get(SearchHistory.LIST_QS));
	this.listId = SearchPage.prototype.decodeForSearch(queryString.get(SearchHistory.LIST_ID));
}
	
//setters
SearchHistory.prototype.setActionUrl = function (newActionUrl) {
	this.actionUrl = newActionUrl;
}

SearchHistory.prototype.setListUrl  = function (newListUrl) {
	this.listUrl = newListUrl;
}

SearchHistory.prototype.setListQs = function (newListQs) {
	this.listQs = newListQs;
}

SearchHistory.prototype.setListId =  function (newListId) {
	this.listId = newListId;
}

//getters
SearchHistory.prototype.getActionUrl = function () {
	return this.actionUrl;
}

SearchHistory.prototype.getListUrl = function () {
	return this.listUrl;
}

SearchHistory.prototype.getListQs =  function () {
	return this.listQs;
}

SearchHistory.prototype.getListId =  function () {
	return this.listId;
}

SearchHistory.prototype.toString = function () {
	
	var qs = new QueryString("");
	if(this.actionUrl && this.actionUrl.length > 0){
		qs.add(SearchHistory.ACTION_URL, SearchPage.prototype.encodeForSearch(this.actionUrl));
	}
	if(this.listUrl && this.listUrl.length > 0) {
		qs.add(SearchHistory.LIST_URL, SearchPage.prototype.encodeForSearch(this.listUrl));
	}
	if(this.listQs && this.listQs.length > 0) {
		qs.add(SearchHistory.LIST_QS, SearchPage.prototype.encodeForSearch(this.listQs));
	}
	if(this.listId && this.listId.length > 0){
		qs.add(SearchHistory.LIST_ID, SearchPage.prototype.encodeForSearch(this.listId));
	}
	var historyDescriptor = qs.toString();
	return historyDescriptor.substring(1, historyDescriptor.length);
	
}
function Scontrol() {}

Scontrol.prototype.getSelectedRecordIdsFromForm = function(form, keyPrefix) {
	var selected = [];

	// Get the values directly from the form
	if (form) {
		// Find selected rows with matching key prefix
	    for (i = 0; i < form.elements.length; i++) {
	    	var element = form.elements[i];
	        if ((element.name == "ids") && element.checked) {
	        	var value = element.value;
	        	if (value.substr(0, 3) == keyPrefix) {
					selected.push(value);
				}
	        }
	    }		
	} else {
		alert('Unable to find a form for this button');
	}
			
	return selected;
}
var FilterLookupPage = function(){}

FilterLookupPage.prototype.checked = new Array();

FilterLookupPage.prototype.checkAll = function(val)
{
  for(var i = 0; ; i++)
  {
    var chkbox = document.getElementById("chkbox"+i);
    if (!chkbox) break;
    chkbox.checked = val;
    FilterLookupPage.prototype.checked[i] = (val ? chkbox.value : null);
  }
}

//For boolean fields, we replace the filter value. For enums, we append 
FilterLookupPage.prototype.transfer = function(isBooleanField)
{
    var valueElem = opener.document.getElementById(opener.filterLookupValueElem);
    var string = valueElem.value;
    //Thanks chops!
    if (isBooleanField){
    	if (document.getElementById('chkbox0').checked){
    		string = document.getElementById('chkbox0').value;
    	} else if (document.getElementById('chkbox1').checked){ 
    		string = document.getElementById('chkbox1').value;
    	}
	} else {
        for(var i in FilterLookupPage.prototype.checked) {
            var value = FilterLookupPage.prototype.checked[i];
            if (value != null) {
    		    if (string.length > 0) {
    		        string = string + ", ";
    		    }
    		    if (value.indexOf(",") >= 0) {
    		        value = "\"" + value + "\"";
    		    }
    		    string = string + value;
    		}
    	}
    	if (string.length > valueElem.maxLength){
    		string = string.substring(0,valueElem.maxLength);
    	}
	}
    valueElem.value = string;
	self.close();
	return false;
}

FilterLookupPage.prototype.doCheckbox = function(i) {
    var chkbox = document.getElementById("chkbox"+i);
    if (chkbox.checked) {
        FilterLookupPage.prototype.checked[i] = chkbox.value;
    } else {
        FilterLookupPage.prototype.checked[i] = null;
    }
}

FilterLookupPage.prototype.initBoolean = function() {
	for (i = 0; i < 2; i++){
    	var chkbox = document.getElementById("chkbox"+i);
		chkbox.checked = chkbox.value == opener.document.getElementById(opener.filterLookupValueElem).value;
	}
}
    
function EncryptedTextInputElement(id, maxLength, isMasked){
	if (!isMasked) return;
	this.maxLength = maxLength;
	this.element = getElementByIdCS(id);
	if (!this.element) return;
	
	this.wasCleared = false;
	this.origValue = this.element.value;
	
	var self = this;
	
	this.handleOnFocus = function(e){
		if (self.wasCleared){
			return;
		}
		self.element.select();
	}
	
	this.handleKey = function(e){
		if (!self.wasCleared){
			var code = getEvent(e).keyCode;
			if (!(code === KEY_ENTER || code === KEY_TAB || code === KEY_PAGEUP || code === KEY_PAGEDOWN)){
				self.element.value = "";
				self.element.maxLength = self.maxLength;
				self.wasCleared = true;
			}
		}
	}
	
	this.handleBlur = function(e){
		if (self.element.value === self.origValue){
			self.wasCleared = false;
		}
	}
	
	addEvent(this.element, 'focus', this.handleOnFocus, true);
	addEvent(this.element, 'blur', this.handleBlur, true)
	addEvent(this.element, 'keypress', this.handleKey, true);
}
/**
  This is used to retrieve labels

  @author polcari
  @since 144
*/

function LC() {}

/* This function name is referenced in the dynamicJSLibrary. */
LC.getLabel = function() {
  var retVal = '';
  var args = this.getLabel.arguments;
  if (args[0] && args[1]) {
    retVal = LC.labels[args[0]][args[1]];
  }
  for (i = 2; i < args.length; i++) {  
    //substitutions are done client-side.
    var regexp = new RegExp('\\{'+(i - 2)+'\\}', 'g');
    retVal = retVal.replace(regexp, args[i]);
  }
  return retVal;
}

/*
 * maybe pull a list of  ISO 639 and ISO 3166 codes here?
 */
LC.isEnglishLanguage = function() {
    return UserContext.initialized && UserContext.language == "en_US";
}

LC.isUSLocale = function() {
    return UserContext.initialized && UserContext.locale == "en_US";
}

LC.isEnglishUS = function() {
    return LC.isEnglishLanguage() && LC.isUSLocale();
}

/**
 * XBrowser is a singleton object for all cross-browser utility functions.
 *
 * @author mooney
 * @since 146
 */
var XBrowser = {
    /* simple user agent parsing, use object detection in most cases */
    userAgent : {
        isIE : navigator.userAgent.indexOf("MSIE") != -1,
        isIE6 : navigator.userAgent.indexOf("MSIE 6") != -1,
        isIE7 : navigator.userAgent.indexOf("MSIE 7") != -1,
        isOpera : navigator.userAgent.indexOf("Opera") != -1,
        isSafari : navigator.userAgent.indexOf("AppleWebKit") != -1,
        isFirefox : navigator.userAgent.indexOf("Firefox/") != -1,
        isNetscape : navigator.userAgent.indexOf("Netscape/") != -1
    },

    /**
     * transforms CSS property names from IE format to Mozilla/Opera format
     * i.e. XBrowser.dashify("fontColor") == "font-color"
     */
    dashify : function(str){
        return str.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
    },

    /**
     * Retrieves the current state for a style property
     */
    getCurrentStyle : function(element, styleProp) {
        if (element.currentStyle) {
            //IE
            return element.currentStyle[styleProp];
        } else if (document.defaultView && document.defaultView.getComputedStyle) {
            //Mozilla & Opera
            return document.defaultView.getComputedStyle(element, null).getPropertyValue(XBrowser.dashify(styleProp));
        }
        // Safari :(
        return null;
    },
    
    /**
     * Retreive the CSS style as set on the element with the 'style' HTML attribute.
     * NOTE: This is different from computed style, which usually is not all defined on the
     * element and is inherited from css classes etc.
     * See getCurrentStyle for getting computed style.
     */
    getElementStyle : function(element, styleProp) {
        if (element.currentStyle) { // IE
            return element.currentStyle[styleProp];
        } else if (element.style.getPropertyValue) { // DOM
            return element.style.getPropertyValue(styleProp);
        }
        return null;
    },

    /**
     * Get the actual height of the element in pixels. Uses offsetHeight and corrects for the padding.
     * NOTE: if the padding is not set in pixels will just return offsetHeight.
     * @param useScrollHeight if set to true, use scrollHeight instead of offsetHeight for height calculation
     */
    getActualHeight : function(/*DOMElement*/ element, /* boolean */ useScrollHeight) {
        var regex = /.*px$/;
        var height = useScrollHeight ? element.scrollHeight : element.offsetHeight;
        var paddingTop = XBrowser.getCurrentStyle(element, 'paddingTop');
        var paddingBottom = XBrowser.getCurrentStyle(element, 'paddingBottom');

        if ((!regex.exec(paddingTop)) || (!regex.exec(paddingBottom))) { // can only handle px padding
            return height;
        }
        paddingTop = paddingTop.substring(0, paddingTop.length - 2);
        paddingBottom = paddingBottom.substring(0, paddingBottom.length - 2);
        return height - paddingTop - paddingBottom;
    },

    /**
     * Creats a new XMLHttpRequest and returns it.
     */
    createHttpRequest : function() {
        if (window.XMLHttpRequest) {
            return new XMLHttpRequest();
        } else if (window.ActiveXObject) {
            try {
                return new ActiveXObject("Msxml2.XMLHTTP");
            } catch (e) {
                try {
                    return new ActiveXObject("Microsoft.XMLHTTP");
                } catch (e) {
                }
            }
        }
        return null;
    },

    /**
     * Convenience method which opens an XMLHttpRequest to the specified page, then passes the
     * result to the specified function, or to the specified error handler if an HTTP error occurs
     * 
     * @param url URL to make the request to [String]
     * @param handler Callback to execute after the request returns success [function(request)]
     * @param errorHandler Callback to execute if the request return failure [optional, function(request)]
     * @param method HTTP method to call (GET, POST, PUT, DELETE) [optional, String, default: "GET"]
     * @param body The body of the request [optional, String]
     */
    getHttpResponse : function(url, handler, /* optional */ errorHandler, /*optional*/ method, /*optional*/ body) {
        var request = XBrowser.createHttpRequest();
        var theMethod = method || "GET";
        request.open(theMethod, url, true);
        request.onreadystatechange = function() {
            if (request.readyState == 4) {
                if (request.status == 200) {
                    handler(request);
                } else if (errorHandler) {
                    errorHandler(request);
                }
            }
        };
        if (body && method == "POST"){
            request.setRequestHeader('Content-Type','application/x-www-form-urlencoded; charset=ISO-8859-13');
        }
        request.send(body);
        
        return request;
    },

    /**
     * Convenience method to execute a POST XmlHttpRequest
     * 
     * @param url URL to make the request to [String]
     * @param handler Callback to execute after the request returns success [function(request)]
     * @param postBody The body of the request [optional, String]
     * @param errorHandler Callback to execute if the request return failure [optional, function(request)]
     */    
    postHttpResponse : function(url, handler, postBody, /*optional*/ errorHandler) {
        return XBrowser.getHttpResponse(url, handler, errorHandler, "POST", postBody);
    },
    
    /**
     * Build a post-style request from a JS Object.  ex: { a: "b", c: "2" } -> "a=b&c=2"
     * @throws URIError from ecodeURIComponent
     */
    buildPost : function(map){
        var arr = [];
        var first = true;
        for (var key in map){
            if (!first){
                arr.push("&");
            }
            first = false;
            if (map[key] instanceof Array) {
                var valueArray = map[key]; 
                if (valueArray.length == 0) {
                    arr.push(key);
                    arr.push("=");
                } else {
                    for (var i = 0; i < valueArray.length; i++) {
                        if (i > 0) {
                            arr.push("&");
                        }
                        arr.push(key);
                        arr.push("=");
                        arr.push(encodeURIComponent(valueArray[i]));
                    }
                }
            } else {
                arr.push(key);
                arr.push("=");
                arr.push(encodeURIComponent(map[key]));
            }
        }
        return arr.join("");
    },

    /**
     * Convenience method to retrieve a script at url and execute it, calling handler after the script has been run.
     * 
     * @param url the url of the script to run
     * @param handler function reference to be called once the script has been loaded
     */
    createDynamicScript : function(url, handler) {
        var script = document.createElement("script");
        if (handler) {
            if (window.ActiveXObject) {
                /* IE uses onreadystatechanged, when loading from the server it fires twice with
                 * readyState values of "loading" and then "loaded", but when loading from the
                 * cache it only fires once with a readyState of "complete"
                 */
                script.onreadystatechange = function() {
                    if (this.readyState == "complete" || this.readyState == "loaded") {
                        handler();
                    }
                };
            } else {
                script.onload = handler;
            }
        }
        script.type = "text/javascript"
        script.src = url;
        document.body.appendChild(script);
    },

    // fix for IE6 CSS background image cache bug (#98786)
    turnOnBackgroundImageCache : function() {
        try {
            document.execCommand("BackgroundImageCache", false, true);
        } catch (error) {
            // not in IE6
        }
    }

};

/**
 * add the Node interface to IE
 */
if (!window.Node) {
    var Node = {
		ELEMENT_NODE : 1,
		ATTRIBUTE_NODE : 2,
		TEXT_NODE : 3,
		CDATA_SECTION_NODE : 4,
		ENTITY_REFERENCE_NODE : 5,
		ENTITY_NODE : 6,
		PROCESSING_INSTRUCTION_NODE : 7,
		COMMENT_NODE : 8,
		DOCUMENT_NODE : 9,
		DOCUMENT_TYPE_NODE : 10,
		DOCUMENT_FRAGMENT_NODE : 11,
		NOTATION_NODE : 12
    };
}

/*
 * @author ldelascurain
 * @since 150
 *
 */

function FieldTreeController( container, rootNodeList, elementName, insertCurlyBangDelims, afterInsertCallback, formulaType, servletUrl){

    this.tree = new FieldTree( rootNodeList, formulaType, servletUrl);
    this.selects = [document.getElementById(FieldTreeConstants.SELECT_ID + "0")];
    this.elementName = elementName;
    this.insertCurlyBangDelims = insertCurlyBangDelims;
    this.container = container;
    this.afterInsertCallback = afterInsertCallback;
    
    var depthRE = /(\d+)$/;

    var self = this;

    this.handleSelectClick = function(e){
        var target = getEventTarget(getEvent(e));
        var match = depthRE.exec(target.name);
        if (!match){
            return;
        }
        var selectDepth = parseInt(match[1]);
        var selectedKey = target.options[target.selectedIndex].value;

        self.moveSelectionTo(selectDepth, selectedKey);
    }

    addEvent(this.container.firstChild.firstChild, 'change', this.handleSelectClick, false);
    this.hideSelects();
};

FieldTreeController.prototype.setScrollDiv = function(div){
	this.scrollDiv = div;
};

FieldTreeController.prototype.ajaxRefreshNode = function(refreshedNode){
	if (refreshedNode === this.tree.currentNode){
		this.eraseSelects(this.tree.currentDepth);
		this.buildSelect(refreshedNode.children, this.tree.currentDepth);
		this.scrollRight();
	}
};

FieldTreeController.prototype.moveSelectionTo = function(selectDepth, selectedKey){
    //TODO:  fix for change to "none"
    if (!selectedKey){
        return;
    }

    if (selectDepth < this.tree.currentDepth){
        this.tree.ascend(selectDepth);
    }

    var selectedNode = this.tree.getNodeFromCurrentList(selectedKey);

    if (!(selectedNode.isLeaf)){
    	var self = this;
        this.buildSelect(this.tree.getChildren(selectedNode, function(refreshedNode) {self.ajaxRefreshNode(refreshedNode);}), selectDepth + 1);
        this.tree.descend(selectedNode.key);
   	    this.scrollRight();
    }
    else {
        // Add the Insert code
        var insertString = selectedNode.getLabelToInsert();
        var extraAttributes = selectedNode.getExtraAttributes();
        this.buildInsert(insertString, selectDepth + 1, extraAttributes);
   	    this.scrollRight();
    }
}

FieldTreeController.prototype.focusTop = function(){
    var topSelect = this.selects[0];
    if(topSelect){
        topSelect.focus();
    }
}

FieldTreeController.prototype.reset = function(){
    this.tree.ascend(0);
    this.selects = [document.getElementById(FieldTreeConstants.SELECT_ID + "0")];

    var topSelect = this.selects[0];
    if (topSelect.options.length > 0){
        topSelect.selectedIndex = 0;
        this.moveSelectionTo(0, topSelect.options[0].value);
    }
}

FieldTreeController.prototype.buildSelect = function( nodeList, index ){

    var map = [];
    for(var i=0;i<nodeList.length;i++){
        var nodeLabel = nodeList[i].isLeaf ? nodeList[i].labelName : (nodeList[i].labelName + " &gt;");
        map[i] = [nodeLabel, nodeList[i].key];
    }

    this.eraseSelects(index);

    var attributeMap = {"size":"9", "name":FieldTreeConstants.SELECT_ID + this.selects.length, "class":"fieldTreeSelect"};
    var selectHTML = Util.createDynamicSelect(attributeMap, map, false);

    var wrapper = document.createElement("TD");
    wrapper.id = "selectWrapper" + this.selects.length;
    wrapper.className = "selectWrapper";
    this.container.appendChild(wrapper);
    wrapper.innerHTML = selectHTML;
    wrapper.isDynamicSelect = true;
    this.selects.push(wrapper.firstChild);


    addEvent(this.selects[index], 'change', this.handleSelectClick, false);
}

FieldTreeController.prototype.buildInsert = function( insertString, index, extraAttributes ){
    var insertInfoHTML = LC.getLabel("NewFormulaEditor", "SelectedInfo");
    var insertText = LC.getLabel("Buttons", "ins");
    var insertStringHTML = insertString;
    var insertButtonHTML = "<input type='button' id='fieldInsertButton' name='insertButton' class='btn' value='" + insertText + "' />";
    var self = this;

    if (this.selects[index]) {
        this.eraseSelects(index);
    }
    var insertBox = document.createElement("TD");
    this.container.appendChild(insertBox);
    insertBox.id = "insertBox";

    var wrapper = document.createElement("SPAN");
    wrapper.id = "insertWrapperInfo" + this.selects.length;
    insertBox.appendChild(wrapper);
    wrapper.innerHTML = insertInfoHTML;
    wrapper.isDynamicSelect = false;
    wrapper.className = "insertWrapperInfo";

    wrapper = document.createElement("SPAN");
    wrapper.id = "insertWrapperString" + this.selects.length;
    insertBox.appendChild(wrapper);
    wrapper.innerHTML = insertStringHTML;
    wrapper.isDynamicSelect = true;
    wrapper.className = "insertWrapperString";

    this.selects.push(wrapper.firstChild);

    wrapper = document.createElement("SPAN");
    wrapper.id = "insertWrapperAttributes" + this.selects.length;
    insertBox.appendChild(wrapper);
    wrapper.innerHTML = extraAttributes;
    wrapper.isDynamicSelect = false;
    wrapper.className = "insertWrapperAttributes";

    wrapper = document.createElement("SPAN");
    wrapper.id = "insertWrapperButton" + this.selects.length;
    insertBox.appendChild(wrapper);
    wrapper.innerHTML = insertButtonHTML;
    wrapper.isDynamicSelect = false;
    wrapper.className = "insertWrapperButton";

    addEvent(document.getElementById("fieldInsertButton"), "click", function(){self.insertCode(self.elementName, insertString, self.insertCurlyBangDelims);}, false);

}

FieldTreeController.prototype.eraseSelects = function(index){
    var i = this.selects.length;
    while (i > index ){
        i--;
        var element = this.selects[i].parentNode;
        while (element.nodeName != "TD"){
            element = element.parentNode;
        }
        this.container.removeChild(element);
        this.selects.pop();
    }
}

FieldTreeController.prototype.insertCode = function(elementName, insertString, insertCurlyBangDelims){
    FormulaEditor.insertCode( elementName, insertString, insertCurlyBangDelims);
    if (this.afterInsertCallback){
        this.afterInsertCallback();
    }
}

FieldTreeController.prototype.scrollRight = function(){
	var container = this.scrollDiv || this.container;
	if (container.clientWidth == 0){
		//IE fix
		container = container.parentNode;
	}
    container.scrollLeft = container.scrollWidth - container.clientWidth;
}

FieldTreeController.prototype.showSelects = function(){
    for (var i=0; i< this.selects.length; i++ ){
        this.selects[i].style.display = "inline";
    }
}

FieldTreeController.prototype.hideSelects = function(){
    for (var i=0; i< this.selects.length; i++ ){
        var element = this.selects[i];
        if (element!=null && element.nodeName == "SELECT"){
            element.style.display = "none";
        }
    }
}

/**
 * Javascript object and controls for the inline date picker
 * @author jmooney
 * @since 148
 */
function DatePicker() {
    this.today = DateUtil.getDateTimeFromUserLocale(UserContext.today);
    this.calendarDiv = document.getElementById(DatePickerIds.DOM_ID);
    this.shim = new iframeShim(this.calendarDiv);
    this.table = document.getElementById(DatePickerIds.TABLE_ID);
    this.monthPicker = document.getElementById(DatePickerIds.MONTH_PICKER);
    this.yearPicker = document.getElementById(DatePickerIds.YEAR_PICKER);
    this.callOnChange = false;
    this.myField = null;
    this.myElement = null;
    this.currentDate = null;
    this.hasTime = false;
    this.addedFields = {};
    var self = this;
    addEvent(document, "click", function() { self.hide(); }, false);
    addEvent(this.calendarDiv, "click", function(e) { self.cancelHide(e); }, false);
    addEvent(this.monthPicker, "change", function() { self.generateMonth(); }, false);
    addEvent(this.yearPicker, "change", function() { self.generateMonth(); }, false);
}

/**
 * sets the month and year to the passed in date. If the year is not in the dropdown already
 * it will add it in the correct place.
 */
DatePicker.prototype.setMyDate = function(date) {
    var found = false;
    for (var i = 0; i < this.yearPicker.options.length; i++) {
        var year = parseInt(this.yearPicker[i].value);
        if (year > date.getFullYear()) {
            // need to insert the year
            Util.insertOption(this.yearPicker, new Option(date.getFullYear(), date.getFullYear(), false, true), i);
            found = true;
            break;
        } else if (parseInt(this.yearPicker[i].value) == date.getFullYear()) {
            // found it
            this.yearPicker.selectedIndex = i;
            found = true;
            break;
        }
    }
    if (!found) {
        // need to insert the year at the end
        this.yearPicker.options[this.yearPicker.options.length] = new Option(date.getFullYear(), date.getFullYear(), false, true);
    }

    this.monthPicker.selectedIndex = date.getMonth();
}

/**
 * view the previous month
 */
DatePicker.prototype.prevMonth = function() {
    if (this.monthPicker.selectedIndex == 0) {
        var prevYear = parseInt(this.yearPicker[this.yearPicker.selectedIndex].value) - 1;
        if (this.yearPicker.selectedIndex == 0 || prevYear != this.yearPicker[this.yearPicker.selectedIndex - 1].value) {
            var d = new Date();
            d.setFullYear(prevYear);
            d.setMonth(11);
            this.setMyDate(d);
        } else {
            this.yearPicker.selectedIndex--;
            this.monthPicker.selectedIndex = 11;
        }
    } else {
        this.monthPicker.selectedIndex--;
    }
    this.generateMonth();
}

/**
 * view the next month
 */
DatePicker.prototype.nextMonth = function() {
    if (this.monthPicker.selectedIndex == 11) {
        var nextYear = parseInt(this.yearPicker[this.yearPicker.selectedIndex].value) + 1;
        if (this.yearPicker.selectedIndex == this.yearPicker.length - 1 || nextYear != this.yearPicker[this.yearPicker.selectedIndex + 1].value) {
            var d = new Date();
            d.setFullYear(nextYear);
            d.setMonth(0);
            this.setMyDate(d);
        } else {
             this.yearPicker.selectedIndex++;
             this.monthPicker.selectedIndex = 0;
        }
    } else {
        this.monthPicker.selectedIndex++;
    }
    this.generateMonth();
}

/**
 * generates the days for the current selected month.
 */
DatePicker.prototype.generateMonth = function() {
    var month = parseInt(this.monthPicker[this.monthPicker.selectedIndex].value);
    var d = new Date();
    d.setDate(1);
    var year = parseInt(this.yearPicker[this.yearPicker.selectedIndex].value);
    d.setFullYear(year);
    d.setMonth(month);
    // java days are indexed from 1-7, javascript 0-6
    var startPoint = UserContext.startOfWeek - d.getDay();
    if (startPoint > 1) startPoint -= 7;
    d.setDate(startPoint);
    document.getElementById("calRow5").style.display = "";
    document.getElementById("calRow6").style.display = "";
    var dayCells = this.table.getElementsByTagName("td");
    for (var i = 0; i < dayCells.length; i++) {
        var dayOfWeek = d.getDay();
        var week = i / 7;
        var clazz;
        if (dayOfWeek == 0 || dayOfWeek == 6) {
            clazz = "weekend";
        } else {
            clazz = "weekday";
        }
        if (d.getMonth() == month - 1 || d.getFullYear() == year - 1) {
            clazz += " prevMonth"
        } else if (d.getMonth() == month + 1 || d.getFullYear() == year + 1) {
            if (i % 7 == 0) {
                // done, hide the remaining rows.
                document.getElementById("calRow6").style.display = "none";
                if (i / 7 == 4) {
                     document.getElementById("calRow5").style.display = "none";
                }
                break;
            }
            clazz += " nextMonth"
        }
        if (DateUtil.equals(d, this.today)) {
            clazz += " todayDate";
        }
        if (DateUtil.equals(d, this.currentDate)) {
            clazz += " selectedDate"
        }
        dayCells[i].className = clazz;
        dayCells[i].innerHTML = d.getDate();
        d.setDate(d.getDate() + 1);
    }
}

DatePicker.prototype.selectDate = function(value) {
    var selectedDate;
    if ("today" == value) {
        this.currentDate = this.today;
        selectedDate = this.hasTime ? DateUtil.getDateTimeStringFromUserLocale(this.today) : DateUtil.getDateStringFromUserLocale(this.today);
        this.setMyDate(this.today);
        this.generateMonth();
    } else {
        var d = new Date(this.today.getTime());
        // set the date to the 1st to avoid month wrapping
        d.setDate(1);
        d.setFullYear(parseInt(this.yearPicker[this.yearPicker.selectedIndex].value));
        var month = parseInt(this.monthPicker[this.monthPicker.selectedIndex].value);
        if (value.className.indexOf("nextMonth") != -1) {
            month++;
        } else if (value.className.indexOf("prevMonth") != -1) {
            month--;
        }
        d.setMonth(month);
        d.setDate(value.innerHTML);
        selectedDate = this.hasTime ? DateUtil.getDateTimeStringFromUserLocale(d) : DateUtil.getDateStringFromUserLocale(d);
        this.hide();
    }
    DatePicker.insertDate(selectedDate, this.myField.id, this.callOnChange);
}

DatePicker.prototype.position = function() {
    // have to position the calendar relative to its relatively positioned parent (the body div)
    var x = 0;
    var y = 0;
    var element = this.myElement;
    while (element != null && element != this.calendarDiv.offsetParent) {
        x += element.offsetLeft;
        y += element.offsetTop;
        element = element.offsetParent;
    }
    // to check the picker isn't off the bottom of the page we need to calculate the position relative to the top of the page
    if (getObjY(this.myElement) + this.calendarDiv.offsetHeight > getScrollY() + getWindowHeight()) {
        y -= this.calendarDiv.offsetHeight;
    } else {
        y += this.myElement.offsetHeight;
    }
    this.shim.setStyle("left", x + "px");
    this.shim.setStyle("top", y + "px");
}

DatePicker.prototype.show = function(callOnChange, myField, hasTime, myElement) {
    this.callOnChange = callOnChange;
    this.hasTime = hasTime;
    this.myField = getElementByIdCS(myField);
	if (myElement)
    	this.myElement = myElement;
	else
		this.myElement = getElementByIdCS(myField);
    var self = this;
    if (this.myField.type != "hidden") {
        if (this.addedFields[myField] !== this.myField) {
            // gotta detect if field was deleted and replaced by a new one but still has the same dom id
            // remove the reference to the deleted field and re-add the events.
            this.addedFields[myField] = null;
        }
        if (!this.addedFields[myField]) {
            this.addedFields[myField] = this.myField;
            addEvent(this.myField, "click", function(e) { self.cancelHide(e); }, false);
            addEvent(this.myField, "keydown", function(e) { self.handleKeyPress(e); }, false);
            if (!hasTime && LC.isEnglishLanguage()) {
				var blurHandler;
            	if (LC.isEnglishUS()) {
            		blurHandler = function() { DateUtil.checkYear(self.myField, self.callOnChange); };
            	} else {
            		blurHandler = function() { DateUtil.evaluateShortcut(self.myField, self.callOnChange); };
            	}
                addEvent(this.myField, "blur", blurHandler, false);
            }
        }
    }

    // try to parse the date in the field, with or without time
    var time = hasTime ? DateUtil.getDateFromFormat(this.myField.value, UserContext.dateTimeFormat) :
                         DateUtil.getDateFromFormat(this.myField.value, UserContext.dateFormat);
    if (time != 0) {
        // parse successful
        this.currentDate = new Date(time);
        this.setMyDate(this.currentDate);
    } else {
        // couldn't parse, use today's date
        this.setMyDate(this.today);
    }
    this.generateMonth();

    this.shim.setStyle("display", "block");
    this.position();
}

DatePicker.prototype.cancelHide = function(e) {
    eventCancelBubble(e);
    return false;
}

DatePicker.prototype.handleKeyPress = function(e) {
    var key = getEvent(e).keyCode;
    if (key == KEY_ESC || key == KEY_TAB) {
        this.hide();
    } else if (key == KEY_ENTER && !this.hasTime) {
    	if (LC.isEnglishUS()) {
    		DateUtil.checkYear(this.myField);
    	} else if (LC.isEnglishLanguage()) {
	        DateUtil.evaluateShortcut(this.myField);
    	}
    }
}

DatePicker.prototype.hide = function() {
    this.shim.setStyle("display", "none");
}
// static date picker object, lazily create 1 per page
DatePicker.datePicker = null;

DatePicker.pickDate = function(callOnChange, field, hasTime, element) {
    if (!DatePicker.datePicker) {
    	DatePicker.datePicker = new DatePicker();
    }
    DatePicker.datePicker.show(callOnChange, field, hasTime, element);
}

DatePicker.insertDate = function(value, field, callOnChange) {
    var element = getElementByIdCS(field);
    if (!element.disabled && element.value != value) {
        element.value = value;
        if (callOnChange && element.onchange) {
            element.onchange();
        }
    }
}



var Captcha = {
    formName : "",
    submitButtonName : "",
    publicKey : "",
    recaptchaLang : "",
    
    dialog : null,
    
    verified : false,

    // called when you click on the captcha button
    click : function(formName, submitButtonName, publicKey, helpHref, recaptchaLang) {
        Captcha.formName = formName;
        Captcha.submitButtonName = submitButtonName;
        Captcha.publicKey = publicKey;
        Captcha.recaptchaLang = recaptchaLang;
        
    	if (Captcha.verified) {
    		Captcha.proceed();
    		return;
    	}
    	
    	if (typeof Recaptcha == "undefined") {
    	    // recaptcha.js failed to load, recaptcha.net might be down
    	    Captcha.submitClientError();
    	    return;
    	}
    	
    	if (!Captcha.dialog) {
        	Captcha.dialog = new SimpleDialog("captcha_dialog", true);
        	Captcha.dialog.enter = Captcha.submit;
        	Captcha.dialog.setupDefaultButtons();
        	Captcha.dialog.overrideButton(0, LC.getLabel("Buttons", "submit"), "Captcha.submit()");
        	Captcha.dialog.setWidth('350px');
        	Captcha.dialog.register(); // this calls createDialog
        	var html = [];
        	html.push('<div id="recaptcha_widget">');
        	html.push(LC.getLabel("CaptchaElement", "dialog"));
        	html.push('<div id="recaptcha_image"></div>');
        	html.push('<div id="incorrect" style="display:none;color:red">');html.push(LC.getLabel("CaptchaElement", "incorrect"));html.push('</div>');
        	html.push('<table class="captchaContent" border="0" cellpadding="0" cellspacing="0">');
        	html.push('  <tr><td><span class="recaptcha_only_if_image">');html.push(LC.getLabel("CaptchaElement", "imagePrompt"));html.push('</span>');
        	html.push('          <span class="recaptcha_only_if_audio">');html.push(LC.getLabel("CaptchaElement", "audioPrompt"));html.push('</span>');
        	html.push('          <input id="recaptcha_response_field" name="recaptcha_response_field" type="text">');
        	html.push('      </td>');
        	html.push('      <td style="width:25px;border-left:none;cursor:pointer">');
        	html.push('          <img src="/img/recaptcha_refresh.gif" alt="' + LC.getLabel("CaptchaElement", "refresh") + '" title="' + LC.getLabel("CaptchaElement", "refresh") + '" onclick="Recaptcha.reload()">');
        	html.push('          <img class="recaptcha_only_if_image" src="/img/recaptcha_audio.gif" alt="' + LC.getLabel("CaptchaElement", "audio") + '" title="' + LC.getLabel("CaptchaElement", "audio") + '" onclick="Recaptcha.switch_type(\'audio\')">');
        	html.push('          <img class="recaptcha_only_if_audio" src="/img/recaptcha_text.gif" alt="' + LC.getLabel("CaptchaElement", "image") + '" title="' + LC.getLabel("CaptchaElement", "text") + '" onclick="Recaptcha.switch_type(\'image\')">');
            if (helpHref != null && helpHref.length > 0) {
            	html.push('          <img src="/img/recaptcha_help.gif" alt="' + LC.getLabel("Buttons", "help") + '" title="' + LC.getLabel("Buttons", "help") + '" onclick="' + helpHref + '">');
            }
        	html.push('      </td>');
        	html.push('  </tr>');
        	html.push('  <tr><td colspan="2" style="border:0px">');
        	Captcha.dialog.createButtons(html);
        	html.push('<a id="moreinfo" style="float:right" href="#" onclick="Captcha.toggleMoreinfo(true)">');html.push(LC.getLabel("CaptchaElement", "moreinfo"));html.push('</a>');
        	html.push('  </td></tr>');
        	html.push('  <tr><td colspan="2" style="border:0px">');
        	html.push('    <div id="about" style="display:none"><img src="img/reCAPTCHAlogo.png" style="float:left;padding-right:5px">');
        	html.push('      <div style="font-size:85%">Security test provided by <a href="http://www.recaptcha.net" target="_blank">reCAPTCHA&trade;</a>');
        	html.push('      <br>The words above come from scanned books.  By typing them, you help to digitize old texts.</div>');
        	html.push('      <a style="float:right" href="#" onclick="Captcha.toggleMoreinfo(false)">');html.push(LC.getLabel("CaptchaElement", "lessinfo"));html.push('</a>');
        	html.push('    </div>');
        	html.push('  </td></tr>');
        	
        	html.push('</table>');
        	html.push('</div>');
        	
        	Captcha.dialog.setContentInnerHTML(html.join(""));
    	}
    	Captcha.dialog.show();
    	
        Captcha.displayOnly();
    },
    
    toggleMoreinfo : function(show) {
    	if (show) {
            document.getElementById('about').style.display = 'block';
            document.getElementById('moreinfo').style.display = 'none';
    	} else {
            document.getElementById('about').style.display = 'none';
            document.getElementById('moreinfo').style.display = 'inline';
    	}
    },
    
    displayOnly : function() {
        Recaptcha.create(Captcha.publicKey, null,
            { callback: Recaptcha.focus_response_field,
              theme: 'custom',
              lang: Captcha.recaptchaLang });
    },
    
    hide : function() {
        Captcha.dialog.hide();
    },

    // handles Captcha form submit
    submit : function() {
        if (!Captcha.checkRecaptchaConnected()) {
            Captcha.submitClientError();
        } else {
            Captcha.verify();
        }
        return false;
    },

    verify : function() {
        var challenge = Recaptcha.get_challenge();
        var response = Recaptcha.get_response();
        Recaptcha.destroy();
        Captcha.callVerifier(challenge, response, "false", Captcha.verifyResultCallback);
    },
    
    verifyResultCallback : function(response) {
        var responseText = response.responseText;
        var json = Util.evalAjaxServletOutput(responseText);
        if (json[CaptchaVerifierServlet.VALID_KEY] == true) {
            // proceed with the submit, which will now work
            Captcha.verified = true;
            Captcha.hide();
            Captcha.proceed();
        } else {
            // On failure, re-display the captcha
            document.getElementById('incorrect').style.display = 'block';
            Captcha.displayOnly();
        }
    },
    
    proceed : function() {
        if (Captcha.formName) {
	        document.forms[Captcha.formName][Captcha.submitButtonName].click();
    	} else {   
    	    window.location = document.getElementById(Captcha.submitButtonName).href;
    	}
    },
    
    submitClientError : function() {
        Captcha.callVerifier("", "", "true", Captcha.proceed);
    },
    
    callVerifier : function(chal, resp, clientError, callback) {
        var params = { };
        params[CaptchaVerifierServlet.CHALLENGE_PARAM] = chal;
        params[CaptchaVerifierServlet.RESPONSE_PARAM] = resp;
        params[CaptchaVerifierServlet.CLIENT_ERROR_PARAM] = clientError;
        var ajaxServletUrl = UrlMap.convertClassNameToUrl(CaptchaVerifierServlet.SERVLET_NAME, null);
        XBrowser.postHttpResponse(ajaxServletUrl, callback, XBrowser.buildPost(params));
    },
    
    checkRecaptchaConnected : function() {
        var imageHtml = document.getElementById('recaptcha_image').innerHTML;
        return !!imageHtml;
    }
}

function ActionOverrideUi() {}

ActionOverrideUi.prototype.visiblePicklist = null;

ActionOverrideUi.prototype.setVisiblePicklist = function(toDisplay) {
    if (ActionOverrideUi.prototype.visiblePicklist != null) {
        document.getElementById(ActionOverrideUi.prototype.visiblePicklist).className = 'hidden';
    }
    document.getElementById(toDisplay).className = null;
    ActionOverrideUi.prototype.visiblePicklist = toDisplay;
}


/*
 * Copyright, 1999-2006, SALESFORCE.com
 * All Rights Reserved
 * Company Confidential
 *
 * JavaScript Utilities. 
 * REQUIRES: DOJO-0.4.1.
 * WILL BE REMOVED - WILL TRY TO UTILIZE EXISTING FUNCTIONS IF AVAILABLE
 * @author dkothule
 * @since 148
 */

/**
 * Modify date object to parse ISO8601 format:
 */
Date.prototype.setISO8601 = function (string) {
    var regexp = "([0-9]{4})(-([0-9]{2})(-([0-9]{2})" +
        "(T([0-9]{2}):([0-9]{2})(:([0-9]{2})(\.([0-9]+))?)?" +
        "(Z|(([-+])([0-9]{2}):([0-9]{2})))?)?)?)?";
    var d = string.match(new RegExp(regexp));

    var offset = 0;
    var date = new Date(d[1], 0, 1);

    if (d[3]) { date.setMonth(d[3] - 1); }
    if (d[5]) { date.setDate(d[5]); }
    if (d[7]) { date.setHours(d[7]); }
    if (d[8]) { date.setMinutes(d[8]); }
    if (d[10]) { date.setSeconds(d[10]); }
    if (d[12]) { date.setMilliseconds(Number("0." + d[12]) * 1000); }
    if (d[14]) {
        offset = (Number(d[16]) * 60) + Number(d[17]);
        offset *= ((d[15] == '-') ? 1 : -1);
    }

    offset -= date.getTimezoneOffset();
    time = (Number(date) + (offset * 60 * 1000));
    this.setTime(Number(time));
}
Date.prototype.toISO8601String = function (format, offset) {
    /* accepted values for the format [1-6]:
     1 Year:
       YYYY (eg 1997)
     2 Year and month:
       YYYY-MM (eg 1997-07)
     3 Complete date:
       YYYY-MM-DD (eg 1997-07-16)
     4 Complete date plus hours and minutes:
       YYYY-MM-DDThh:mmTZD (eg 1997-07-16T19:20+01:00)
     5 Complete date plus hours, minutes and seconds:
       YYYY-MM-DDThh:mm:ssTZD (eg 1997-07-16T19:20:30+01:00)
     6 Complete date plus hours, minutes, seconds and a decimal
       fraction of a second
       YYYY-MM-DDThh:mm:ss.sTZD (eg 1997-07-16T19:20:30.45+01:00)
       
       offset indicates the timezone which in the form +HH:MM or -HH:MM
    */
    if (!format) { var format = 6; }
    if (!offset) {
        var offset = 'Z';
        var date = this;
    } else {
        var d = offset.match(/([-+])([0-9]{2}):([0-9]{2})/);
        var offsetnum = (Number(d[2]) * 60) + Number(d[3]);
        offsetnum *= ((d[1] == '-') ? -1 : 1);
        var date = new Date(Number(Number(this) + (offsetnum * 60000)));
    }

    var zeropad = function (num) { return ((num < 10) ? '0' : '') + num; }

    var str = "";
    str += date.getUTCFullYear();
    if (format > 1) { str += "-" + zeropad(date.getUTCMonth() + 1); }
    if (format > 2) { str += "-" + zeropad(date.getUTCDate()); }
    if (format > 3) {
        str += "T" + zeropad(date.getUTCHours()) +
               ":" + zeropad(date.getUTCMinutes());
    }
    if (format > 5) {
        var secs = Number(date.getUTCSeconds() + "." +
                   ((date.getUTCMilliseconds() < 100) ? '0' : '') +
                   zeropad(date.getUTCMilliseconds()));
        str += ":" + zeropad(secs);
    } else if (format > 4) { str += ":" + zeropad(date.getUTCSeconds()); }

    if (format > 3) { str += offset; }
    return str;
}
/**
 * JSUtils: Utility functions.
 */
var JSUtils = {
		/** 
		 * getTiomeZoneString - returns the current timezone string:
		 */
		getTimeZoneString: function(){
			var str = new Date().toString();
			var pos = str.lastIndexOf("(");
			if(pos != -1){
				str = str.substring(pos + 1);
				pos = str.indexOf(")");
				str = pos != -1? str.substring(0, pos) : str;
			}else{
				var words = str.split(' ');
				if(words != null && words.length == 6){
					str = words[words.length - 2];
				}else{
					str = "Local Timezone";
				}
			}
			return str;
		},
		
		/**
		 * Converts the ISO8601 string into a javascript date object.
		 */
		iso8601StringToDate: function(iso8601String){
			var date = new Date(); 
			date.setISO8601(iso8601String);
			return date;
		},
		
		/**
		 * Formats the timestamp in javascript date object to displayable string.
		 */
		formatTimestamp: function(timestamp) {
			if(timestamp == null){
				return "";
			}
			var strTimestamp = "";
			num = timestamp.getMonth() + 1;
			strTimestamp += " " + (num >= 10? "" : "0") + num;
			num = timestamp.getDate();
			strTimestamp += "/" + (num>= 10? "" : "0") + num;
			num = timestamp.getFullYear();
			strTimestamp += "/" + num;
			num = timestamp.getHours();
			strTimestamp += " " + (num>= 10? "" : "0") + num;
			num = timestamp.getMinutes();
			strTimestamp += ":" + (num>= 10? "" : "0") + num;
			num = timestamp.getSeconds();
			strTimestamp += "." + (num>= 10? "" : "0") + num;
			return strTimestamp;
		},
		
		/**
		 * Format numbers to add comma separator.
		 * @param {int} numbers
		 */
		formatNumbers: function (numbers){
			var nStr =  numbers + '';
			x = nStr.split('.');
			x1 = x[0];
			x2 = x.length > 1 ? '.' + x[1] : '';
			var rgx = /(\d+)(\d{3})/;
			while (rgx.test(x1)) {
				x1 = x1.replace(rgx, '$1' + ',' + '$2');
			}
			return x1 + x2;	
		}, /*::Method:formatNumbers*/
		
		/**
		 * Compare two strings.
		 * @param {string} str1 First string
		 * @param {string} str2 Second string.
		 * @type {int}
		 */
		strCompare: function(str1, str2){
			if(str1 > str2){
				return 1;
			}else if(str1 < str2){
				return -1;
			}else{
				return 0;
			}
		},/*::Method::strCompare*/
		
		/**
		 * Trim whitespace from 'str'. If 'wh' > 0,
		 * only trim from start, if 'wh' < 0, only trim
		 * from end, otherwise trim both ends
		 */
		trim: function(str, wh){
			if(!str.replace){ return str; }
			if(!str.length){ return str; }
			var re = (wh > 0) ? (/^\s+/) : (wh < 0) ? (/\s+$/) : (/^\s+|\s+$/g);
			return str.replace(re, "");
		}, /*::Method::trim*/
		
		/**
		 * Trim whitespaces at begining.
		 */
		ltrim: function(str){
			return JSUtils.trim(str, 1);
		}, /*::Method::ltrim*/
		
		/**
		 * Trim whitespace at the end.
		 */
		rtrim: function(str){
			return JSUtils.trim(str, -1);
		},/*::Method::rtrim*/
		
		unescapeChar: function(str, c) {
			var cur = new String;
			var inEscape = false;
			
			for (var i = 0; i < str.length; i++) {
				var ch = str.charAt(i);
				if (inEscape) { // escaped character
					cur = cur + ch;
					inEscape = false;
				} else if (ch == c) { // escaping
					inEscape = true;
				} else {
					cur = cur + ch;
				}
			}
			if (inEscape) return null;
			return cur;
		},/*::Method::unescapeChar*/
		
		
		splitWithQuoteAndEsc: function(str, split) {
	        var result = [];
	        var cur = new String;
	        var inQuote = false;
	        var inEscape = false;
	
	        for (var i = 0; i < str.length; i++) {
	            var ch = str.charAt(i);
	            if (inEscape) {  // escaped character
	                switch (ch) {
	                case 'n':
	                    cur = cur + '\n'; break;
	                case 'r':
	                    cur = cur + '\r'; break;
	                case 't':
	                    cur = cur + '\t'; break;
	                default:
	                    cur = cur + ch;
	                }
	                inEscape = false;
	            } else if (ch == '\\') {  // Escaping
	                inEscape = true;
	            } else if (ch == '\"') {  // Quoting
	                inQuote = !inQuote;
	            } else if (!inQuote && ch == split) {  // A delimiter
	                result.push(cur);
	                cur = new String;
	            } else {  // normal
	                cur = cur + ch;
	            }
	        }
	        if (inEscape || inQuote) {
	            return null;
	        }
	        result.push(cur);
	        return result;
		},/*::Method::splitWithQuoteAndEsc*/
		
		KEY_DEL 		: 46,
		KEY_ESC			: 27,
		KEY_BACKSPACE	: 8,
		KEY_ENTER		: 13, //0x0D
		/**
		 * Returns the event key code
		 */
		getEventKeyCode: function(e){
			var Esc = (window.event) ? 27 : e.DOM_VK_ESCAPE // MSIE : Firefox
			var keyChar = (window.event)? event.keyCode : e.keyCode;
			return (keyChar);
		},		
		
		/**
		 * Checks if the given event is an ESC key event or not.
		 * @param {event} e Event to be checked for.
		 */
		isESCKeyEvent: function (e){
			var Esc = (window.event) ? 27 : e.DOM_VK_ESCAPE // MSIE : Firefox
			var keyChar = (window.event)? event.keyCode : e.keyCode;
			return (keyChar == Esc);
		}, /*::Method::isESCKeyEvent*/
		
		/**
		 * Checks if the given event key contains a valid ASCII character or not.
		 * @param {event} e Event to be checked for.
		 */
		isASCIIKeyEvent: function(e){
			var Esc = (window.event) ? 27 : e.DOM_VK_ESCAPE // MSIE : Firefox
			var keyChar = (window.event)? event.keyCode : e.keyCode;
			return (keyChar >= 32 && keyChar <= 126);
		},
		
		/**
		 * Return the element from document with given id.
		 * @param {string} or {object} elementId to be searched for
		 * @return element if the argument is of type string with id of element;
		 *   		otherwise returns the argument itself;
		 * @type {object}
		 */
		getById: function(elementId){
			if(elementId && (typeof elementId == "string" || elementId instanceof String)){
				return document.getElementById(elementId);
			}else{
				return elementId;
			}
		}, /*::Method::getById*/
		
		/**
		 * Return the first matching element from document where the name 
		 * matches the elementName.
		 * @param {string} elementName Name of the element to search.
		 * @return element object if found; otherwise null;
		 * @type {object} 
		 */
		getByName: function(elementName){
			if(elementName == null) { return null;}
			if(typeof(elementName) == 'string'){
				var el = document.getElementsByName(elementName);
				if(el != null && el.length > 0){
					return el[0];
				}else{
					return null;
				}
			}else{
				return elementName;
			}
		}, /*::Method::getByName*/
		
		/**
		 * clearList
		 * Clears each list box that was passed to this method.
		 * Variable arguments can be passed with either list element or 
		 * an id of the list element (SELECT).
		 * Example: clearList(firstListObj, 'secondListId', thirdListObj).
		 * @param {...} args list1, list2...listn
		 */
		clearList: function() {
			for (var i = 0; i < arguments.length; i++) {
		    	var element = JSUtils.getById(arguments[i]);
		        if (element && element.options) {
		            element.options.length = 0;
		            element.selectedIndex = -1;
		        }
		    }
		}, /*::Method::clearList*/

		/**
		 * Clears the list from given index.
		 * @param list List Object
		 * @param fromIndex index to start removing items from (inclusive)
		 */
		clearListFrom: function(list, fromIndex){
			if(fromIndex == null || fromIndex <= 0){
				JSUtils.clearList(list);
				return;
			}
	    	var element = JSUtils.getById(list);
	        if (element && element.options && element.options.length > fromIndex && fromIndex > 0) {
	        	element.options.length = fromIndex;
	            element.selectedIndex = fromIndex - 1;
	        }
		},
		
		/**
		 * Populate the list box with provided data. 
		 * @param {array} data The multi-dimensional array [][2], 
		 *  with first item of an array item as label and second as value. 
		 *  Example: [['California', 'CA'],['Pittsburgh', 'PA']]
		 *	or		 [{label:'California', value:'CA'}, {label:'Pittsburgh', value:'PA'}]
		 *  or 		 ['California', 'Pittsburgh', 'New York']
		 *  or		 [10, 20, 30, 40, 50]
		 */
		setListData: function(listId, data){
			var list = JSUtils.getById(listId);
			if(list && data && data.length && data.length > 0){
				var text, value, item;
				for(var i=0; i < data.length; i++){
					item = data[i];
					if(item){
						//name, label pair
						//name, value pair
						//label, value pair
						//name list
						//number list
						//multi dimentional
						if(item.name != null && item.label != null){
							text = item.label;
							value = item.name;
						}else if(item.name != null && item.value != null){
							text = item.name;
							value = item.value;
						}else if(item.label != null && item.value != null){
							text = item.label;
							value = item.value;
						}else if(typeof(item) == 'string' || typeof(item) == 'number'){
							text = item.toString();
							value = text;
						}else{
							text = item.length > 0? item[0] : item.toString();
							value = item.length > 1? item[1] : text;
						}
						list.options[list.length] 
								= JSUtils.newOption(text, value);
					}
				}
			}
		}, /*::Method::setListData*/
		
		/**
		 * Removes the selected option(s) from the list box. 
		 * An optional boolean flag removeAll can be passed with value "true"
		 * to remove all selected options if it is multi-select list;
		 * otherwise by default it removes only one element.
		 * @param {object} list The List Element
		 * @param {boolean} removeAll Indicates if multiple option removal.
		 */
		removeSelectedOption: function(list, removeAll){
			list = JSUtils.getById(list);
			var idx = list? list.selectedIndex : -1;
			while(idx != -1){
				list.options[idx] = null;
				if(removeAll != null && removeAll == true){
					idx = list.selectedIndex;
				}else{
					return;
				}
			}
		}, /*::Method::removeSelectedOption*/
		
		/**
		 * Select the given option in given list.
		 * @param {object} list The list to select
		 * @param {object} option Option to select in in (text:, value:} format.
		 * @return Selects and returns the index of selected option if found;
		 *	  		otherwise -1;
		 * @type {int}
		 */
		selectOption: function(list, option){
			list = JSUtils.getById(list);
			if(list){
				var idx = JSUtils.indexOfOption(list, option);
				if(idx != -1){
					list.options[idx].selected = true;
					return idx;
				}
			}
			return -1;
		}, /*::Method::selectOption*/
		
		/**
		 * Unselect the given option in given list.
		 * @param {object} list The list object
		 * @param {object} option Option to unselect in in (text:, value:} format.
		 * @return Unselects and returns the index of option if found;
		 *	  		otherwise -1;
		 * @type {int}
		 */
		unselectOption: function(list, option){
			list = JSUtils.getById(list);
			if(list){
				var idx = JSUtils.indexOfOption(list, option);
				if(idx != -1){
					list.options[idx].selected = false;
					return idx;
				}
			}
			return -1;
		}, /*::Method::unselectOption*/
		
		/**
		 * Selects all the option in given list.
		 * @param {object} list The list object.
		 */
		selectAll: function(list){
			list = JSUtils.getById(list);
			if(list && list.options && list.options.length > 0){
				for(var i=0; i < list.options.length; i++){
					list.options[i].selected = true;
				}
			}
		}, /*::Method::selectAll*/
		
		/**
		 * Unselects all the option in given list.
		 * @param {object} list The list object.
		 */
		unselectAll: function(list){
			list = JSUtils.getById(list);
			if(list && list.options && list.options.length > 0){
				for(var i=0; i < list.options.length; i++){
					list.options[i].selected = false;
				}
			}
		}, /*::Method::unselectAll*/
		
		/**
		 * appendOption()
		 * Adds a new option to the list.
		 * @param {object} list The list object
		 * @param {string} optText The display text for the option.
		 * @param {string} optValue The actual value of the option.
		 * @return Returns the newly created option.
		 * @type {object}
		 */
		appendOption: function (list, optText, optValue){
			list = JSUtils.getById(list);
			if(!list){ return null;}
			var newOpt = JSUtils.newOption(optText, optValue);	
			list.options[list.length] = newOpt;
			return list.options[list.length-1];
		}, /*::Method::appendOption*/
		
		/**
		 * newOption()
		 * Creates a new option with given text and value.
		 * @param {string} optText The display text.
		 * @param {string} optValue The value of the option.
		 * @return Returns newly created option.
		 * @type {object}
		 */
		newOption: function(optText, optValue) {
			var newOpt = document.createElement("OPTION");
			newOpt.text = optText;
			newOpt.value = optValue;
			return newOpt;
		}, /*::Method::newOption*/
		
		/**
		 * setSelectedIndex
		 * @param {object} list The SELECT object
		 * @param {int} index Index of new selection.
		 */
		setSelectedIndex: function(list, index){
			list = JSUtils.getById(list);
			if(list && list.options && list.options.length > index){
				list.options[index].selected = true;
			}
		}, /*::Method::setSelectedIndex*/
		
		/**
		 * Returns the index of selected option in the list.
		 * @return selected index if selected; otherwise -1
		 * @type {int}
		 */
		getSelectedIndex: function(list){
			list = JSUtils.getById(list);
			if(list){
				return list.selectedIndex;
			}
			return -1;
		},  /*::Method::getSelectedIndex*/
		
		/**
		 * Returns the selected option in the list.
		 * @return selected option if selected; otherwise null.
		 * @type {object}
		 */
		getSelectedOption: function(list){
			list = JSUtils.getById(list);
			if(list && list.options && list.selectedIndex >=0 ){
				return list.options[list.selectedIndex];
			}
			return null;
		}, /*::Method::getSelectedOption*/
		
		/**
		 * Returns the selected option value in the list.
		 * @return selected option value if selected; otherwise null.
		 * @type {string}
		 */
		getSelectedValue: function(list){
			var opt = JSUtils.getSelectedOption(list);
			return opt == null? null : opt.value;
		}, /*::Method::getSelectedValue*/
		
		/**
		 * Returns the selected option text in the list.
		 * @return selected option text if selected; otherwise null.
		 * @type {string}
		 */
		getSelectedText: function(list){
			var opt = JSUtils.getSelectedOption(list);
			return opt == null? null : opt.text;
		}, /*::Method::getSelectedValue*/
		
		/**
		 * Returns the index of given option in the list.
		 * Example: JSUtils.indexOfOption(list, {value:"USA"})
		 * @return index of option if found; otherwise -1;
		 * @type {int}
		 */
		indexOfOption: function(list, option){
			if(option == null) {return -1; }
			var check;
			if(option.text == null && option.value != null){
				check = 0; //value only
			}else if(option.text != null && option.value == null){
				check = 1; //text only
			}else if(option.text != null && option.value != null){
				check = 2; //text and value
			}else {
				return -1; //invalid
			}
			list = JSUtils.getById(list);
			if(list && list.options && list.options.length > 0){
				for(var i=0; i < list.options.length; i++){
					switch(check){
						case 0:
							if(list.options[i].value == option.value){
								return i;
							}
							break;
						case 1:
							if(list.options[i].text == option.text){
								return i;
							}
							break;
						case 2:
							if(	list.options[i].value == option.value &&
								list.options[i].text == option.text){
								return i;
							}
							break;
					}
				}
			}
			return -1;
		},/*::Method::indexOfOption*/

		/**
		 * Set the innerHTML for the give object ID.
		 */
		setInnerHTML: function(objectId, value){
			var obj = JSUtils.getById(objectId);
			if(obj != null){
				obj.innerHTML = value;
			}
		},

		/**
		 * Gets the innerHTML for the give object ID.
		 */
		getInnerHTML: function(objectId){
			var obj = JSUtils.getById(objectId);
			return obj == null? null : obj.innerHTML;
		},
		
		/**
		 * Set the "value" attribute of the given element with given text.
		 * @param {object} input The input element.
		 * @value {string} value The text value.
		 */
		setTextValue: function(input, value){
			input = JSUtils.getById(input);
			if(input){
				try{input.value = value == null? "" : value;}catch(e){}
			}
		}, /*::Method::setTextValue*/
		
		/**
		 * Get the text value of "value" attribute from given object.
		 * @param {object} input The input element.
		 * @return Returns the text value of "value" attribute; otherwise null.
		 * @type {string}
		 */
		getTextValue: function(input){
			input = JSUtils.getById(input);
			return input? input.value : null;
		}, /*::Method::getTextValue*/
		
		/**
		 * Set the "style" attribute with given text. 
		 * Example: JSUtils.setStyleText("nodeId", "background-color:#FFFFFF;padding:5px");
		 */
		setStyleText: function(node, styleText){
			node = JSUtils.getById(node);
			try {
	 			node.style.cssText = styleText;
			} catch (e) {
				node.setAttribute("style", styleText);
			}
		},
		
		/**
		 * Set the value of checkbox.
		 * @param {object} checkbox The checkbox element.
		 * @param {boolean} check The new value of checkbox [true | false]
		 */
		setCheckbox: function(checkbox, check){
			checkbox = JSUtils.getById(checkbox);
			if(checkbox){
				checkbox.checked = check;
			}
		}, /*::Method::setCheckbox*/
		
		/**
		 * Determines if the checkbox is checked or not.
		 * @param {object} checkbox The checkbox element
		 * @return Returns true if the checkbox is checked; false otherwise.
		 * @type {boolean}
		 */
		isCheckboxChecked: function(checkbox){
			checkbox = JSUtils.getById(checkbox);
			return (checkbox && checkbox.checked);
		}, /*::Method::isCheckboxChecked*/
		
		/**
		 * Sets the focus on given element.
		 * @param {object} element The element to focus on.
		 */
		setFocus: function(element){
			element = JSUtils.getById(element);
			if(element){
				try{ element.focus(); }catch(e){}
			}
		}, /*::Method::setFocus*/
		
		/**
		 * Show (unhide) the given element.
		 * @param {object} element The element to make visible.
		 */
		show: function(){
			for (var i = 0; i < arguments.length; i++) {
				try{ dojo.style.show(arguments[i]); }catch(e){}
			}
		}, /*::Method::showObject*/
		
		/**
		 * Extended version of Show (unhide) the given element.
		 * This is used where dojo version (show) is not useful.
		 * @param {object} element The element to make visible.
		 */
		showEx: function(){
			var obj;
			for (var i = 0; i < arguments.length; i++) {
				obj = JSUtils.getById(arguments[i]);
				if(obj){
					try{
						obj.style.display = "";
						obj.style.visibility ="visible";
					}catch(e){}
				}
			}
		}, /*::Method::showObject*/
		
		/**
		 * Hides an element.
		 * @param {object} element An element to hide.
		 */
		hide: function(){
			for (var i = 0; i < arguments.length; i++) {
				try{ dojo.style.hide(arguments[i]); }catch(e){ dojo.debug(e);}
			}
		}, /*::Method::hide*/
		
		/**
		 * Hides an element.
		 * This is used where dojo version (hide) is not useful.
		 * @param {object} element An element to hide.
		 */
		hideEx: function(){
			var obj;
			for (var i = 0; i < arguments.length; i++) {
				obj = JSUtils.getById(arguments[i]);
				if(obj){
					try{
						obj.style.display = "none";
						obj.style.visibility = "hidden";
					}catch(e){}
				}
			}
		},/*::Method::hide*/
		
		/**
		 * Set the tab index for given elements in specified order.
		 * @param elements is an array of {name: "xxx", tabindex: xx}
		 */
		setTabIndex: function(elements){
			if(elements && elements.length && elements.length > 0){
				var el;
				for(var i=0; i < elements.length; i++){
					try{
						el = JSUtils.getById(elements[i].name);
						if(el) el.setAttribute("tabindex", elements[i].tabindex);
					}catch(e){
						dojo.debug(e);
					}
				}
			}
		},/*::Method:setTabIndex*/
		
		reloadPage: function(){
			try{
				window.location.reload();
			}catch(e){
				window.location.href=window.location.href
			}
		},/*::reloadPage():*/
		
		/**
		 * @param arg = {id, label, title, visible, onclick}
		 */
		setButtonProperties: function(){
			var btnVal, btnTitle;
			for (var i = 0; i < arguments.length; i++) {
				var btnProp = arguments[i];
				if(btnProp != null){
					if(btnProp.id){
						var btnObj = JSUtils.getById(btnProp.id);
						if(btnObj){
							btnVal = btnProp.label;
							btnTitle = btnProp.title? btnProp.title : btnVal;
							if(btnVal){
								btnObj.value = btnVal;
							}
							if(btnTitle){
								btnObj.title = btnTitle;
							}
							if(btnProp.onclick){
								btnObj.onclick = btnProp.onclick;
							}
							if(btnProp.visible){
								JSUtils.show(btnObj);
							}else{
								JSUtils.hide(btnObj);
							}
						}
					}
				}
			}
		}/*::setButtonProperties():*/
};/*::Class::JSUtils*/	

function ManageableInfoElement(dhtml_id){
	if (!dhtml_id) return;
	
	var outer = document.getElementById(dhtml_id);
	if (!outer) return;

	var elements = getElementsByClassName(ManageableInfo.MORE_INFO_CLASS, outer, "div");

	if (!elements || elements.length < 1) return;
	var moreInfo = elements[0];
	
	var self = this;
	this.isHidden = true;
	
	this.onLinkClickHandler = function(){
		if (self.isHidden){
			moreInfo.style.display = 'block';
			self.link.innerHTML = LC.getLabel("ManageableInfo", "LessInfo");
			self.isHidden = false;
		} else {
			moreInfo.style.display = 'none';
			self.link.innerHTML = LC.getLabel("ManageableInfo", "MoreInfo");
			self.isHidden = true;
		}
	}

	
	var linkArr = outer.getElementsByTagName("a");
	if (linkArr && linkArr.length > 0){
		this.link = linkArr[0]
		addEvent(this.link, 'click', this.onLinkClickHandler, false);
	}
}
var PortalStyleConfigEditor = {
    themes: {},
    themeLoader: null,
    previewUrls: {},
    inputs: []
};

PortalStyleConfigEditor.updateAllPreviews = function () {
    for (key in this.previewUrls) {
        this.updatePreview(this.previewUrls[key], key);
    }
};


PortalStyleConfigEditor.ThemeLoader = function (id) {
    this.id = id;
    this.select = document.getElementById(id);

    var self = this;
    this.handleChange = function (e) {
        self.loadTheme();
    }

    this.init();
};

PortalStyleConfigEditor.ThemeLoader.prototype.loadTheme = function () {
    var newTheme = this.select.value;
    var styleMap = PortalStyleConfigEditor.themes[newTheme];
    for (key in styleMap) {
        var field = document.getElementById(key);
        field.value = styleMap[key];
        if (field.updateColor) {
            field.updateColor();
        }
    }
    this.select.value = newTheme;
    PortalStyleConfigEditor.updateAllPreviews();
};

PortalStyleConfigEditor.ThemeLoader.prototype.reset = function () {
    this.select.value = "";
};

PortalStyleConfigEditor.ThemeLoader.prototype.init = function () {
    addEvent(this.select, 'change', this.handleChange, false);
    PortalStyleConfigEditor.themeLoader = this;
};

PortalStyleConfigEditor.FontSizeInputElement = function (id) {
    this.id = id;
    this.input = document.getElementById(id);

    var self = this;
    this.handleChange = function (e) {
        self.formatInput();
    };

    this.init();
};

PortalStyleConfigEditor.FontSizeInputElement.prototype.formatInput = function () {
    var fontSize = this.input.value;
    if ("%" != fontSize.charAt(fontSize.length - 1)) {
        this.input.value = fontSize + "%";
    }
};

PortalStyleConfigEditor.FontSizeInputElement.prototype.init = function () {
    addEvent(this.input, "change", this.handleChange, false);
};

PortalStyleConfigEditor.CssWidthInputElement = function (id) {
    this.id = id;
    this.select = document.getElementById(id);
};

PortalStyleConfigEditor.FontFamilyInputElement = function (id) {
    this.id = id;
    this.select = document.getElementById(id);
};


PortalStyleConfigEditor.BorderStyleInputElement = function (id) {
    this.id = id;
    this.input = document.getElementById(id);
};

PortalStyleConfigEditor.getPostBody = function () {
    var params = {};
    for (var i = 0; i < this.inputs.length; i++) {
        var input = this.inputs[i];
        params[input.id] = input.value;
    }

    return XBrowser.buildPost(params);
};

PortalStyleConfigEditor.updatePreview = function (url, target) {
    var handler = function (r) {
        var iframe = document.getElementById(target);
        var doc = iframe.contentWindow || iframe.contentDocument;
        if (doc.document) { doc = doc.document;}
        doc.body.innerHTML = "";
        doc.write(r.responseText);
        doc.close();
        iframe.style.height = doc.body.offsetHeight + "px";
    };
    var postBody = this.getPostBody();
    XBrowser.postHttpResponse(url, handler, postBody);
};

PortalStyleConfigEditor.init = function () {
    var tmp = document.getElementById(EditPageConstants.pEDIT_PAGE).elements;
    var handler = function (e) {
        PortalStyleConfigEditor.themeLoader.reset();
        PortalStyleConfigEditor.updateAllPreviews();
    };
    for (var i = 0; i < tmp.length; i++) {
        var field = tmp[i];
        if (0 == field.id.indexOf(PortalStyleConfigEditorConstants.PARAM_PREFIX)
            && field.id != this.themeLoader.id) {
            addEvent(field, "change", handler);
            this.inputs.push(field);
        }
    }
};

/**
 * Javascript object and controls for the inline color picker
 * @author rchen
 * @since 148
 */
 function ColorPicker() {
     this.pickerDiv = document.getElementById(ColorPickerConstants.DOM_ID);
     this.colorView = document.getElementById(ColorPickerConstants.COLOR_VIEW_ID);
     this.hexView = document.getElementById(ColorPickerConstants.HEX_VIEW_ID);
     this.shim = new iframeShim(this.pickerDiv);
     this.field = null;
     this.addedFields = {};
     var self = this;
     addEvent(document, "click", function () { self.hide(); }, false);
     addEvent(this.pickerDiv, "click", function (e) { ColorPicker.cancelHide(e); }, false);
}

ColorPicker.prototype.position = function () {
    // Get field's position relative to the offsetParent
    var x = 0;
    var y = 0;
    var elem = this.field;
    // TODO: RPC: Can this be done by getting absolute offset of the field and my element?
    while (elem != null && elem != this.pickerDiv.offsetParent) {
        x += elem.offsetLeft;
        y += elem.offsetTop;
        elem = elem.offsetParent;
    }

    // X - The default is to have the left match the field's left. If that won't work,
    // align the right sides.
    // Y - The default is to be flush with the bottom of the field. If that won't work,
    // place it flush with the top
    var pickerHeight = this.pickerDiv.offsetHeight;
    var pickerWidth = this.pickerDiv.offsetWidth;
    if (getObjX(this.field) + pickerWidth > getScrollX() + getWindowWidth()) {
        x -= pickerWidth - this.field.offsetWidth;
    }
    if (getObjY(this.field) + pickerHeight > getScrollY() + getWindowHeight()) {
        y -= pickerHeight;
    } else {
        y += this.field.offsetHeight;
    }

    this.shim.setStyle("left", x + "px");
    this.shim.setStyle("top", y + "px");
}

ColorPicker.prototype.hide = function () {
    this.shim.setStyle("display", "none");
}

ColorPicker.prototype.show = function (fieldId) {
    this.field = document.getElementById(fieldId);
    this.updateView(this.field.value);
    this.shim.setStyle("display", "block");
    if (!this.addedFields[fieldId]) {
        this.addedFields[fieldId] = true;
        var self = this;
        addEvent(this.field, "keydown", function (e) { self.handleKeyPress(e); }, false);
    }
    this.position();
}

ColorPicker.prototype.handleKeyPress = function(e) {
    var key = getEvent(e).keyCode;
    if (key == KEY_ESC) {
        this.hide();
    }
}

ColorPicker.prototype.selectBasic = function (value) {
    if (!this.field.disabled && this.field.value != value) {
        // Assign new value
        this.field.value = ColorPicker.formatHex(value);

        // Fire events
        if (this.field.fireEvent) {
            this.field.fireEvent('onchange');
        } else if (this.field.dispatchEvent) {
            var e = document.createEvent("HTMLEvents");
            e.initEvent('change', true, true);
            this.field.dispatchEvent(e);
        }
    }
    this.hide();
}

ColorPicker.prototype.updateView = function (hex) {
    var fHex = ColorPicker.formatHex(hex);
    this.colorView.style.backgroundColor = fHex;
    this.hexView.value = fHex;
}

// Lazily instantiated singleton
ColorPicker.singleton = null;

ColorPicker.cancelHide = function (e) {
    eventCancelBubble(e);
    return false;
}

ColorPicker.pick = function (fieldId, event) {
    if (!ColorPicker.singleton) {
        ColorPicker.singleton = new ColorPicker();
    }
    ColorPicker.singleton.show(fieldId);
    if (event) {
        ColorPicker.cancelHide(event);
    }
}

ColorPicker.formatHex = function (hex) {
    var newHex = ('#' == hex.charAt(0)) ? hex : '#' + hex;
    // Attempt to expand 3 hex to 6 hex
    if (newHex.match(/^#[0-9a-f]{3}$/i)) {
        var r = newHex.charAt(1);
        var g = newHex.charAt(2);
        var b = newHex.charAt(3);
        newHex = '#' + r + r + g + g + b + b;
    } else if (!newHex.match(/^#[0-9a-f]{6}$/i)) {
        newHex = '#FFFFFF';
    }
    return newHex;
}

ColorPicker.hiOn = function (elem, boxColor) {
    hiOn(elem);
    elem.style.backgroundColor = '#000000';
    ColorPicker.singleton.updateView(boxColor);
}

ColorPicker.hiOff = function (elem, boxColor) {
    hiOff(elem);
    elem.style.backgroundColor = ColorPicker.formatHex(boxColor);
}

/**
 * Represents a field in a detail element. Handles opening the field for editing, undo, retrieving value for save...
 * Fields are created onload so they can use the DOM.
 * 
 * @author jmooney
 * @since 150
 */
function InlineEditField() {
    this.id = null;
    this.tableCell = null;
    this.readDiv = null;
    this.created = false;
    this.editDiv = null;
    this.state = InlineEditState.NONE;
    this.required = false;
    this.label = null;
    this.initialValue = null;
    this.initialHTML = null;
    this.currentValue = null;
    this.changed = false;
    this.undoButton = null;
    this.error = null;
    this.errorDiv = null;
    this.compound = false;
    this.waitForLoad = false;
    this.controllerId = null;
    this.saveOnEnter = false;
}

// overlay for compound fields and dependencies
InlineEditField.overlay = null;

/**
 * common initializer for all fields
 */
InlineEditField.prototype.init = /* final */ function(id, state, required, isColumn, initialValue) {
    this.id = id;
    this.state = state;
    this.required = required;
    this.isColumn = isColumn;
    if (initialValue === undefined || initialValue === null) {
        this.initialValue = "";
    } else {
        this.initialValue = initialValue;
    }
    this.currentValue = this.initialValue;
    if (!this.isColumn) {
        this.tableCell = getElementByIdCS(id + InlineEditConstants.CELL_ID);
        this.readDiv = getElementByIdCS(id + InlineEditConstants.INNER_ID);
        if (!this.tableCell || !this.readDiv) {
            this.state = InlineEditState.NONE;
            return;
        }
        this.initialHTML = this.readDiv.innerHTML;
    }
}

/* abstract methods that need to be overridden */

InlineEditField.prototype.isDifferentValue = function(newValue) { }

InlineEditField.prototype.openField = function() { }

InlineEditField.prototype.showEdit = function() { }

InlineEditField.prototype.hideEdit = function() { }

InlineEditField.prototype.closeField = function() { }

InlineEditField.prototype.createEditElements = function() { }

InlineEditField.prototype.getValueFromEdit = function() { return null; }

InlineEditField.prototype.updateReadElement = function() { }

InlineEditField.prototype.formatValue = function() { }

InlineEditField.prototype.updateEditElement = function() { }

InlineEditField.prototype.addSaveData = function(saveData) { }

InlineEditField.prototype.createDummy = function() { }

InlineEditField.prototype.load = function() { }

/**
 * @returns true if this field should post values on save
 */
InlineEditField.prototype.doPost = function() {
    return this.state == InlineEditState.EDIT || this.state == InlineEditState.POSTONLY;
}

/**
 * resets this field back to its initial value
 */
InlineEditField.prototype.reset = function() { }

/**
 * strip out < > and replace newlines with <br>
 */
InlineEditField.prototype.cleanValue = function(value) {
    if (value && value.replace) {
        return value.replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\n/g, '<br>').replace(/"/g, "&quot;");
    }
    return value;
}

/**
 * get the value to use when a field has been nulled out, usually "Deleted" in italics
 */
InlineEditField.prototype.getDeletedValue = function() {
    return this.isColumn ? "" : "<em>" + LC.getLabel("Global", "deleted") + "</em>";
}

/**
 * strip < > out of a string
 */
InlineEditField.prototype.cleanValueNoBR = function(value) {
    if (value && value.replace) {
        return value.replace(/</g, '&lt;').replace(/>/g, '&gt;');
    }
    return value;
}

/**
 * creates the undo button
 */
InlineEditField.prototype.createUndoButton = function() {
    this.undoButton = document.createElement("a");
    this.undoButton.className = "inlineEditUndoLink";
    this.undoButton.title = LC.getLabel("Icons", "inlineEditUndo");
    this.undoButton.href = "javascript:sfdcPage.inlineEditData.resetFieldById('" + this.id + "');";
    this.undoButton.innerHTML = "<img width='16px' height='16px' src='s.gif' alt='" + LC.getLabel("Icons", "inlineEditUndo") + "' class='inlineEditUndo'>";
}

/**
 * Attempts to get the field label from the label cell in the detail element.
 */
InlineEditField.prototype.getFieldLabel = function() {
    var labelNode = this.tableCell.previousSibling;
    while (labelNode && labelNode.nodeType != Node.TEXT_NODE) {
        labelNode = labelNode.firstChild;
    }
    return labelNode ? labelNode.nodeValue : "";
}

/**
 * sets a validation error on this field
 */
InlineEditField.prototype.setError = function(message) {
    this.error = message;
    if (!this.errorDiv) {
        this.errorDiv = document.createElement("div");
        this.errorDiv.className = "errorMsg";
        this.errorDiv.innerHTML = this.error;
        this.tableCell.appendChild(this.errorDiv);
    } else {
        this.errorDiv.innerHTML = this.error;
        this.errorDiv.style.display = "block";
    }
}

/**
 * clears any validation errors on this field
 */
InlineEditField.prototype.clearError = function() {
    if (this.errorDiv) {
        this.errorDiv.style.display = "none";
    }
    this.error = null;
}

/**
 * get the css class for this field's state
 */
InlineEditField.prototype.getCSSClass = function() {
    return this.state.cssClass;
}

/**
 * get the mouseover css class for this state
 */
InlineEditField.prototype.getCSSHoverClass = function() {
    return this.state.cssClass + "On";
}


/*  -----   STATIC FUNCTIONS   -----  */

/**
 * create a field from the field data struct
 */
InlineEditField.createField = function(fieldData) {
    var fieldType = InlineEditField.resolveSwitchableField(fieldData);
    var fieldId = fieldData[InlineEditConstants.FIELD_ID];
    var state = InlineEditState[fieldData[InlineEditConstants.FIELD_STATE]];
    var required = fieldData[InlineEditConstants.FIELD_REQUIRED];
    var initialValue = fieldData[InlineEditConstants.FIELD_VALUE];
    var extraData = {};
    if (fieldType && fieldType.inlineEditExtraData) {
        for (var i = 0; i <  fieldType.inlineEditExtraData.length; i++) {
            extraData[fieldType.inlineEditExtraData[i]] = fieldData[fieldType.inlineEditExtraData[i]];
        }
    }
    try {
        if (fieldType && fieldType.inlineEditFieldObject && fieldId && state) {
            var ctor = fieldType.inlineEditFieldConstructor();
            return new ctor(fieldId, state, required, false, initialValue, extraData);
            //return eval("new " + fieldType.inlineEditFieldObject + "(fieldId, state, required, false, initialValue, extraData)");
        }
    } catch(e) {
        // squash js error, field won't be editable
    }
    return null;
}

/**
 * resolves switchable personname fields for Account name
 */
InlineEditField.resolveSwitchableField = function(fieldData) {
    var type = ColumnType[fieldData[InlineEditConstants.FIELD_TYPE]];
    if (type == ColumnType.SWITCHABLE_PERSONNAME) {
        return ColumnType[fieldData[InlineEditConstants.OVERRIDE_TYPE]];
    }
    return type;
}

var Util = {
    makeOptionString : function(labelText, value, array){
        if (!array){
            return "<option value='" + value + "'>" + labelText + "</option>";
        } else {
            array.push('<option value="')
            array.push(value);
            array.push('">');
            array.push(labelText);
            array.push('</option>');
        }
    },
    
    scriptCache : {},

    evalScriptsUnderElement : function(element){
        var scriptTags = element.getElementsByTagName("script");
        var srcScripts = [];
        for (var i = 0; i < scriptTags.length; i++) {
        	var src = scriptTags[i].src;
        	if (src && !Util.scriptCache[src]) {
        		XBrowser.createDynamicScript(src);
        		Util.scriptCache[src] = true;
        		srcScripts.push(scriptTags[i]);
	     	} else {
	            eval(scriptTags[i].innerHTML);
        	}
        }
        for (var i = 0; i < srcScripts.length; i++) {
   			srcScripts[i].parentNode.removeChild(srcScripts[i]);	
        }
    },

    evalAjaxServletOutput : function(jsonStr){
        if (!jsonStr){
            return null;
        } else if (jsonStr.substring(0, AjaxServlet.CSRF_PROTECT.length) !== AjaxServlet.CSRF_PROTECT){
            //If it doesn't start with CSRF_PROTECT, it didn't come from AjaxServlet...something's wrong
            throw "CSRF protect string not added to servlet response.";
        } else  {
            return eval('('+jsonStr.substring(AjaxServlet.CSRF_PROTECT.length, jsonStr.length) + ')');
        }
    },

    refreshDynamicSelect : function(/*SelectElement*/selectElement, /*list of [label, value]*/options, /*boolean*/ showNone, /*str*/valToMatch){
        var selectedIndex = 0;
        var optionsArr = ["<select name='", selectElement.name, "' id='", selectElement.id, "' class='", selectElement.className, "' title='", selectElement.title, "'"];
        // otherAtributes contains optional attributes for select elements, they are retained if they are set for the original element
        var otherAttributes = ["size","multiple"];
        for (var i = 0; i < otherAttributes.length; i++){
            var param=otherAttributes[i];
            if (selectElement[param]) {
                optionsArr.push(" ");
                optionsArr.push(param);
                optionsArr.push("='");
                optionsArr.push(selectElement[param]);
                optionsArr.push("'");
            }
        }
        optionsArr.push(">");

        var indexNum = 0;
        if (showNone){
            Util.makeOptionString(LC.getLabel("SelectElement", "Required"), '', optionsArr);
            indexNum++;
        }
        for (var i = 0; i < options.length; i++){
            var newVal = options[i][1];
            Util.makeOptionString(options[i][0], newVal, optionsArr);
            if (valToMatch && (newVal === valToMatch)){
                selectedIndex = indexNum;
            }
            indexNum++;
        }
        optionsArr.push("</select>");
        var selParent = selectElement.parentNode;
        if (!selParent.isDynamicSelect){
            var wrapperSpan = document.createElement("SPAN");
            wrapperSpan.isDynamicSelect = true;
            selParent.insertBefore(wrapperSpan, selectElement);
            selParent.removeChild(selectElement);
            selParent = wrapperSpan;
        }
        selParent.innerHTML = optionsArr.join("");
        var newSel = selParent.firstChild;
        if (valToMatch){
            newSel.selectedIndex = selectedIndex;
        }
        return newSel;
     },
 /**
  * Will return a string that can be used as the innerHTML of another element, which will
  * create a select element with the desired attributes and options
  */
    createDynamicSelect : function(/*attribute map*/attributeMap, /*list of [label, value]*/options, /*boolean*/ showNone) {
        var optionsArr = ["<select"];
        for (var key in attributeMap){
                optionsArr.push(" ");
                optionsArr.push(key);
                optionsArr.push("='");
                optionsArr.push(attributeMap[key]);
                optionsArr.push("'");
        }
        optionsArr.push(">");

        if (showNone){
            Util.makeOptionString(LC.getLabel("SelectElement", "Required"), '', optionsArr);
        }
        for (var i = 0; i < options.length; i++){
            var newVal = options[i][1];
            Util.makeOptionString(options[i][0], newVal, optionsArr);
        }
        optionsArr.push("</select>");

        return optionsArr.join("");
    },

    /**
     * convenience method to add Options to SelectElements
     */
    insertOption : function(/*Select Element*/ selectElement, /* Option Element */ optionElement, /* int */index) {
        if (selectElement.currentStyle) {
            selectElement.add(optionElement, index);
        } else {
            selectElement.add(optionElement, selectElement.options[index]);
        }
    },

    /**
     * converts a list of options in [label, value] format into the format used by the picklist/MSP code
     */
    convertOptionsForPicklistData : function(/* list of [label, value] */ options) {
        var ret = [];
        for (var i = 0; i < options.length; i++) {
            ret.push(options[i][1]);
            ret.push(options[i][0]);
        }
        return ret;
    },
    
    /**
     * animates an HTMLElement by continuously altering a specified CSS value
     * 
     * a sample argument template for your coding convenience:
     * {"obj":object, "prop":"propertyName", "start":start, "target":target, "f":function(n) {return n}, "maxinc":maxinc, "aftereach": function(){...}, "after":function(){...}}
     * 
     * NOTE: for opacity, specify a value between 0 and 100 (IE style), not between 0.0 and 1.0 (Firefox style)
     * 
     */
    animate : function(args) {
		var obj = args["obj"];						/* element */
		var prop = args["prop"];					/* css property to change, as a string */
		var value = parseInt(args["start"]);		/* start value */
		var target = args["target"];				/* target value */
		var f = args["f"] || function(n){return n};	/* optional approach function, defaults to linear */
		var inc = args["inc"] || 1;					/* optional current increment (specify to give starting speed) */
		var maxinc = args["maxinc"] || Infinity;	/* optional maximum increment (i.e., when to stop acceleration) */
		var after = args["after"];					/* optional function to call when animation is complete */
		var aftereach = args["aftereach"];			/* optional function to call after each frame of animation */

    	if (target < value) {
    		var dest = value - f(inc);
    		value = (dest < target) ? target : dest;
    	}
    	else if (target > value) {
    		var dest = value + f(inc);
    		value = (dest > target) ? target : dest;
    	}
    	
    	if(prop=="opacity") {
    		obj["style"][prop] = value / 100;
    		obj["style"]["filter"] = "alpha(opacity="+value+")";
    	} else {
	    	obj["style"][prop] = value + "px";
    	}
    	
    	if (!(inc >= maxinc))
    		inc++;
    		
    	if (value != target) {
    		if (aftereach)
    			aftereach();
    		setTimeout(function () { Util.animate({"obj":obj, "prop":prop, "start":value, "target":target, "f":f, "aftereach":aftereach, "after":after, "inc":inc}) }, 20);
    	} else {
    		if (aftereach)
    			aftereach();
    		if (after)
    			setTimeout(after, 50);
    	}
    }
}

function MaskTypeSelector(targetDivId, typeSelectId, charSelectId, maskData){
	this.targetDiv = document.getElementById(targetDivId);
	this.typeSelect = document.getElementById(typeSelectId);
	this.charSelect = document.getElementById(charSelectId);
	this.maskData = maskData;
	
	var self = this;
	
	this.handleSelectChange = function(e){
		var typeValue = self.typeSelect.options[self.typeSelect.selectedIndex].value;
		var charValue = self.charSelect.options[self.charSelect.selectedIndex].value;
		
		if (!(typeValue && charValue)){
			self.targetDiv.innerHTML = "";
			return;
		}
		
		var example = self.maskData[typeValue];
		example = example.replace(/X/g, charValue);
		self.targetDiv.innerHTML = example;
	};

	addEvent(this.typeSelect, 'change', this.handleSelectChange, false);
	addEvent(this.charSelect, 'change', this.handleSelectChange, false);
	
	this.handleSelectChange();
}
////////////////////////////////
// Dynamically load CSS Skin
////////////////////////////////

function DynamicCss (){
    this.cssLinks = [];
}

DynamicCss.prototype.addCssUrl = function(url, mediaType) {
    this.cssLinks.push(new DynamicCss.CssLink(url, mediaType));
}

DynamicCss.prototype.writeCss = function(apiVersion, doc) {
    for (var i = 0; i < this.cssLinks.length; i++) {
        doc.write(this.cssLinks[i].getLink(apiVersion));
    }
}

DynamicCss.addCssUrl = function(url, mediaType) {
    DynamicCss.instance.addCssUrl(url, mediaType);
}

DynamicCss.writeCss = function(apiVersion, doc, dontClose) {
    DynamicCss.instance.writeCss(apiVersion, doc);
    if (!dontClose) {
        doc.close();
    }
}


// load one CSS file
DynamicCss.loadCSS = function(headElem, cssUri) {
    var commonCSSLink = document.createElement("link");
    commonCSSLink.setAttribute("type", "text/css");
    commonCSSLink.setAttribute("href", cssUri);
    commonCSSLink.setAttribute("rel", "stylesheet");
    headElem.appendChild(commonCSSLink);
}

// load a set of CSS style sheets for a theme
DynamicCss.loadSkin = function(getUserInfoResult, version) {
    var headElem = DynamicCss.getHead();
    if (headElem) {
        var uiSkin = "Theme2";
        if (getUserInfoResult && getUserInfoResult.userUiSkin) {
            uiSkin = getUserInfoResult.userUiSkin;
        }
        var base;
        if (version){
            base = "/sCSS/" + version;
        } else {
            base = "/dCSS";
        }
        base = base + "/" + uiSkin + "/default";
        DynamicCss.loadCSS(headElem, base + "/common.css");
        DynamicCss.loadCSS(headElem, base + "/custom.css");
    }
}

DynamicCss.getHead = function(){
    var headElems = document.getElementsByTagName("head");
    var headElem = (headElems && headElems.length == 1) ? headElems[0] : null;
    return headElem;
}

DynamicCss.CssLink = function(url, mediaType) {
    this.url = url;
    if (mediaType) {
        this.mediaType = mediaType;
    } else {
        this.mediaType = null;
    }
}

DynamicCss.CssLink.prototype.getUrl = function() { 
    return this.url;
}

DynamicCss.CssLink.prototype.getMediaType = function() { 
    return this.mediaType;
}

DynamicCss.CssLink.prototype.getLink = function(apiVersion) {
    var strBuf = [];
    strBuf.push("<link type='text/css' rel='stylesheet' href='");
    var url = this.getUrl();
    if (apiVersion) {
        if (!DynamicCss.CssLink.URL_VERSION_REGEX) {
            DynamicCss.CssLink.URL_VERSION_REGEX = new RegExp("sCSS/[^/]*");
        }
        var repStr = "sCSS/" + apiVersion;
        url = url.replace(DynamicCss.CssLink.URL_VERSION_REGEX, repStr);
    }
    strBuf.push(url);
    strBuf.push("'");
    if (this.getMediaType()) {
        strBuf.push(" media='");
        strBuf.push(this.getMediaType());
        strBuf.push("'");
    }
    strBuf.push(">");
    return strBuf.join('');
}


DynamicCss.instance = new DynamicCss();  //singleton

/**
 * MRU hover detail object.
 * @author mooney
 * @since 146
 */
function MRUHoverDetail(id) {
    this.id = id;
    this.mruItem = getElementByIdCS("mru" + id);
    this.hover = document.createElement("div");
    this.hover.id = id + "Hover";
    this.hover.className = "mruHoverDetail";
    this.hover.innerHTML = "<div class=\"bPageBlock secondaryPalette\"><div class=\"pbBody\">" + LC.getLabel("Global", "loading") + "</div></div>";
    this.mruItem.appendChild(this.hover);
    this.originalClass = this.mruItem.className;
    var width = this.mruItem.offsetWidth;
    // IE6 calculates the width incorrectly, add in 30 pixels for the mruIcon and its margin
    if (this.mruItem.currentStyle && XBrowser.userAgent.isIE6) {
       width -= 30;
    }
    this.hover.style.left = width + "px";
    this.hover = new iframeShim(this.hover);
    this.fadingOut = null;
    this.fadingIn = null;
    this.loaded = false;
}

MRUHoverDetail.SHOW_DELAY = 800;
MRUHoverDetail.HIDE_DELAY = 400;
// the URL for bulk loading all the MRU hovers
MRUHoverDetail.loaderURL = null;
// boolean for if the request has been sent already
MRUHoverDetail.sentRequest = false;
// response from the bulk loader servlet
MRUHoverDetail.response = null;
// map from id to hover object
MRUHoverDetail.hovers = {};
// id of the currently open hover
MRUHoverDetail.openHover = null;

// static function to retrieve a hover detail using a 15 char ID
MRUHoverDetail.getHover = function(id) {
    if (MRUHoverDetail.hovers[id]) {
        return MRUHoverDetail.hovers[id];
    }
    var hover = new MRUHoverDetail(id);
    MRUHoverDetail.hovers[id] = hover;
    return hover;
}

// static function to load the hover details
MRUHoverDetail.bulkLoad = function() {
    if (!MRUHoverDetail.sentRequest && MRUHoverDetail.loaderURL != null) {
        MRUHoverDetail.sentRequest = true;
        XBrowser.getHttpResponse(MRUHoverDetail.loaderURL,
            function(request) {
                MRUHoverDetail.response = request.responseText;
                // if a hover detail is already open then load it now
                if (MRUHoverDetail.openHover != null) {
                	MRUHoverDetail.hovers[MRUHoverDetail.openHover].load();
                }
            },
            function(request) {
                MRUHoverDetail.response = request.responseText;
                if (MRUHoverDetail.openHover != null) {
                	MRUHoverDetail.hovers[MRUHoverDetail.openHover].load();
                }
            }
        );
    }
}
// show the hover detail
MRUHoverDetail.prototype.show = function() {
    if (this.fadingOut) {
        clearTimeout(this.fadingOut);
        this.fadingOut = null;
	} else {
        var self = this;
	    this.fadingIn = setTimeout( function() { self.showNow(); }, MRUHoverDetail.SHOW_DELAY);
    }
}

MRUHoverDetail.prototype.showNow = function() {
    if (!MRUHoverDetail.sentRequest) {
    	if (MRUHoverDetail.loaderURL != null) {
            MRUHoverDetail.bulkLoad();
    	} else {
    		// we haven't loaded, and we have no URL to load from, so don't display anything.
    		// onunload should null out the URL, so this is mostly to prevent sending a request after
    		// the user navigates away from this page
    		return;
    	}
    }
	MRUHoverDetail.openHover = this.id;
	if (!this.loaded && MRUHoverDetail.response != null) {
		this.load();
	}
    this.hover.setStyle("display", "block");
    if (this.mruItem.currentStyle && XBrowser.userAgent.isIE6) {
        // something wrong with the offsetLeft calc for this in IE6, override it manually for now
        this.hover.iframe.style.left = this.hover.div.style.left;
    }
    this.mruItem.className = this.originalClass + " secondaryPalette";
    this.fadingIn = null;
}

// hide the hover detail
MRUHoverDetail.prototype.hide = function(id) {
    if (this.fadingIn) {
        clearTimeout(this.fadingIn);
        this.fadingIn = null;
    } else {
        var self = this;
        this.fadingOut = setTimeout(function() { self.hideNow(); }, MRUHoverDetail.HIDE_DELAY);
    }
}

MRUHoverDetail.prototype.hideNow = function() {
	MRUHoverDetail.openHover = null;
    this.hover.setStyle("display", "none");
    this.mruItem.className = this.originalClass;
    this.fadingOut = null;
}

// loads the mini detail from the responseText
MRUHoverDetail.prototype.load = function() {
    var startTag = "<" + this.id + ">";
    var endTag = "</" + this.id + ">";
    var start = MRUHoverDetail.response.indexOf(startTag);
    var end = MRUHoverDetail.response.indexOf(endTag);
    if (start != -1 && end != -1) {
    	this.hover.div.innerHTML = MRUHoverDetail.response.slice(start + startTag.length, end);
    	Util.evalScriptsUnderElement(this.hover.div);
    	this.loaded = true;
    }
}

/* This file contains Ext extensions which are specific to the new list views in 154. */

if (window.Ext) {

// NAMESPACING
var Sfdc = {};
Sfdc.grid = {};

/**
 * @class Sfdc.grid.GridView
 * @extends Ext.grid.GridView
 */
Sfdc.grid.GridView = Ext.extend(Ext.grid.GridView, {
    // we are not using the Ext.data.Store sort implementation--this maintains sort state
    sortState : { field: null,
                  dir: null
                },
    
    // private
    onRowSelect : function(row){
        var recordId = this.grid.store.getAt(row).id;
        var checkbox = getElementByIdCS(recordId);
        if (checkbox) {
            checkbox.checked = true;
            updateToggleAllBox(checkbox.form,'ids');
        }
        this.addRowClass(row, "x-grid3-row-selected");
        this.grid.viewport.paginator.selectedOnThisPage++;
    },

    // private
    onRowDeselect : function(row){
        var recordId = this.grid.store.getAt(row).id;
        var checkbox = getElementByIdCS(recordId);
        if (checkbox) {
            checkbox.checked = false;
            updateToggleAllBox(checkbox.form,'ids');
        }
        this.removeRowClass(row, "x-grid3-row-selected");
        this.grid.viewport.paginator.selectedOnThisPage--;
    },
    
    /* ADDING DOM IDS */
    // private
    initTemplates : function(){
        var ts = this.templates || {};
        if(!ts.master){
            ts.master = new Ext.Template(
                    '<div class="x-grid3" hidefocus="true">',
                        '<div class="x-grid3-viewport">',
                            '<div class="x-grid3-header"><div class="x-grid3-header-inner"><div class="x-grid3-header-offset">{header}</div></div><div class="x-clear"></div></div>',
                            '<div class="x-grid3-scroller"><div class="x-grid3-body">{body}</div><a href="#" class="x-grid3-focus" tabIndex="-1"></a></div>',
                        "</div>",
                        '<div class="x-grid3-resize-marker">&#160;</div>',
                        '<div class="x-grid3-resize-proxy">&#160;</div>',
                    "</div>"
                    );
        }

        if(!ts.header){
            ts.header = new Ext.Template(
                    '<table border="0" cellspacing="0" cellpadding="0" style="{tstyle}">',
                    '<thead><tr class="x-grid3-hd-row">{cells}</tr></thead>',
                    "</table>"
                    );
        }

        if(!ts.hcell){
            ts.hcell = new Ext.Template(
                    '<td class="x-grid3-hd x-grid3-cell x-grid3-td-{id}" style="{style}"><div {tooltip} {attr} class="x-grid3-hd-inner x-grid3-hd-{id}" style="{istyle}">', this.grid.enableHdMenu ? '<a class="x-grid3-hd-btn" href="#"></a>' : '',
                    '{value}<img class="x-grid3-sort-icon" src="', Ext.BLANK_IMAGE_URL, '" />',
                    "</div></td>"
                    );
        }

        if(!ts.body){
            ts.body = new Ext.Template('{rows}');
        }

        if(!ts.row){
            ts.row = new Ext.Template(
                    '<div class="x-grid3-row {alt}" style="{tstyle}"><table class="x-grid3-row-table" border="0" cellspacing="0" cellpadding="0" style="{tstyle}">',
                    '<tbody><tr>{cells}</tr>',
                    (this.enableRowBody ? '<tr class="x-grid3-row-body-tr" style="{bodyStyle}"><td colspan="{cols}" class="x-grid3-body-cell" tabIndex="0" hidefocus="on"><div class="x-grid3-row-body">{body}</div></td></tr>' : ''),
                    '</tbody></table></div>'
                    );
        }

        if(!ts.cell){
            ts.cell = new Ext.Template(
                    '<td class="x-grid3-col x-grid3-cell x-grid3-td-{id} {css}" style="{style}" tabIndex="0" {cellAttr}>',
                    '<div class="x-grid3-cell-inner x-grid3-col-{id}" id="{domId}" {attr}>{value}</div>',
                    "</td>"
                    );
        }

        for(var k in ts){
            var t = ts[k];
            if(t && typeof t.compile == 'function' && !t.compiled){
                t.disableFormats = true;
                t.compile();
            }
        }

        this.templates = ts;

        this.tdClass = 'x-grid3-cell';
        this.cellSelector = 'td.x-grid3-cell';
        this.hdCls = 'x-grid3-hd';
        this.rowSelector = 'div.x-grid3-row';
        this.colRe = new RegExp("x-grid3-td-([^\\s]+)", "");
    },
    
    // private
    doRender : function(cs, rs, ds, startRow, colCount, stripe){
        var ts = this.templates, ct = ts.cell, rt = ts.row, last = colCount-1;
        var tstyle = 'width:'+this.getTotalWidth()+';';
        // buffers
        var buf = [], cb, c, p = {}, rp = {tstyle: tstyle}, r;
        for(var j = 0, len = rs.length; j < len; j++){
            r = rs[j]; cb = [];
            var rowIndex = (j+startRow);
            for(var i = 0; i < colCount; i++){
                c = cs[i];
                p.domId = r.id + "_" + c.id;
                p.id = c.id;
                p.css = i == 0 ? 'x-grid3-cell-first ' : (i == last ? 'x-grid3-cell-last ' : '');
                p.attr = p.cellAttr = "";
                p.value = c.renderer(r.data[c.name], p, r, rowIndex, i, ds);
                p.style = c.style;
                if(p.value == undefined || p.value === "") p.value = "&#160;";
                if(r.dirty && typeof r.modified[c.name] !== 'undefined'){
                    p.css += ' x-grid3-dirty-cell';
                }
                cb[cb.length] = ct.apply(p);
            }
            var alt = [];
            if(stripe && ((rowIndex+1) % 2 == 0)){
                alt[0] = "x-grid3-row-alt";
            }
            if(r.dirty){
                alt[1] = " x-grid3-dirty-row";
            }
            rp.cols = colCount;
            if(this.getRowClass){
                alt[2] = this.getRowClass(r, rowIndex, rp, ds);
            }
            rp.alt = alt.join(" ");
            rp.cells = cb.join("");
            buf[buf.length] =  rt.apply(rp);
        }
        return buf.join("");
    },

    getColumnStyle : function(col, isHeader) {
        return Sfdc.grid.GridView.superclass.getColumnStyle.call(this, col, false);
    },
    
    /* resizes columns to the width of the longest data in the column
     * ** ONLY WORKS IF COLUMN IS *THINNER* THAN WIDEST DATA **
     */
    sizeColumnToContent: function(colIndex) {
        var maxwidth = 0;
        var extra = 8;
        
        var rows = this.getRows().length;
        for (var i=0; i<rows; i++) {
            var cellChild = this.getCell(i, colIndex).firstChild;
            var w = cellChild.scrollWidth;
            if (w == cellChild.clientWidth) {
            	// don't do anything if column is already wide enough
            	continue;
            }
            if (w > maxwidth) {
                maxwidth = w;
            }
        }
        
        if (maxwidth == 0) {
        	return;
        }
        
        this.grid.getColumnModel().setColumnWidth(colIndex, maxwidth+extra);
    }
});

/**
 * @class Sfdc.grid.RowSelectionModel
 * @extends Ext.grid.RowSelectionModel
 */
Sfdc.grid.RowSelectionModel = Ext.extend(Ext.grid.RowSelectionModel, {
    // private
    initEvents : function(){
        Sfdc.grid.RowSelectionModel.superclass.initEvents.call(this);
        this.on("beforerowselect", this.onBeforeRowSelect, this);
    },
    
    maxSelections : 200,
    
    /**
     * Selects a row.
     * @param {Number} row The index of the row to select
     * @param {Boolean} keepExisting (optional) True to keep existing selections
     */
    selectRow : function(index, keepExisting, preventViewNotify){
        if(this.locked || (index < 0 || index >= this.grid.store.getCount())) return false;
        if (this.isSelected(index)) return true;
        var r = this.grid.store.getAt(index);
        if(r && this.fireEvent("beforerowselect", this, index, keepExisting, r) !== false){
            if(!keepExisting || this.singleSelect){
                this.clearSelections();
            }
            this.selections.add(r);
            this.last = this.lastActive = index;
            if(!preventViewNotify){
                this.grid.getView().onRowSelect(index);
            }
            this.fireEvent("rowselect", this, index, r);
            this.fireEvent("selectionchange", this);
            this.grid.viewport.paginator.setSelectCount(this.selections.length);
        } else {
            return false;
        }
        
        return true;
    },

    /**
     * Deselects a row.
     * @param {Number} row The index of the row to deselect
     */
    deselectRow : function(index, preventViewNotify){
        if(this.locked || !this.isSelected(index)) return;
        this.last = index;
        var r = this.grid.store.getAt(index);
        if(r){
            this.selections.removeKey(r.id);
            if(!preventViewNotify){
                this.grid.getView().onRowDeselect(index);
            }
            this.fireEvent("rowdeselect", this, index, r);
            this.fireEvent("selectionchange", this);
            this.grid.viewport.paginator.setSelectCount(this.selections.length);
        }
    },
    
    /**
     * Selects multiple rows.
     * @param {Array} rows Array of the indexes of the row to select
     * @param {Boolean} keepExisting (optional) True to keep existing selections
     */
    selectRows : function(rows, keepExisting){
        if(!keepExisting){
            this.clearSelections();
        }
        for(var i = 0, len = rows.length; i < len; i++){
            if (!this.selectRow(rows[i], true)) {
                break;
            }
        }
    },

    /**
     * Selects a range of rows. All rows in between startRow and endRow are also selected.
     * @param {Number} startRow The index of the first row in the range
     * @param {Number} endRow The index of the last row in the range
     * @param {Boolean} keepExisting (optional) True to retain existing selections
     */
    selectRange : function(startRow, endRow, keepExisting){
        if(this.locked) return;
        if(!keepExisting){
            this.clearSelections();
        }
        if(startRow <= endRow){
            for(var i = startRow; i <= endRow; i++){
                if(!this.selectRow(i, true)) {
                    break;
                }
            }
        }else{
            for(var i = startRow; i >= endRow; i--){
                if(!this.selectRow(i, true)) {
                    break;
                }
            }
        }
    },
    
    /**
     * Deselects a range of rows. All rows in between startRow and endRow are also deselected.
     * @param {Number} startRow The index of the first row in the range
     * @param {Number} endRow The index of the last row in the range
     */
    deselectRange : function(startRow, endRow, preventViewNotify){
        if(this.locked) return;
        if(startRow <= endRow) {
            for(var i = startRow; i <= endRow; i++){
                this.deselectRow(i, preventViewNotify);
            }
        } else {
            for(var i = startRow; i >= endRow; i--){
                this.deselectRow(i, preventViewNotify);
            }
        }
    },
    
    /**
     * Clears all selections across all pages.
     */
    clearAllSelections : function() {
        this.clearSelections();
        this.selections.clear();
        this.grid.viewport.paginator.setSelectCount(0);
        this.grid.viewport.paginator.selectedOnThisPage = 0;
    },
    
    /**
     * Clears selections on this page.
     */
    clearSelections : function(){
        for(var i = 0, len = this.grid.store.getCount(); i < len; i++){
            this.deselectRow(i);
        }
        
        this.last = false;
    },

    /**
     * Selects all rows on this page.
     */
    selectAll : function(){
        if(this.locked) return;
        for(var i = 0, len = this.grid.store.getCount(); i < len; i++){
            if (!this.selectRow(i, true)) {
                break;   
            }
        }
    },
    
    // private
    onRefresh : function(){
        var ds = this.grid.store, index;
        var s = this.getSelections();
        
		if (this.grid.viewport.paginator) {
	        this.grid.viewport.paginator.selectedOnThisPage = 0;
        }

        var offPageHTML = [];
        for(var i = 0, len = s.length; i < len; i++){
            var r = s[i];
            if((index = ds.indexOfId(r.id)) != -1){
                this.grid.getView().onRowSelect(index);
            } else {
            	offPageHTML.push("<input type='hidden' name='ids' value='");
            	offPageHTML.push(s[i].id);
            	offPageHTML.push("'/>");
            }
        }
		this.grid.viewport.offPageIds.innerHTML = offPageHTML.join('');
        
        if(s.length != this.selections.getCount()){
            this.fireEvent("selectionchange", this);
        }
        this.last = false;
    },
    
    onBeforeRowSelect : function(sm, index, keepExisting, r) {
        if(this.selections.length >= this.maxSelections) {
            alert(LC.getLabel("List", "selectionLimit", this.maxSelections));
            return false;
        }
    },
    
    /* we are only allowing selection via checkbox.  blow away row selection. */
    handleMouseDown : function(g, rowIndex, e){
        return;
    },
    
    // private
    onEditorKey : function(field, e){
        return;
    }
});

/**
 * @class Sfdc.grid.CheckboxSelectionModel
 * @extends Sfdc.grid.RowSelectionModel
 */
Sfdc.grid.CheckboxSelectionModel = Ext.extend(Sfdc.grid.RowSelectionModel, {    
    header: "<input type='checkbox' id='allBox' value='' onclick='return false'/>",
    /**
     * @cfg {Number} width The default width in pixels of the checkbox column (defaults to 20).
     */
    width: 20,
    /**
     * @cfg {Boolean} sortable True if the checkbox column is sortable (defaults to false).
     */
    sortable: false,

    // private
    fixed:true,
    dataIndex: '',
    id: 'checkbox',
    
    // private
    renderer : function(v, p, record){
        var html = [];
        html.push("<input id='");
        html.push(record.id);
        html.push("' value='");
        html.push(record.id);
        html.push("'");
        html.push(" type='checkbox'");
        html.push(" class='checkbox'");
        html.push(" name='ids'");
        html.push(" onclick='return false;'/>");
        return html.join('');
    },

    // private
    initEvents : function(){
        Sfdc.grid.CheckboxSelectionModel.superclass.initEvents.call(this);
        this.grid.on('render', function(){
            var view = this.grid.getView();
            view.mainBody.on('mousedown', this.onMouseDown, this);
            Ext.fly(view.innerHd).on('mousedown', this.onHdMouseDown, this);

        }, this);
    },

    // private
    onMouseDown : function(e, t){
        if(e.button === 0 && t.className == 'checkbox'){ // Only fire if left-click
            e.stopEvent();
            var row = e.getTarget('.x-grid3-row');
            
            if(row){
                var index = row.rowIndex;
                
                if(e.shiftKey && this.last !== false){
                    var last = this.last;
                    
                    if (this.isSelected(last)) {
                        this.selectRange(last, index, true);
                    } else {
                        this.deselectRange(last, index);
                    }
                    this.last = last; // reset the last
                } else {
                    if(this.isSelected(index)){
                        this.deselectRow(index);
                    }else{
                        this.selectRow(index, true);
                    }
                }
            }
        }
    },

    // private
    onHdMouseDown : function(e, t){
        if(e.button === 0) {
            if(t.id == 'allBox'){
                e.stopEvent();
                if(t.checked){
                    this.clearSelections();
                }else{
                    this.selectAll();
                }
            }
        }
    },
    
    // private
    onRefresh : function(){
        var all = getElementByIdCS("allBox");
        if (all) {
            all.checked = false;
        }
        Sfdc.grid.CheckboxSelectionModel.superclass.onRefresh.call(this);
    }
});

}

var MOUSE_OVER_FADE_MAP = [];

/* This should be called from onMouseOver */
function addMouseOver(div, /*optional*/hotSpot){
  for (var i = 0; i < MOUSE_OVER_FADE_MAP.length; i++){
    if (MOUSE_OVER_FADE_MAP[i] === div){
      return;
    }
  }

  var inner;
  for (var i = 0; i < div.childNodes.length; i++){
    if (div.childNodes[i].className == MouseOverElement.DEFAULT_CLASS_INNER) {
      inner = div.childNodes[i];
      break;
    }
  }
  if (!inner) return;
  var foo;
  if (hotSpot){
    foo = new MouseOverFade(hotSpot, inner);
  } else {
    foo = new MouseOverFade(div, inner);
  }
  foo.handleMouseOver();
  MOUSE_OVER_FADE_MAP.push(div);
}

function MouseOverFade(hotSpot, divToFade){
  	this.mover = new MouseOverFadeHandler(hotSpot, divToFade, true);
  	
  	var self = this;
  	
  this.handleMouseOver = function(e){
    self.mover.fadeIn();
  };

  this.handleMouseOut = function(e){
    self.mover.fadeOut();
  };

  this.init();
}

MouseOverFade.prototype.init = function(){
    addEvent(this.mover.controller, 'mouseover', this.handleMouseOver, false);
    addEvent(this.mover.controller, 'mouseout', this.handleMouseOut, false);
    addEvent(this.mover.div, 'mouseover', this.handleMouseOver, false);
    addEvent(this.mover.div, 'mouseout', this.handleMouseOut, false);
};

function MouseOverFadeHandler(hotSpot, divToFade, saveOrigPos){
  this.controller = hotSpot
  this.div = divToFade;
  this.shim = new iframeShim(divToFade);
  this.saveOrigPos = saveOrigPos;

  var self = this;
  
  this.setPosition = function(object) {
  		if (!object){
  			object = self.shim;
  		}
		object.setStyle('display', 'block');
		if (self.saveOrigPos){
		     if (!self.origL){
		          self.origL = self.div.style.left;
		      } else {
		          object.setStyle('left', self.origL);
		      }
		}

        var calloutLeft = getOffsetLeft(self.div);
        var calloutRight = calloutLeft + self.div.offsetWidth;
        var windowRight = getScrollX() + getWindowWidth() - 15;

        if (calloutLeft < 0) {
            object.setStyle('left', "0");
        } else if (calloutRight > windowRight){
            object.setStyle('left', (self.div.offsetLeft - (calloutRight - windowRight) - 20) + "px");
        } 
        
        //Now the bottom
        if (self.saveOrigPos){
	        if (!self.origTop){
	        	self.origTop = self.div.style.top;
	        } else {
	        	object.setStyle('top', self.origTop);
	        }
        }
        
        var calloutTop = getObjY(self.div);
        var calloutBottom = calloutTop + self.div.offsetHeight;
        var windowBottom = getScrollY() + getWindowHeight() - 15; //15 for scrollbars
        
        if (calloutTop < 0){
        	object.setStyle('top', '0');
        } else if (calloutBottom > windowBottom ){
        	object.setStyle('top', (self.div.offsetTop - (calloutBottom - windowBottom) - 15) + 'px');
        } 
    }
    
  this.mover = new Fader(
    this.shim,
    function(object, currVal) { return object.getOpacity() <= 0; },
    function(object, currVal) {	 return object.getOpacity() >= 0.99; },
    30,
    function(currVal, sign) { return currVal += sign*0.2; },
    function(object, nextVal) { object.setOpacity(nextVal); },
    0,
    function(object) {object.setOpacity(0); object.setStyle('display', 'none');},
    function(object) {object.setOpacity(0.99); object.setStyle('display', 'block');},
	this.setPosition
  ); 
  
  this.fadeIn = function(){
  	self.mover.fadeIn();
  }
  
  this.fadeOut = function(){
  	self.mover.fadeOut();
  }
}
function Attachments() {}

var hasPendingAttachments = false;

function addPendingAttachment(attId) {
   document.getElementById(Activity.pNEW_ATTACHMENTS).value=document.getElementById(Activity.pNEW_ATTACHMENTS).value + attId + ',';
   hasPendingAttachments = true;
   displayAttachmentWarning(true);
}

function removePendingAttachment(attId, listDomId) {
   var att = document.getElementById(Activity.pNEW_ATTACHMENTS);
   if(att) {
       var attStr = new String(att.value);
       att.value = attStr.replace(attId +',', '');
       hasPendingAttachments = (att.value.length >= 15);
       if(!hasPendingAttachments) {
           displayAttachmentWarning(false);
       }
       var extraParamNames = null;
       var attIds = document.getElementById(Activity.pNEW_ATTACHMENTS);
       if (attIds) {
           extraParamNames = new Array(attIds.id);
       }
       var rl = sfdcPage.getRelatedListById(listDomId);
       if(rl) {
           rl.refresh(extraParamNames, attIds ? new Array(attIds.value) : null);
       }
   }
}

function displayAttachmentWarning(showWarning){
    var aw = document.getElementById(Activity.pATT_WARNING);
    if (aw) {
        if (showWarning){
            aw.style.display='block';
        } else {
            aw.style.display='none';
        }
    }

}

/**
 * attachments is a comma-separated list of ids. (stupid, yes.)
 * returns object based on PromoteTransientAttachments.formatResults().
 */
Attachments.prototype.promoteAttachments = function(sessionId, parentId, attachments, checkSize){

    var promotionResult = null;

    if (sessionId && parentId && (attachments || checkSize)){

        var qs = new QueryString("");
        qs.add("sid", sessionId);
        qs.add("pid", parentId);
        qs.add("att", attachments);
        if (checkSize){
            qs.add("check", "1");
        }

        var promoteURL = "/servlet/promoteAtt" + qs.toString();
        var response = DesktopAjax.prototype.doGet(promoteURL);
        if (response){
            promotionResult = eval("(" + response + ")");
        }
        
    }
    
    return promotionResult;
}

var TimePickerInputElement = {};

// onfocus to the input field show the picker and clears the field if HH:MM text persent
TimePickerInputElement.FocusInput = function (inputId) {
    var inputElement = document.getElementById(inputId);

    inputElement.className = "timeInputActive";

	// show blank input value if value is HH:MM when the field is onFocus
    if (inputElement.value == TimePickerInputElementConstants.EMPTY_TIME_STANDIN) {
        inputElement.value = "";
        inputElement.select();
    } else if (inputElement.value != '') {
        inputElement.select();
    }
}

TimePickerInputElement.BlurInput = function (inputId) {
    var inputElement = document.getElementById(inputId);

    //if the field is empty populate it with HH:MM value 
    if (inputElement.value == '') {
        inputElement.className = "timeInputInactive";
        inputElement.value = TimePickerInputElementConstants.EMPTY_TIME_STANDIN;
    }
}


//  Javascript functionality for the tagging setup.
//

var TagSettingsPage = function(){}

// Static function used by the tagging setup page
TagSettingsPage.toggleTags = function(elemId, item) {
  var section = document.getElementById(elemId);
  if (item.checked) {
    section.style.display='block';
  }
  else {
    section.style.display='none';
  }
}

/**
 * JS functionality for the Google Talk sidebar gadget (see SidebarModuleGoogleTalkElement.java)
 * @author byang
 * @since 152
 **/
function GoogleTalk(gadget, resizeBar, gadgetUrl) {
    this.gadget = gadget;
    this.gadgetUrl = gadgetUrl;
    this.resizeBar = resizeBar;
    this.resizeBarOrigHeight = resizeBar.style.height;
    this.mouseStatus = 'up';
    this.popupWindow = function() {};
    this.showOnExitOverlay = true;

    var cookieHeight = getCookie(GoogleTalkConstants.HEIGHT_COOKIE);
    this.expandedHeight = cookieHeight == null || cookieHeight == 0 ?
        GoogleTalkConstants.EXPANDED_HEIGHT : cookieHeight;

    // For some reason, in IE6, if the talk gadget is loaded before bodyOnLoad() is executed,
    // the JS gets crossed-up and nothing works.  So, the loading is deferred until GoogleTalk
    // is registered, which happens in bodyOnLoad() (see SidebarGoogleTalkGadget.java)
    if (this.gadget.height != GoogleTalkConstants.COLLAPSED_HEIGHT) {
        this.gadget.src = this.gadgetUrl;
    }

    /**
     * Shows/hides the gadget.  Also shows/hides the resize bar
     **/
    GoogleTalk.prototype.toggle = function(hiddenLinks, shownLinks) {
        var isExpanding = this.gadget.height == GoogleTalkConstants.COLLAPSED_HEIGHT;

        this.gadget.height = (isExpanding ? this.expandedHeight : GoogleTalkConstants.COLLAPSED_HEIGHT);

        // this is important: by blanking out the source of the iframe, we disconnect from Google Talk
        if (isExpanding) {
            this.gadget.src = this.gadgetUrl;
        } else {
            this.gadget.src = UrlMap.getURL("BlankPage");
        }

        // set a cookie denoting that the user has collapsed or expanded the gadget
        var expires = new Date();
        expires.setTime(expires.getTime() + (3650*24*60*60*1000));
        setCookie(GoogleTalkConstants.COLLAPSED_COOKIE, isExpanding ? '0' : '1', expires);

        // toggle the links that are shown
        if (isExpanding) {
            shownLinks.style.display = 'inline';
            hiddenLinks.style.display = 'none';
        } else {
            shownLinks.style.display = 'none';
            hiddenLinks.style.display = 'inline';
        }

        // hide the resize bar
        this.resizeBar.style.display = isExpanding ? 'block' : 'none';

        // force resize handling in the console
        if (typeof resizeFramesToFit != 'undefined') {
            resizeFramesToFit();
        }
    }

    /**
     * Resizes the gadget while the user is dragging
     **/
    GoogleTalk.prototype.resize = function(e) {
        if(this.mouseStatus == 'down'){
            var curevent = (typeof event == 'undefined' ? e : event);
            // get new mouse position and calculate movement in pixels
            var newPos = curevent.clientY;
            var newHeight=parseInt(this.curHeight + parseInt(newPos - this.curPos));
            //conditional to set minimum height to 5
            newHeight = ( newHeight < GoogleTalkConstants.MIN_EXPANDED_HEIGHT ? GoogleTalkConstants.MIN_EXPANDED_HEIGHT : newHeight);
            //set the new height of the div
            this.gadget.height = newHeight;
        }
    }

    /**
     * Initiates resizing
     **/
    GoogleTalk.prototype.setStartDrag = function(e) {
        //for handling events in ie vs. w3c
        var curevent = (typeof event == 'undefined' ? e : event);

        // some trickery to allow the user ample space to drag their mouse without killing the drag by mousing over the gadget
        this.resizeBar.style.height = '39px';
        var newHeight = this.gadget.height - 35;
        this.gadget.height = newHeight > GoogleTalkConstants.MIN_EXPANDED_HEIGHT ? newHeight : GoogleTalkConstants.MIN_EXPANDED_HEIGHT ;

        //sets mouse flag as down
        this.mouseStatus = 'down';
        //gets position of click
        this.curPos = curevent.clientY;

        this.curHeight = parseInt(this.gadget.height);

        // make the entire page area register the resize events
        document.body.onmousemove = function(e) { GoogleTalk.prototype.theGadget.resize(e); };
        document.body.onmouseup = function(e) { GoogleTalk.prototype.theGadget.setEndDrag(e); };
    }

    /**
     * Ends resizing
     **/
    GoogleTalk.prototype.setEndDrag = function(e) {
        if(this.mouseStatus == 'down') {
            //sets mouse flag as down
            this.mouseStatus='up';
            this.resizeBar.style.height = this.resizeBarOrigHeight;

            var expires = new Date();
            expires.setTime(expires.getTime() + (3650*24*60*60*1000));
            setCookie(GoogleTalkConstants.HEIGHT_COOKIE, this.gadget.height, expires);

            this.expandedHeight = this.gadget.height;
        }
    }

    GoogleTalk.prototype.popout = function(e) {
        //if (typeof(this.popupWindow.focus) != 'undefined' && !this.popupWindow.closed) {
            //this.popupWindow.focus();
        //} else {
            this.popupWindow = window.open(this.gadgetUrl, 'gTalkPopup', 'toolbar=no,width=300,height=600,resizable=yes,toolbars=no,status=no,scrollbars=yes,menubar=no,directories=yes,location=yes,dependant=no', false, false);
        //}
    }


    // used in bbutils.js
    GoogleTalk.prototype.hide = function() {
        this.gadget.height = 0;
    }

    GoogleTalk.prototype.show = function() {
        this.gadget.height = this.expandedHeight;
    }

    GoogleTalk.prototype.isShown = function() {
        return this.gadget.height != GoogleTalkConstants.COLLAPSED_HEIGHT;
    }
}

ColorInput = function (id) {
    this.id = id;
    this.box = document.createElement("div");
    this.box.innerHTML = "<span></span>"; // Get IE to respect the height set for the DIV
    this.input = document.getElementById(id);

    var self = this;
    this.handleChange = function (e) {
        self.formatInput();
        self.updateColor();
    };

    this.init();
};

ColorInput.prototype.updateColor = function () {
    var color = this.input.value;
    if (color.match(/^(#[0-9a-f]{6})$/i)) {
        delStyleClass(this.box, ColorInputConstants.ERROR_COLOR_BOX_CSS);
        this.box.style.backgroundColor = color;
    } else {
        this.box.style.backgroundColor = "#FFFFFF";
        addStyleClass(this.box, ColorInputConstants.ERROR_COLOR_BOX_CSS);
    }
};

ColorInput.prototype.formatInput = function () {
    // Correct missing #
    var color = this.input.value;
    if ("#" != color.charAt(0) && 6 == color.length) {
        color = "#" + color;
    }

    // Uppercase
    color = color.toUpperCase();

    // Convert 3 hex to 6 hex
    if (color.match(/^#[0-9a-f]{3}$/i)) {
        var r = color.charAt(1);
        var g = color.charAt(2);
        var b = color.charAt(3);
        color = '#' + r + r + g + g + b + b;
    }

    this.input.value = color;
};

ColorInput.prototype.init = function () {
    // Prep box
    addStyleClass(this.box, ColorInputConstants.COLOR_BOX_CSS);
    this.updateColor();
    this.input.parentNode.insertBefore(this.box, this.input);

    // Add handler
    var self = this;
    addEvent(this.input, "change", this.handleChange, false);
    var handlePick = function (e) {
        ColorPicker.pick(self.id, e);
    };
    addEvent(this.box, "click", handlePick, false);
    addEvent(this.input, "focus", handlePick, false);
    addEvent(this.input, "click", ColorPicker.cancelHide, false);

    // Add a reference to functions
    this.input.updateColor = function() {self.updateColor(); };
};

/**
	@param object		required. object, The object to be faded
	@param testMin		required. function(object, currVal), should return true if the object is completely faded out
	@param testMax  	required. function(object, currVal), should return true if the object is completely faded in
	@param timestep 	required. number, The interval between steps, in milliseconds
	@param nextStep		required. function(currVal, sign), given the current value and a direction, return the next value.
								  sign will be positive for fadeIn, negative for fadeOut.  Any return value will be saved 
								  to currVal.
	@param increment	requried. function(object, nextVal) the increment function.  Should change the property
							      of the object to nextVal (which is the value returned by nextStep).  
	@param initVal		optional. number, an initial value for currVal.
	@param finalMin		optional. function(object),  Will be called at the end of fadeOut
	@param finalMax		optional. function(object), Will be called at the end of fadeIn
    @param startIn      optional. function(object), Wtill be called before a jumpIn or fadeIn
*/
function Fader(object, testMin, testMax, timestep, nextStep, increment, initVal, finalMin, finalMax, startIn) {	
	var self = this;
	
	if (!(object && testMin && testMax && timestep && nextStep && increment)){
		//required arguments
		return null;
	}
	
	this.object = object;
	this.testMin = testMin;
	this.testMax = testMax;
	this.timestep = timestep;
	this.nextStep = nextStep;
	this.increment = increment;
	this.currVal = initVal;
	this.finalMin = finalMin;
	this.finalMax = finalMax;
	this.startIn = startIn;
	
	this.inId = -1;
	this.outId = -1;
	
	this.position = 'out';
	
	this.fadeIn = function(){
		if (self.startIn) self.startIn(this.object);
		if (self.outId >= 0){
			clearInterval(self.outId);
			self.outId = -1;
		}
		if (this.inId < 0){
			self.inId = setInterval(fadeInCaller, self.timestep);
			self.position = 'moving_in';
 		} 
	}
	
	this.fadeOut = function() {
		if (self.inId >= 0){
			clearInterval(self.inId);
			self.inId = -1;
		}
		if (self.outId < 0){
			self.outId = setInterval(fadeOutCaller, self.timestep);
			self.position = 'moving_out';
 		} 
	}
	
	function fadeInCaller(){
		self.fadeInHelp();
	}
	
	function fadeOutCaller(){
		self.fadeOutHelp();
	}
	
	this.isMoving = function() {
		return (this.inId >= 0 || this.outId >= 0);
	}
	
	/*
	return one of 'in', 'out', 'moving_in', 'moving_out', or 'stopped'
	*/
	this.getPosition = function(){
		return self.position;
	}
}

Fader.prototype.fadeInHelp = function() {
	var nextVal = this.nextStep(this.currVal, 1);
	if (this.testMax(this.object, nextVal)){
		var finalVal = this.finalMax && this.finalMax(this.object);
		if (typeof finalVal == "number") { this.currVal = finalVal; }
		clearInterval(this.inId);
		this.inId = -1;
		this.position = 'in';
		return;
	} 
	this.increment(this.object, nextVal);
	this.currVal = nextVal;
};

Fader.prototype.fadeOutHelp = function() {
	var nextVal = this.nextStep(this.currVal, -1);
	if (this.testMin(this.object, nextVal)){
		var finalVal = this.finalMin && this.finalMin(this.object);
		if (typeof finalVal == "number") { this.currVal = finalVal; }
		clearInterval(this.outId);
		this.outId = -1;
		this.position = 'out';
		return;
	}
	this.increment(this.object, nextVal);
	this.currVal = nextVal;
};

Fader.prototype.stopFade = function() {
	if (this.inId >= 0){
		clearInterval(this.inId);
		this.inId = -1;
	}
	if (this.outId >= 0){
		clearInterval(this.outId);
		this.outId = -1;
	}
	this.position = 'stopped';
};

Fader.prototype.jumpIn = function() {
	if (this.startIn) this.startIn(this.object);
	var newCur = null;
	if (this.finalMax) {newCur = this.finalMax(this.object); }
	if (newCur !== null) { this.currVal = newCur;}
	this.position = 'in';
};

Fader.prototype.jumpOut = function() {
	var newCur = null;
	if (this.finalMin) {newCur = this.finalMin(this.object);}
	if (newCur !== null) { this.currVal = newCur; }
	this.position = 'out'
};
	
function LMACheckboxesManager() {
	var self = this;
	
	this.radios = document.getElementsByName(DeveloperSettings.LICENSE_MGR_CHOICE_STR);
	
	this.divNames = [];
	for (var i = 0; i < arguments.length; i++){
		this.divNames[i] = arguments[i];
	}
	
	this.onClickHandler = function(e){
		self.setVisibility(getEventTarget(getEvent(e)).value);
	}
	
	for (var i = 0; i < this.radios.length; i++){
		addEvent(this.radios[i], 'click', this.onClickHandler, false);
		if (this.radios[i].checked){
			this.setVisibility(this.radios[i].value);
		}
	}
}

LMACheckboxesManager.prototype.setVisibility = function(radioName){
	for (var i = 0; i < this.divNames.length; i++){
		document.getElementById(this.divNames[i] + DeveloperSettings.DIV_SUFFIX).style.display = 
			(this.divNames[i] === radioName ? 'block' : 'none');
	}
}
/**
 *  Javascript object for BannerElement.
 *  @author mooney
 *  @since 144
 *  @param id The id of the banner div
 */ 
function Banner(id) {
    this.bannerDiv = document.getElementById(id);
    this.bannerY = Banner.BANNER_END;
    this.fadingIn = null;
    this.fadingOut = null;
    this.clicked = false;
    var self = this;
    if (getCookie("sawBanner") != id) {
        this.shim = new iframeShim(this.bannerDiv);
        addEvent(this.bannerDiv, 'click', function() { self.click(); }, false);
        //addEvent(this.bannerDiv, 'mouseover', function() { self.interrupt(); }, false);
        //addEvent(this.bannerDiv, 'mouseout', function() { self.goAway(); }, false);
        this.shim.setStyle('display', 'block');
        this.fadeIn();
        //this.goAway();
    }
}

Banner.BANNER_END = -50;
Banner.BANNER_START = 0;
Banner.BANNER_STEP = -5;
Banner.BANNER_STEP_DELAY = 40;
Banner.BANNER_DELAY = 4000;
Banner.COOKIE_LIFE = 90;

// the user clicked on the banner, so make it go away right now and not come back for 90 days
Banner.prototype.click = function() {
    if (this.fadingIn) {
        clearTimeout(this.fadingIn);
        this.fadingIn = null;
    }
    this.clicked = true;
    var expires = new Date();
    expires.setDate(expires.getDate() + Banner.COOKIE_LIFE);
    setCookie("sawBanner", this.bannerDiv.id, expires);
    this.fadeOut();
}

// sets the delay for the banner to go away
Banner.prototype.goAway = function() {
    if (!this.clicked) {
        var self = this;
        this.fadingOut = setTimeout(function() { self.fadeOut(); }, Banner.BANNER_DELAY);
    }
}

// called when the user hovers on the banner, interrupts the call to hide it and fades in
Banner.prototype.interrupt = function() {
    if (!this.clicked && this.fadingOut) {
        var self = this;
        clearTimeout(this.fadingOut);
        this.fadingOut = null;
        this.fadingIn = setTimeout(function() { self.fadeIn(); }, 0);
    }
}

// slides the banner off the screen
Banner.prototype.fadeOut = function() {
    if (this.fadingOut) {
        clearTimeout(this.fadingOut);
        this.fadingOut = null;
    }
    if (this.bannerY > Banner.BANNER_END) {
        var self = this;
        this.bannerY += Banner.BANNER_STEP;
        this.shim.setStyle('top', this.bannerY + 'px');
        this.fadingOut = setTimeout(function() { self.fadeOut(); }, Banner.BANNER_STEP_DELAY);
    }
}

// slides the banner onto the screen
Banner.prototype.fadeIn = function() {
    if (this.fadingIn) {
        clearTimeout(this.fadingIn);
        this.fadingIn = null;
    }
    if (this.bannerY < Banner.BANNER_START) {
        var self = this;
        this.bannerY -= Banner.BANNER_STEP;
        this.shim.setStyle('top', this.bannerY + 'px');
        this.fadingIn = setTimeout(function() { self.fadeIn(); }, Banner.BANNER_STEP_DELAY);
    }
}

/**
 * MenuButton (mutton) basically mimics a SelectElement. In accessible mode it is a SelectElement.
 *
 * @author jmooney
 * @since 148
 */
function MenuButton(id, hasDefaultAction) {
    this.id = id;
    this.hasDefaultAction = hasDefaultAction;
    if (this.id) {
        if (this.hook_isAccessibleMode()) {
            this.initAccessibilityMode(this.id);
            return;
        }
        this.parentDiv = document.getElementById(id);
        this.buttonDiv = document.getElementById(id + MenuButtonElement.BUTTON);
        this.menuDiv = document.getElementById(id + MenuButtonElement.MENU);
        this.buttonWidth = MenuButton.DEFAULT_ARROW;
        this.shim = new iframeShim(this.menuDiv);
        var self = this;
        addEvent(document, 'click', function(e) {self.hideOthers(e); }, false);
        addEvent(document, 'keydown', function(e) { self.handleKeyPress(e); }, false);
        addEvent(this.parentDiv, 'click', function(e) { self.handleDivClick(e); }, false);
    }
}

MenuButton.DEFAULT_ARROW = 17;

// checks for a default action and opens or closes the menu
MenuButton.prototype.handleDivClick = function(e) {
    if (this.hasDefaultAction) {
        // determine if the click was on the arrow or the text
        var x = 0;
        if (e.offsetX) { // IE
            x = e.offsetX - e.srcElement.offsetLeft;
        } else if (e.layerX) { // FF
            var elem = e.target;
            x = e.pageX - getObjX(e.target);
        }
        if (this.defaultActionCondition(x, e)) {
            this.defaultAction();
            return;
        }
    }
    if (XBrowser.getCurrentStyle(this.menuDiv, "display") == "none") {
        this.show();
    } else {
        this.hide();
    }
}

MenuButton.prototype.defaultActionCondition = function (xLocation, event) {
    return (xLocation < this.parentDiv.offsetWidth - this.buttonWidth);
}

MenuButton.prototype.hook_isAccessibleMode = function() {
    return UserContext.isAccessibleMode;
}

MenuButton.prototype.defaultAction = function() {
    // clicked the text, do the default
    var link = this.menuDiv.childNodes[0];
    if (link.target) {
        // if the link has a target look for it by name
        var targets = document.getElementsByName(link.target);
        // target could be another window, only set it if its a frame
        if (targets && targets[0].src) {
            targets[0].src = link.href;
        } // else nothing we can do
    } else {
        navigateToUrl(link.href);
    }
}

// show the menu
MenuButton.prototype.show = function() {
    this.shim.setStyle("display", "block");
    this.position();
    this.show_hook();
}

MenuButton.prototype.show_hook = function() {}

// positions the menu correctly
MenuButton.prototype.position = function() {
    this.menuDiv.style.width = "";
    // first we set the width so that nothing wraps
    var width = this.buttonDiv.offsetWidth - 2; // subtract 2 for the borders
    for (var i = 0; i < this.menuDiv.childNodes.length; i++) {
        var node = this.menuDiv.childNodes[i];
        if (node.nodeType == Node.ELEMENT_NODE) {
            if (node.offsetWidth > width) {
                width = node.offsetWidth;
            }
        }
    }
     this.shim.setStyle("width", width + "px");
    // if the parent div is inline, position the menu below the button
    if (XBrowser.getCurrentStyle(this.parentDiv, "display") == "inline") {
        this.parentDiv.style.position = "relative";
        var y = this.buttonDiv.offsetHeight;

        if (this.parentDiv.currentStyle) {
            for (var i = 0; i < this.menuDiv.childNodes.length; i++) {
                var node = this.menuDiv.childNodes[i];
                if (node.nodeType == Node.ELEMENT_NODE) {
                    node.style.width = width + "px";
                }
            }
        }
        this.shim.setStyle("top", y + "px");
    }
}

// hide the menu
MenuButton.prototype.hide = function(ignoreHideHook) {
    if (XBrowser.getCurrentStyle(this.menuDiv, "display") != "none") {
        this.shim.setStyle("display", "none");
        this.parentDiv.style.position = "";
        if (!ignoreHideHook) {
            this.hide_hook();
        }
    }
}

MenuButton.prototype.hide_hook = function() {}

// hide if we aren't the target of the event
MenuButton.prototype.hideOthers = function(e) {
    var target = getEventTarget(e);
    if (target != this.buttonDiv && target != this.parentDiv) {
        this.hide(true);
    }
}

// esc closes the menu
MenuButton.prototype.handleKeyPress = function(e) {
    var key = e.keyCode;
    if (key == KEY_ESC) {
        this.hide();
    }
}

// add an options to a mutton, you should call position after adding options to resize the menu if it is open
MenuButton.prototype.addOption = function(disp, href, css, target) {
    // can't do this in accessible mode
    if (!this.hook_isAccessibleMode()) {
        var link = document.createElement("a");
        if (css) link.className = css;
        if (target) link.target = target;
        link.href = href;
        link.innerHTML = disp;
        this.menuDiv.appendChild(link);
    }
}

MenuButton.prototype.initAccessibilityMode = function(id) {
    var go = document.getElementById(id + MenuButtonElement.GO_BUTTON);
    addEvent(go, 'click', function() {
        var select = document.getElementById(id + MenuButtonElement.SELECT);
        var where = select.options[select.selectedIndex].value;
        if (where != "")
            navigateToUrl(where);
    }, false);
}

/**
 *  ActivityReminder, the main class for the popup timer & window logic.
 *
 *  @author beidson
 *  @since 144
 */

/**
 * There's only 1 reminder per page, so ActivityReminder is
 * all static methods.
 */
var ActivityReminder = {};

// Used for primitive inter-window communication (from popup to any other main sfdc window):
ActivityReminder._REMINDER_COOKIE = 'reminderCookie';
ActivityReminder._REMINDER_INTERVAL = 5000;

// Used for primitive inter-window communication (to prevent dup popups from multiple windows)
ActivityReminder._LOCK_COOKIE = 'reminderLockCookie';

/**
 * Initialize the popup timer.<b>
 * If isPopup is set, it is for the reminder popup itself,
 * which does some extra setup.
 */
ActivityReminder.initialize = function(popupSchedule, isPopup, isRefresh) {
    // If isPopup, we're the popup window itself:
    ActivityReminder._isPopup = isPopup;

    ActivityReminder._launched = new Date().getTime();
    ActivityReminder._currentSchedule = popupSchedule;
    ActivityReminder._checkScheduleUpdates();

    if (ActivityReminder._isPopup) {
        if (!isRefresh) {
            ActivityReminder._isBlur = false;
            addEvent(window, 'focus', ActivityReminder._wasFocused, false);
            addEvent(window, 'blur', ActivityReminder._wasBlured, false);
            setTimeout('ActivityReminder._pseudoFlash()', 500);
        }

        // Start the countdown:
        ActivityReminder._popupCountdown();

        ActivityReminder._setupMeetingSummary();

        ActivityReminder._setupSnoozeDismiss();

        ActivityReminder._updateSchedule();

        ActivityReminder._closeIfEmpty();

        // IE/CSS limitation:
        window.onresize = ActivityReminder._resizeToFitHorizontalChange;
        ActivityReminder._resizeToFitHorizontal();

        // Can get out of sync:
        updateToggleAllBox(document.forms.reminder, 'ids');
    }
}

ActivityReminder._checkScheduleUpdates = function() {
    // Check if another window, including the popup itself, refreshed the schedule cookie
    // (This is particularly important after a 'snooze' where the user may not actually
    // refresh the main window, but the user does close the reminder window)
    var rc = getCookie(ActivityReminder._REMINDER_COOKIE);
    // Parse it:
    if (rc) {
        ActivityReminder._currentSchedule = rc.split(',');
        // we (someone) got it, so delete just after the interval so other windows can get it:
        setTimeout("deleteCookie(ActivityReminder._REMINDER_COOKIE)", ActivityReminder._REMINDER_INTERVAL);
    }
    // See if any reminders went off:
    var now = new Date().getTime();
    var anyScheduled = false;
    var kept = new Array();
    for (var i=0; i<ActivityReminder._currentSchedule.length; i++) {
        if (Number(ActivityReminder._currentSchedule[i]) <= (now + ActivityReminder._REMINDER_INTERVAL * 2)) {
            // Now that the meeting is < the polling interval away, go ahead & schedule it directly:
            if (!anyScheduled) {
                ActivityReminder._schedule(ActivityReminder._currentSchedule[i]);
                anyScheduled = true;
            }
        } else {
            kept.push(ActivityReminder._currentSchedule[i]);
        }
    }
    // And clean up:
    ActivityReminder._currentSchedule = kept;

    setTimeout("ActivityReminder._checkScheduleUpdates()", ActivityReminder._REMINDER_INTERVAL);
}


ActivityReminder._schedule = function(time) {
    var milliseconds = Number(time) - new Date().getTime();
    // Don't schedule negative reminders, schedule them for now:
    if (milliseconds < 0) {
        milliseconds = 0;
    }
    if (ActivityReminder._isPopup) {
        milliseconds += 10000; // The popup can refresh itself, but if there's a main window open,
                               // give it a 10 second head start to actually do the refresh.
    }
    var timeSinceStart = Number(time) - ActivityReminder._launched;
    if (!ActivityReminder._isPopup && timeSinceStart <= (-2 * 60 * 60 * 1000)) {
        // If the reminder is more than two hours in the past, there's no point in re-checking the event before showing the popup.
        // More importantly, for users with popup blocking (who will ALWAYS have lots of past reminders),
        // we don't want to hit the refresh page... instead it'll just attempt to launch the popup,
        // which will get blocked.

        // We use two hours buffer because of pages views the following scenario:
        // 1) See reminder popup
        // 2) Dismiss all (or snooze, etc.)
        // 3) Hit back button to a previously viewed SFDC page
        // 4) Popup window opens/closes (because the previous page had the old reminder schedule)
        // The doesn't totally solve the issue, but it mitigates it --- the previous page view must have been > 2 hrs. ago.
        setTimeout("ActivityReminder._showPopup(false)", milliseconds);
    } else {
        setTimeout("ActivityReminder._showPopupIfRequired()", milliseconds);
    }
}

ActivityReminder._updateSchedule = function() {
    var scheduleCookieVal = ActivityReminder._currentSchedule.join(',');
    // Send it via cookie (all SFDC windows should get this):
    var dieDate = new Date(new Date().getTime() + ActivityReminder._REMINDER_INTERVAL * 2);
    setCookie(ActivityReminder._REMINDER_COOKIE, scheduleCookieVal, dieDate);
}

// Shows the popup (if necesary; may have been cancelled, etc.)
ActivityReminder._showPopupIfRequired = function() {
    var fn = function(responseStr) {
        // Check that we needed to popup:
        var txt = responseStr.indexOf(ActivityReminderConstants.REMINDERS_OK);
        if (txt < 0) {
            // Nope, it didn't give the signal.
            txt = responseStr.indexOf(ActivityReminderConstants.REMINDERS_NONE);
            if (txt < 0) {
                // Didn't get the signal at all... something wrong on the server, most likely a session timeout.
                // Just show the popup which will show the login page:
                ActivityReminder._showPopup();
            }
            // In we got the none signal, there are no events now; it was cancelled, just do nothing.
        } else {
            // Everything normal, show the popup
            ActivityReminder._showPopup();
        }
    };
    // Do a quick check to see if we still really need to popup:
    // (ideally this could be combined with the call to
    // display the page)
    var at = new Date().getTime();
    makeAjaxRequest(UrlMap.convertClassNameToUrl(ActivityReminderRefreshPage.pCLASS_NAME) + '?at=' + at, fn);
}

ActivityReminder._showPopup = function(isTest) {
    // Crude (semi reliable) lock to reduce chance of 2 browser windows opening 2 popups
    // (open with a name can still create dup windows if called simultaneously)
    var rc = getCookie(ActivityReminder._LOCK_COOKIE);
    if (rc) {
        // Already being shown.
        return;
    }
    var dieDate = new Date(new Date().getTime() + 5000); // expire quickly.
    setCookie(ActivityReminder._LOCK_COOKIE, 'shown', dieDate);

    // Ok, open the popup (or refresh the already-open one):
    var locval = isFirefox ? 'yes' : 'no'; // firefox changes the title if we don't show a location bar.
    var at = new Date().getTime();
    var teststr = isTest==true ? '&test=1' : '';
    var useScrollbars = (isNetscape && !isIE) ? 'yes' : 'no';
    var height = 320;
    if (isNetscape && isIE) height += 40; // Netscape/IE popup windows come up shorter for whatever reason.
    var parentWin = window.parent; // for desktop pages.
    var win = parentWin.open(UrlMap.convertClassNameToUrl(ActivityReminderPage.pCLASS_NAME) + '?at=' + at + teststr,
        'Reminder',
        'width=450,height=' + height + ',status=no,location=' + locval + ',dependent=no,resizable=yes,toolbar=no,directories=no,menubar=no,scrollbars=' + useScrollbars,
        false);
    var opened = win && !win.closed;
    // Note: firefox ignores status=no for security reasons...
    if (isTest && !opened) {
        // popup blocking.
        alert(LC.getLabel("Page_ActivityReminder", "popup_blocked"));
        return;
    }
    if (opened) {
        // for re-opens, need to pop to the front. Would like to flash, but doesn't seem to be a way.
        win.focus();
    }
}

ActivityReminder._popupCountdown = function() {
    // Update the remaining/overdue time display:
    var now = new Date().getTime();
    for (var i=0;;i++) {
        var el = document.getElementById(ActivityReminderConstants.DUE_MINUTES_ID + i);
        if (!el) {
            break;
        }
        var time = el.getAttribute(ActivityReminderConstants.DUE_TIME_ATTR);
        if (time != 0) {
            var away = time - now;
            ActivityReminder._updateTime(el, away);
        }
    }

    // Snooze options may have changed:
    ActivityReminder._enableSnoozeOptions();

    // refresh the countdown every 30 seconds.
    setTimeout("ActivityReminder._popupCountdown()", 30000);
}

// Updates 1 reminder due in field with the proper
// text for the current due in value.
ActivityReminder._updateTime = function(el, awayMillis) {
    var awayMins = Math.round(awayMillis / (1000*60));
    var textNode = el.firstChild;
    var overDue;
    if (awayMins < 0) {
       overDue = true;
       awayMins = -awayMins;
    } else {
       overDue = false;
    }

    var msg = ActivityReminder._formatDuration(awayMins, overDue);
    if (overDue) {
        msg = LC.getLabel("Page_ReminderSettings", "overdue", msg);
    }
    textNode.nodeValue = msg;
}

ActivityReminder._formatDuration = function(awayMins, overDue) {
    if (awayMins >= 60) {
        var awayHours = overDue ? Math.floor(awayMins / 60) : Math.ceil(awayMins / 60);
        if (awayHours >= 24) {
            var awayDays = Math.floor(awayHours / 24);
            if (awayDays == 1) {
                return LC.getLabel("Page_ReminderSettings", "day", awayDays);
            } else {
                return LC.getLabel("Page_ReminderSettings", "days", awayDays);
            }
        } else {
            if (awayHours == 1) {
                return LC.getLabel("Page_ReminderSettings", "hour", awayHours);
            } else {
                return LC.getLabel("Page_ReminderSettings", "hours", awayHours);
            }
        }
    } else {
        if (awayMins == 1) {
            return LC.getLabel("Page_ReminderSettings", "minute", awayMins);
        } else {
            return LC.getLabel("Page_ReminderSettings", "minutes", awayMins);
        }
    }
}

// Shows an activity link in the opener (if it still exists)
// or a new window.
ActivityReminder.showLink = function(url) {
    ActivityReminder._stopFlash = true; // Just kill flashing if user has clicked here.
    var openerClosed = true;
    try {
        // IE throws when accessing closed when opener gone.
        openerClosed = !window.opener || window.opener.closed || window.opener==window;
    } catch (e) {
    }
    if (openerClosed) {
        window.open(url, null, '', false);
    } else {
        // See if we're on a desktop.
        var mainFrame = window.opener.document.getElementById('mainFrame');
        if (mainFrame && mainFrame.tagName == 'IFRAME') {
            // Not available: showLoading('mainLoader', mainFrame);
            mainFrame.src = url + '?' + Desktop.IS_DESKTOP + '=mn';
        } else {
            window.opener.location = url;
        }
    }
}

// If there are no more reminders left after snooze/dismiss,
// then close the window.
ActivityReminder._closeIfEmpty = function() {
    var ct = 0;
    for (var i=0;;i++) {
        var item = document.getElementById("ids" + i);
        if (item) {
            ct++;
        } else {
            break;
        }
    }
    if (!ct) {
        // no more remain (dismiss 10ms later, o.w. form won't submit)
	    setTimeout("window.close()", 10);
    }
}

ActivityReminder._setupMeetingSummary = function() {
    // Mouse over any row selects the meeting summary:
    var r = getElementsByClassName('dataRow');
    for (rownum in r) {
        var row = r[rownum];
        var makeHandler = function(rn) {
            return function(event) {
                // The global handler, below, will
                // default the selection (when the
                // mouse isn't over a row).
                eventCancelBubble(event); // stop it.
                ActivityReminder._displayMeeting(rn);
            }
        };
        addEvent(row, 'mouseover', makeHandler(rownum));
    }
    var reminderForm = document.getElementById(ActivityReminderConstants.REMINDER_ID);
    var defaultSelector = function(event) {
        ActivityReminder._displayMeeting(); // no args.
    }
    // When the mouse isn't over one of the rows, have
    // it select the default (checked) one:
    addEvent(reminderForm, 'mouseover', defaultSelector);

    // Do initial selection:
    ActivityReminder._displayMeeting();
}

ActivityReminder._displayMeeting = function(rownum) {
    // If rownum not specified, use the first selected checkbox
    if (typeof rownum == 'undefined') {
        for (var i=0; ;i++) {
            var sel = document.getElementById("ids" + i);
            if (!sel) {
                rownum = 0; // just pick the first one, consistent w/ the initial display.
                break;
            }
            if (sel.checked) {
                rownum = i;
                break;
            }
        }
    }
    for (var i=0; ;i++) {
        var summary = document.getElementById(ActivityReminderConstants.SUMMARY_ID + i);
        if (!summary) {
            break;
        }
        summary.style.display = i==rownum ? 'block' : 'none';
    }
}

ActivityReminder._setupSnoozeDismiss = function() {
    for (var i=0; ;i++) {
        var sel = document.getElementById("ids" + i);
        if (!sel) {
            break;
        }
        addEvent(sel, 'click', ActivityReminder._reenableSnoozeDismiss);
    }
    var allBox = document.getElementById('allBox');
    if (allBox) { // If there are no items, can be empty.
        addEvent(allBox, 'click', ActivityReminder._reenableSnoozeDismiss);
    }
    ActivityReminder._reenableSnoozeDismiss();
}

ActivityReminder.updateBrowserTime = function() {
    // Sends the browsers time down for snooze command:
    document.getElementById(ActivityReminderConstants.pSNOOZED_AT).value = new Date().getTime();
}

ActivityReminder._reenableSnoozeDismiss = function() {
    var anyChecked = false;
    for (var i=0; ;i++) {
        var sel = document.getElementById("ids" + i);
        if (!sel) {
            break;
        }
        if (sel.checked) {
            anyChecked = true;
            break;
        }
    }
    var btnCls = anyChecked ? 'btn' : 'btnDisabled';
    document.getElementById(ActivityReminderConstants.SNOOZE_ID).disabled = !anyChecked;
    document.getElementById(ActivityReminderConstants.SNOOZE_ID).className = btnCls;
    document.getElementById(ActivityReminderConstants.SNOOZE_TIME_ID).disabled = !anyChecked;
    document.getElementById(ActivityReminderConstants.DISMISS_ID).disabled = !anyChecked;
    document.getElementById(ActivityReminderConstants.DISMISS_ID).className = btnCls;
    ActivityReminder._enableSnoozeOptions();
}

ActivityReminder._enableSnoozeOptions = function() {
    // Figure out nearest selected activity:
    var now = new Date().getTime();
    var minTimeAway;
    for (var i=0;;i++) {
        var el = document.getElementById(ActivityReminderConstants.DUE_MINUTES_ID + i);
        if (!el) {
            break;
        }
        var sel = document.getElementById("ids" + i);
        if (!sel.checked) {
            continue;
        }
        var time = el.getAttribute(ActivityReminderConstants.DUE_TIME_ATTR);
        var isAllDay = el.getAttribute(ActivityReminderConstants.ALL_DAY_ATTR);
        var away = time - now;
        if (!minTimeAway || minTimeAway > away) {
            minTimeAway = away;
        }
        if (isAllDay == "true") {
            minTimeAway = 0; // All day events/tasks can't be snoozed for 15 minutes before.
        }
    }

    // Figure out nearest selected activity:
    var snooze = document.getElementById(ActivityReminderConstants.SNOOZE_TIME_ID);
    var options = snooze.childNodes;

    var removedCurrentSelected = false;
    // Add/remove all the appropriate 'before' times:
    var leadOptions = [0, 5, 10, 15];
    for (var i=0; i < leadOptions.length; i++) {
        var val = leadOptions[i];
        var options = snooze.childNodes;

        // Find the existing one, if any:
        var existingOption = null;
        for (var li=options.length-1; li >= 0; li--) {
            var option = options[li];
            if (option.text && option.value == -val) {
                existingOption = option;
                break;
            }
        }
        if ((val + 1.5) * 60 * 1000 <= minTimeAway) { // 1.5 extra minutes since < 1 minute will reshow immediately.
            if (!existingOption) {
                var option = document.createElement('option');
                var label;
                if (val==0) {
                    label = LC.getLabel('Page_ReminderSettings', 'hours_before', val);
                } else {
                    label = LC.getLabel('Page_ReminderSettings', 'minutes_before', val);
                }
                var opttxt = document.createTextNode(label);
                option.appendChild(opttxt);
                option.value = -val; // negative indicates lead time.
                snooze.insertBefore(option, snooze.firstChild);
                removedCurrentSelected = true;
            }
        } else {
            // Should not be here:
            if (existingOption) {
                if (existingOption.selected == true) {
                    removedCurrentSelected = true;
                }
                snooze.removeChild(existingOption);
            }
        }
    }
    if (removedCurrentSelected == true) {
        // reselect the first one:
        var options = snooze.childNodes;
        for (var i=0; i< options.length; i++) {
            var option = options[i];
            if (option.text) {
                option.selected = 'true';
                break;
            }
        }
    }
}

ActivityReminder.selectAll = function() {
    for (var i=0; ;i++) {
        var sel = document.getElementById("ids" + i);
        if (!sel) {
            break;
        }
        sel.checked = true;
    }
}

ActivityReminder._wasFocused = function() {
    ActivityReminder._isBlur = false;
}

ActivityReminder._wasBlured = function() {
    ActivityReminder._isBlur = true;
}

ActivityReminder._pseudoFlash = function() {
    if (!ActivityReminder._originalTitle) {
        ActivityReminder._originalTitle = document.title;
    }
    var flashCount = ActivityReminder._flashCount;
    if (!flashCount) {
        flashCount = 1;
    } else {
        flashCount++;
    }
    ActivityReminder._flashCount = flashCount;
    var flashLimit = isNetscape ? 6 : 12; // Netscape grabs focus on setTitle, so flash shorter.
    // Netscape blur/focus events don't work well...
    if ((ActivityReminder._isBlur != true || ActivityReminder._stopFlash == true || isNetscape) && ActivityReminder._flashCount > flashLimit) {
        // Ok, the user has seen it, restore title & finish.
        document.title = ActivityReminder._originalTitle;
        return;
    }
    // Keep flashing:
    if (flashCount % 2 == 1) {
        document.title = LC.getLabel("Page_ActivityReminder", "new_flash");
    } else {
        document.title = ActivityReminder._originalTitle;
    }
    setTimeout('ActivityReminder._pseudoFlash()', 500);
}

ActivityReminder.testPopup = function() {
    // Note, 1500 below is not just a random #, Firefox won't consider it a popup unless the
    // # is > 1000 (it seems)
    setTimeout('ActivityReminder._showPopup(true)', 1500);
}

ActivityReminder._resizeToFitHorizontalChange = function() {
    if (!isIE) return;
    if (document.documentElement.clientWidth == ActivityReminder._oldWidth) {
        // need to prune for real changes.
        return;
    }
    ActivityReminder._oldWidth = document.documentElement.clientWidth;
    var els = getElementsByClassName('maxHorizontal');
    var clearedAny = false;
    for (var elnum in els) {
        var el = els[elnum];
        if (el.style.width && el.style.width != null) {
            el.style.width = null;
            clearedAny = true;
        }
    }
    if (clearedAny) {
        // Because we have already altered the document (by setting stylesheet),
        // we clear the style change (above), allow the browser (IE) to recompute the
        // size... then (later) we re-compute the max size fix.
        // This breaks badly if we don't do it later in a timeout -- the layout computations
        // seem to be in a partially complete state otherwise.
        window.setTimeout('ActivityReminder._resizeToFitHorizontal()', 100);
    }
}

ActivityReminder._resizeToFitHorizontal = function() {
    if (isNetscape && !isIE) { // Netscape not in IE mode:
        // Update stylesheet for netscape.
        var els = getElementsByClassName('maxHorizontal');
        var maxFoundWidth = 0;
        for (var elnum in els) {
            var el = els[elnum];
            var curWidth = el.offsetWidth;
            el.style.width = '200px'; // Table layout didn't work.
            el.style.overflow = 'hidden';
        }
        if (els[0]) {
            // Netscape doesn't support scrolling tbody.
            var tbody = els[0].parentNode.parentNode.parentNode;
            tbody.style.height = 'auto';
        }
        return;
    }
    if (!isIE) return;
    // With IE tables, it ignores whether overflow-x is set to hidden for any div inside a td, and just
    // uses as much horz. space as required.  Firefox will, if overflow-x is set to hidden, take up as much
    // horz. space as available & then hide the rest.
    // CSS doesn't seem to specify what to do here, but Firefox's behavior
    // is obviously much nicer.

    // Use the width of the related list el as the guide for how much space the table is taking up:
    var relatedListEl = getElementsByClassName('bRelatedList')[0];
    var relatedListTableEl = getElementsByClassName('list')[0];
    // In IE6, the relatedListEl has the full used width, but in IE7 only the table has it.
    // Because of other differences in sizing, use offset width (which will be greater in IE6).
    var tableBasedOffsetWidth = relatedListTableEl.offsetWidth + 4; // extra pixels for borders, etc.
    var offsetWidth;
    if (relatedListEl.offsetWidth < tableBasedOffsetWidth) {
        // oversize IE7
        offsetWidth = tableBasedOffsetWidth;
    } else {
        // not oversized or IE6.
        offsetWidth = relatedListEl.offsetWidth;
    }

    var extraWidth = document.documentElement.clientWidth - offsetWidth;
    var minWidth = 100;
    if (extraWidth != 0) {
        var newWidth;
        var els = getElementsByClassName('maxHorizontal');
        var maxFoundWidth = 0;
        for (var elnum in els) {
            var el = els[elnum];
            var curWidth = el.offsetWidth;
            maxFoundWidth = Math.max(maxFoundWidth, curWidth);
        }
        newWidth = Math.max(minWidth, maxFoundWidth + extraWidth);
        for (var elnum in els) {
            var el = els[elnum];
            var curWidth = el.offsetWidth;
            el.style.width = newWidth + 'px';
        }
    }
}

/**
* Contains general utility function for traversing & manipulating the DOM
*
* @author mpolcari
* @since 142.ml
*/
function DomUtil() {}

/**
* applies a function (funk) to node & all of its children
* this results in a depth-first search which
* ends when funk returns a true value
*
* It is a half-assed X-path
*/
DomUtil.walkDomTreeApplyingFunction = function(node, funk) {
  if (!node) return null;
  var ans = funk(node);
  if (ans) {
     return ans;
  } else if (node.firstChild) {
    for (var i = 0; i < node.childNodes.length; i++) {
      ans = DomUtil.walkDomTreeApplyingFunction(node.childNodes[i], funk);
      if (ans) {
        return ans;
      }
    }
  }
  return null;
}

/* stops at the first one */
DomUtil.findDescendantWithProperty = function(startNode, property, value, caseInSensitive) {
  if (caseInSensitive) {
    var lowerVal = value.toLowerCase();
    return DomUtil.walkDomTreeApplyingFunction(startNode, function(node) {
      if (node[property] && node[property].toLowerCase && (node[property].toLowerCase() == lowerVal)) {
        return node;
      } else {
        return null;
      }
    });
  } else {
    return DomUtil.walkDomTreeApplyingFunction(startNode, function(node) {
      if ((node[property] == value)) {
        return node;
      } else {
        return null;
      }
    });
  }
}

/* similar to getElementsByTagName, but just returns the first one */
DomUtil.findDescendantWithTag = function(startNode, tagType) {
  return DomUtil.findDescendantWithProperty(startNode, 'tagName', tagType, true);
}

/* returns only the first one we encounter in a depth-first search */
DomUtil.findDescendantWithClassName = function(startNode, className) {
  if (!className) return;
  var spacedClass = ' ' + className + ' ';
  return DomUtil.walkDomTreeApplyingFunction(startNode, function(node) {
      if (node.className && ((' ' + node.className + ' ').indexOf(spacedClass) > -1)) {
        return node;
      } else {
        return null;
      }
    });
}

/* imports a shallow copy of the node.  If you want a deep copy, copy the innerHTML */
DomUtil.importNode = function(node, targetDocument) {
  if (!node) { Gack.sendGack("invalid Node"); return; }
  if (targetDocument.importNode) { //every reasonable browser on the planet
    return targetDocument.importNode(node, false);
  } else { //ie6
    var copy = targetDocument.createElement(node.tagName);
    for (var at = 0; at < node.attributes.length; at++) {
       if (node.attributes[at].specified) {
           copy.setAttribute(node.attributes[at].name, node.attributes[at].value);
        }
    }
    return copy;
  }
}

DomUtil.copyScripts = function (srcDoc, targetDoc) {
      var targetHead = targetDoc.body.parentNode.firstChild;
      var scripts = srcDoc.getElementsByTagName("SCRIPT");
      var scriptElement;
      for (var i = 0, script; i < scripts.length; i++){
        script = scripts[i];
        if (script.src) { //just copy in functions.js and its ilk
          scriptElement = targetDoc.createElement("script");
          scriptElement.src = script.src
          targetHead.appendChild(scriptElement);
       //   iFrameHead.appendChild(DomUtil.importNode(script, iFrameDoc));  this wasn't working in ffox ?
        }
      }
}

DomUtil.copyCSS = function (srcDoc, targetDoc, apiVersion) {
      var targetHead = targetDoc.body.parentNode.firstChild;
      for (var i = 0, sheet; i < srcDoc.styleSheets.length; i++){
        sheet = srcDoc.styleSheets[i];
        var newNode;
        if (sheet.ownerNode) {
          newNode = DomUtil.importNode(sheet.ownerNode, targetDoc);
        } else {
          newNode = DomUtil.importNode(sheet.owningElement, targetDoc);
        }
        if (apiVersion && newNode.href && newNode.href.replace) {
          newNode.href = newNode.href.replace('/sCSS/', '/sCSS' + apiVersion + '/');
        }
        targetHead.appendChild(newNode);
      }
}

DomUtil.copyScriptsCssBodyClass = function (srcDoc, targetDoc) { //Copy css styleSheets, script includes, & body.className
  DomUtil.copyCSS(srcDoc, targetDoc);
  DomUtil.copyScripts(srcDoc, targetDoc);
  targetDoc.body.className = srcDoc.body.className;
}

DomUtil.setHelpLink = function (doc, url, helpTarget, helpSection) {
  if (helpTarget && helpSection){
     url = "/help/doc/user_ed.jsp?loc=help&target="+helpTarget+"&section="+helpSection;
  }
  var link = DomUtil.findDescendantWithClassName(doc, 'helpLink');
  if (link){
    var par = link.parentNode;
    if (par && par.href && par.href.indexOf("openPopupFocusEscapePounds") > 0){
        par.href = par.href.replace(/'.*?'/, "'"+url+"'");
    }
  }
}


/**
 *  ActivityHover.js, extends Hover class, and is used for Activities such as Events and Tasks
 *
 *  @author eli
 *  @since 146 (rewrite of 144 code in functions.js)
 */

ActivityHover.prototype = new Hover();

function ActivityHover() {
}

ActivityHover.getHover = function(elementId) {
    var hover = Hover.hoverMap[elementId];
    if (typeof hover == 'undefined') {
		return Hover.createHover(new ActivityHover(), elementId);
    }
    return hover;
}

ActivityHover.prototype.loadHook_afterLoad = function() {
    var contentObj = getElementByIdCS(this.eid + "_content");
    var pbSubsectionObj = DomUtil.findDescendantWithClassName(contentObj, 'pbSubsection');
    if (pbSubsectionObj) {
        var detailListObj = DomUtil.findDescendantWithClassName(pbSubsectionObj, 'detailList');

        // Increase width of hover if the contents are too big to fit inside
        if (Hover.getElementWidth(detailListObj) > Hover.getElementWidth(pbSubsectionObj)) {
            var diff = Hover.getElementWidth(detailListObj) - Hover.getElementWidth(pbSubsectionObj);
            contentObj.style.width = (Hover.getElementWidth(contentObj) + diff) + 'px';
            pbSubsectionObj.style.width = Hover.getElementWidth(detailListObj) + 'px';
        }
    }
}

ActivityHover.prototype.setXPos = function(x) {
	var minX = this.getMinX();
	var maxX = this.getMaxX();

    /** Implements a 75px wide 'safezone' where a hover will never appear so that it doesn't cover up the element
     *  If maxX is below this safezone position, then the maxX is adjusted to the left of the element,
     *  and if x is below the safezone line, then we move that as our mouse position. Then if x>maxX, we move x back down
     *  to the max so the hover doesn't go too far right or cover up our safezone.
     *  Also implements an expanding hover that will expand in case the contents do not fit inside the box. This will happen in
     *  the case of long character strings that dont break up into mulitple lines.
     */
    var srcEleWidth = this.xObjRight-this.xObjLeft;
    var offset = (srcEleWidth < 75) ? srcEleWidth : 75;

    var maximum = Math.max(this.xObjLeft - minX, maxX + Hover.getElementWidth(this.ele) - this.xObjLeft - offset);
    if (maximum < 200) maximum = 200;

    if (Hover.getElementWidth(this.ele) > maximum) {
        var contentObj = getElementByIdCS(this.eid + "_content");
        var pbSubsectionObj = DomUtil.findDescendantWithClassName(contentObj, 'pbSubsection');
        // Skip over this code if there is no detail layout hover
        if (pbSubsectionObj) {
            var contentSubsectionDiff = Hover.getElementWidth(contentObj) - Hover.getElementWidth(pbSubsectionObj);
            var hoverContentDiff = Hover.getElementWidth(this.ele)-Hover.getElementWidth(contentObj);
            contentObj.style.width = (maximum - hoverContentDiff) + 'px';
            pbSubsectionObj.style.width = (Hover.getElementWidth(contentObj) - contentSubsectionDiff) + 'px';
            /* This prevents bad behavior on extremely small screens. If the hover did not get reduced to the correct width
             * it'll expand the contents to the size of the hover.
             */
            if (Hover.getElementWidth(this.ele) > maximum) {
                contentObj.style.width = (Hover.getElementWidth(this.ele)-hoverContentDiff) + 'px';
                pbSubsectionObj.style.width = (Hover.getElementWidth(contentObj) - contentSubsectionDiff) + 'px';
            }
            // recalculate maxX since width changed
            maxX = assureInt((Hover.documentBody && Hover.documentBody.clientWidth)? Hover.documentBody.clientWidth : window.innerWidth) +
                assureInt(window.pageXOffset || (Hover.documentBody? Hover.documentBody.scrollLeft : 0) || 0) - Hover.getElementWidth(this.ele);
        }
    }
    if (maxX < this.xObjLeft+offset) maxX = this.xObjLeft - Hover.getElementWidth(this.ele);
    if (x < this.xObjLeft+offset) x = this.xObjLeft+offset;

    if (x > maxX) x = Math.max(minX, maxX);
    this.xCoord = x;
}

/**
 * TreeNodeElement.js works like a class with lots of static methods.
 */

var TreeNodeElement = function(){}

// static definitions of images used in TreeNodeElement
TreeNodeElement.prototype.collapsedWidget = new Image(20, 16);
TreeNodeElement.prototype.collapsedWidget.src = "/img/tree/plus.gif";
TreeNodeElement.prototype.collapsedWidgetStart = new Image(20, 16);
TreeNodeElement.prototype.collapsedWidgetStart.src = "/img/tree/plusStart.gif";
TreeNodeElement.prototype.collapsedWidgetEnd = new Image(20, 16);
TreeNodeElement.prototype.collapsedWidgetEnd.src = "/img/tree/plusEnd.gif";
TreeNodeElement.prototype.expandedWidget = new Image(20, 16);
TreeNodeElement.prototype.expandedWidget.src = "/img/tree/minus.gif";
TreeNodeElement.prototype.expandedWidgetStart = new Image(20, 16);
TreeNodeElement.prototype.expandedWidgetStart.src = "/img/tree/minusStart.gif";
TreeNodeElement.prototype.expandedWidgetEnd = new Image(20, 16);
TreeNodeElement.prototype.expandedWidgetEnd.src = "/img/tree/minusEnd.gif";

// retrieve matching version of 'minus' images
TreeNodeElement.prototype.getExpandedWidgetState = function(imgURL) {
    if (imgURL.indexOf("Start") != -1) {
        return TreeNodeElement.prototype.expandedWidgetStart.src;
    }
    if (imgURL.indexOf("End") != -1) {
        return TreeNodeElement.prototype.expandedWidgetEnd.src;
    }
    return TreeNodeElement.prototype.expandedWidget.src;
}

// retrieve matching version of 'plus' images
TreeNodeElement.prototype.getCollapsedWidgetState = function(imgURL) {
    if (imgURL.indexOf("Start") != -1) {
        return TreeNodeElement.prototype.collapsedWidgetStart.src;
    }
    if (imgURL.indexOf("End") != -1) {
        return TreeNodeElement.prototype.collapsedWidgetEnd.src;
    }
    return TreeNodeElement.prototype.collapsedWidget.src;
}

TreeNodeElement.prototype.toggle = function(img, blockNum) {
   var obj = document.getElementById(blockNum);
   if (obj != null) {
       visible=(obj.style.display != "none")
       if (visible) {  //Toggle to invisible
         obj.style.display="none";
         img.src = TreeNodeElement.prototype.getCollapsedWidgetState(img.src);
       }
       else {
          obj.style.display="block";
          img.src =  TreeNodeElement.prototype.getExpandedWidgetState(img.src);
       }
   }
}

function LayoutMappingHelper() {
}

LayoutMappingHelper.getCellId = function (profileId, recordTypeId) {
	return profileId + "_" + recordTypeId;
}

LayoutMappingHelper.getCellProfileId = function (cell) {
	var id = cell.id;
	if (!id) {
		return null;
	}
	return id.substring(0, id.indexOf("_"));
}

LayoutMappingHelper.getCellRecordTypeId = function (cell) {
	var id = cell.id;
	if (!id) {
		return null;
	}
	return id.substring(id.indexOf("_") + 1);
}

LayoutMappingHelper.selectCellById = function (id) {
	var el = getElementByIdCS(id);
	if (el) {
		if (el.className.indexOf("selectedCell") < 0) {
			el.className += " selectedCell";
			// el.style.backgroundColor = '#D0D0FF';
		}
	}
}

LayoutMappingHelper.deselectCellById = function (id) {
	var el = getElementByIdCS(id);
	if (el) {
		el.className = el.className.replace(/selectedCell/,"");
	}
}


LayoutMappingHelper.changeCellById = function (id) {
	var el = getElementByIdCS(id);
	if (el) {
		if (el.className.indexOf("changedCell") < 0) {
			el.className += " changedCell";
		}
	}
}


LayoutMappingHelper.resetCellById = function (id) {
	var el = getElementByIdCS(this.getCellId(profileId, recordTypeId));
	if (el) {
		el.className = el.className.replace(/selectedCell/,"");
		el.className = el.className.replace(/changedCell/,"");
	}
}

LayoutMappingHelper.getIndex = function (idNameArr, id) {
	if (!idNameArr || !idNameArr.length || idNameArr.length == 0) {
		return -1;
	}
	for (var i = 0; i < idNameArr.length; i++) {
		if (idNameArr[i].id == id) {
			return i;
		}
	}
	return -1;
}

LayoutMappingHelper.isProfileHeader = function (id) {
	if (!id) {
		return false;
	}
	if (id.indexOf('00e') == 0) {
		return true;
	}
	return false;
}
/**
 * @author zzhou
 * @since 150
 *
 * the javascript for the Forecast Sharing enabling/disabling dialog boxes on the Forecast Settings page
 **/

   function FctSettingsPage() {}
   function FctShareDialog() {}

   FctSettingsPage.fctShareFormSubmit = false;
   FctShareDialog.allowMgrShare = '0';

   //check to see if we submit the form or not
   FctSettingsPage.submitCheck = function(url,isFctShareEnabled) {
        if (validateForm()) {
            FctSettingsPage.fctShareFormSubmit = (isFctShareEnabled == document.getElementById(ForecastSettings.pFORECAST_SHARING).checked);
            if (FctSettingsPage.fctShareFormSubmit) {
                return true;
            } else {
                openPopupFocus(url, 'fctSharingDialog', 300, 500,'height=350,width=600,location=no,dependent=no,resizable=no,toolbar=no,status=yes,directories=no,menubar=no,scrollbars=no', true, true, true);
                return false;
            }
        } else {
            return false;
        }
   }

   FctShareDialog.checkSaveButton = function(checkCheckBox) {
        var checked;
        if (checkCheckBox) {
            checked = document.getElementById(ForecastSharingPrefPopup.DISABLE_CHECKBOX).checked;
        } else {
            checked = document.getElementsByName(ForecastSharingPrefPopup.CAN_SHARE_RADIO)[0].checked || document.getElementsByName(ForecastSharingPrefPopup.CAN_SHARE_RADIO)[1].checked;
        }

        //check if any of the input values are checked so that we allow the user to save by enabling the save button
        if (checked) {
            document.getElementsByName("save")[0].className = 'btn';
            document.getElementsByName("save")[0].disabled = false;
            document.getElementsByName("save")[0].onclick = function() {FctShareDialog.saveResult(true)};
            if (!checkCheckBox) {
                FctShareDialog.allowMgrShare = document.getElementsByName(ForecastSharingPrefPopup.CAN_SHARE_RADIO)[1].checked ? '1' : '0';
            }
        } else {
            document.getElementsByName("save")[0].className = 'btnDisabled';
            document.getElementsByName("save")[0].disabled = true;
        }
   }

   FctShareDialog.saveResult = function(doSave) {
        if (doSave) {
            window.opener.FctSettingsPage.submit(FctShareDialog.allowMgrShare);
        }
        window.close();
   }

   FctSettingsPage.submit = function(allowMgrShare) {
        //simluate clicking on the button to save
        var qs = new QueryString("");
        document.getElementById(ForecastSettings.pALLOW_FM_SHARING).value = allowMgrShare;
        qs.add(EditPageConstants.pSAVE, "Save");
        document.forms[EditPageConstants.pEDIT_PAGE].action += qs.toString();
        document.forms[EditPageConstants.pEDIT_PAGE].submit();
   }




/**
 * RoleTreeNodeElement handles loading/caching of roles in tree. 
 */

var RoleTreeNodeElement = function(){
    this.openRoleList = new Array(); 
    this.downloadedRoles = new Array();
    this.downloadedAll = false;
    this.treeFormName = null;
}

// called from various java files, typically in a Java-defined
// javascript call, "initializeRoles()"
RoleTreeNodeElement.prototype.init = function(isDownloadedAll, openRoleNodes) {

    this.downloadedAll = isDownloadedAll;
    if (openRoleNodes != null){
        this.openRoleList = openRoleNodes.split(":");
        this.downloadedRoles = openRoleNodes.split(":");
    }
}

RoleTreeNodeElement.prototype.addToOpenRoles = function(item) {
    for (var i = 0; i < this.openRoleList.length; i++) {
        if (this.openRoleList[i] == null || this.openRoleList[i] == '') {
            this.openRoleList[i] = item;    
            this.updateCookiesRole();
            return;     
        }
    }
    this.openRoleList[this.openRoleList.length] = item;
    this.updateCookiesRole();
}

RoleTreeNodeElement.prototype.isInDownloadedRoles = function(item) {
    if (item == '000000000000000') {
        return true;
    }
    
    for (var i = 0; i < this.downloadedRoles.length; i++) {
        if (this.downloadedRoles[i] == item) {
            return true;
        }
    }
    return false;
}    

RoleTreeNodeElement.prototype.removeFromOpenRoles = function(item) {   
    for (var i = 0; i < this.openRoleList.length; i++) {
        if (this.openRoleList[i] == item) {
            this.openRoleList[i] = null;            
        }
    }
    this.updateCookiesRole();
}

RoleTreeNodeElement.prototype.updateCookiesRole = function() {
    var stringlist = "";
    for (var i = 0; i < this.openRoleList.length; i++) {
        if (this.openRoleList[i] != null && this.openRoleList[i] != '') {
            stringlist = stringlist + this.openRoleList[i] + ":";
        }
    }
    Cookies.prototype.SetCookie(RoleTreeCookieConstants.COOKIE_KEY, stringlist, null, "/");     
}

RoleTreeNodeElement.prototype.toggleRoles = function(img, blockNum, roleId) {
   var obj = document.getElementById(blockNum);
   if (obj != null) {
       visible=(obj.style.display != "none")
       if (visible) {  //Toggle to invisible
         obj.style.display = "none";
         img.src = TreeNodeElement.prototype.getCollapsedWidgetState(img.src);
         this.removeFromOpenRoles (roleId);
       }
       else {
          this.addToOpenRoles (roleId);  
          if (this.downloadedAll || this.isInDownloadedRoles (roleId)) {
              obj.style.display = "block";
              img.src = TreeNodeElement.prototype.getExpandedWidgetState(img.src);
          } else {
              this.refreshTree();
          }
       }
   }
}

RoleTreeNodeElement.prototype.collapseAllRoles = function() {
    Cookies.prototype.SetCookie(RoleTreeCookieConstants.COOKIE_KEY, "", null, "/");     
    this.refreshTree();
}

RoleTreeNodeElement.prototype.expandAllRoles = function() {
    Cookies.prototype.SetCookie(RoleTreeCookieConstants.COOKIE_KEY, "EXPANDALL", null, "/");     
    this.refreshTree();
} 

// This is called staticall from TerritoryTreeMultiSelect.java 
// and SelectTargetTerritoryStage.java
RoleTreeNodeElement.prototype.setTreeFormName = function(name) {
	this.treeFormName = name;
}

RoleTreeNodeElement.prototype.refreshTree = function() {
	if (this.treeFormName == null) {
    	window.location.replace(window.location.href);
	} else {
		window.document.forms[this.treeFormName].submit();
	}
}

function BrowserSettingsWarning() {
	var warning = this;
	if (window.sfdcPage) {
		window.sfdcPage.appendToOnloadQueue(function() {warning.init();});
	}
}
		
BrowserSettingsWarning.DO_NOT_ASK_AGAIN_EXPIRY = 60; // 2 months

BrowserSettingsWarning.prototype.init = function() {
	var browserSettingsWarning = this;
	var neverAgain = document.getElementById(BrowserSettingsWarningElement.NEVER_SHOW_AGAIN_ID);
	addEvent(neverAgain, "click" , function(e) {
		 browserSettingsWarning.neverShowAgain(); 
		 return false;
		 }, false);
	var moreInfo =  document.getElementById(BrowserSettingsWarningElement.MORE_INFO_ID);
	addEvent(moreInfo, "click" , function(e) {
		 Cookies.prototype.SetCookie(BrowserSettingsWarningElement.cBrowserSettings, "0", new Date(), "/");
		 browserSettingsWarning.hideElement(); 
		 }, false);
}

BrowserSettingsWarning.prototype.neverShowAgain = function() {
	var expiryDate = new Date();
    expiryDate.setDate(expiryDate.getDate() + BrowserSettingsWarning.DO_NOT_ASK_AGAIN_EXPIRY);
						//	name, value, expires, path, domain
	Cookies.prototype.DeleteCookie(BrowserSettingsWarningElement.cBrowserSettings);
	Cookies.prototype.SetCookie(BrowserSettingsWarningElement.cBrowserSettings, "-1", expiryDate, "/");
	this.hideElement();
}

BrowserSettingsWarning.prototype.hideElement = function() {
	document.getElementById(BrowserSettingsWarningElement.BROWSER_SETTINGS_WARNING_ID).style.display = 'none';
}
/**
 * Extension of Paginator.js that includes a hover
 * toolbar.  Used in the ListViewport.
 * 
 * @author jtroup
 * @since 154
 */
function ListPaginator(args) {
	this.init(args);
}

ListPaginator.prototype = new Paginator();

ListPaginator.opts = [10, 25, 50, 100, 200];
ListPaginator.rppId = "_rpp";
ListPaginator.selectionId = "_selection";
ListPaginator.target = "_target";

ListPaginator.prototype.init = function(args) {
	this.listId = args["listId"];
	this.id = this.listId + "_paginator";
	
	Paginator.addPaginator(this);

	this.containerIds = args["containerIds"];
	this.handler = args["handler"];

	this.ref = "Paginator.instances['" + this.id + "']";
	this.listRef = "ListViewport.instances['" + this.listId + "']";

    var self = this;
    var f = function(e) {
                var target = getEventTarget(e);
                if (target.id != self.id + ListPaginator.rppId + ListPaginator.target &&
                	target.parentNode.id != self.id + ListPaginator.rppId + ListPaginator.target) {
                    ListPaginator.hideSelector(self.id + ListPaginator.rppId + ListPaginator.target);
                }
                if (target.id != self.id + ListPaginator.selectionId + ListPaginator.target &&
                	target.parentNode.id != self.id + ListPaginator.selectionId + ListPaginator.target) {
                    ListPaginator.hideSelector(self.id + ListPaginator.selectionId + ListPaginator.target);
                }
            }
    addEvent(document.body, "mousedown", f, true);

	this.selectedOnThisPage = 0;
	this.selectCount = 0;

	this.setState(args);
}

ListPaginator.prototype.setSelectCount = function(num) {
	this.selectCount = num;
	
	this.draw();
}

ListPaginator.prototype.setState = function(args) {
    this.currentPage = parseInt(args["currentPage"]) || this.currentPage || 1;
    this.recordsPerPage = parseInt(args["recordsPerPage"]) || this.recordsPerPage || 50;
    this.totalRecords = parseInt(args["totalRecords"]);
    this.capped = args["capped"];
    
    if (!this.capped) {
        this.totalPages = Math.ceil(this.totalRecords / this.recordsPerPage);
    } else {
        this.totalPages = null;
    }

    this.startingRecord = (this.currentPage-1)*this.recordsPerPage + 1;

    if (!args["nodraw"]) {
        var self = this;
        if (this.totalRecords === 0) {
        	window.sfdcPage.appendToOnloadQueue(function() {self.draw(true);});
        } else {
        	window.sfdcPage.appendToOnloadQueue(function() {self.draw();});
        }
    }
}

ListPaginator.prototype.draw = function(empty) {
	var html = [];
    html.push("<div class='paginator'>");

	html.push("<span class='left'>");
	if (empty) {
		html.push("&nbsp;");
	} else {
		html.push(this.getRecordCounts());
		html.push(this.getSelectedCount());
	}
	html.push("</span>");
	
	if (empty) {
		html.push("&nbsp;");
	} else {
		html.push(this.getPrevNextLinks());		
	}

	html.push("<span class='right'>");
	if (empty) {
		html.push("&nbsp;");
	} else {
		html.push(this.getPageXofY());
	}
	html.push("</span>");

	html.push("</div>");
	html.push("<div class='clearingBox'/>");

	for(var i=0; i < this.containerIds.length; i++) {
		document.getElementById(this.containerIds[i]).innerHTML = html.join('');
	}
}

ListPaginator.keyHandle = function(e) {
    if (window.ActiveXObject && e.keyCode == KEY_ENTER) {
        getEventTarget(e).onchange();
    }
}

ListPaginator.prototype.getPageXofY = function() {
	var html = [];
	html.push(LC.getLabel("Paginator", "page"));
	if (this.totalPages) {
		html.push("<input class='pageInput' maxlength='4' onchange=\"");
		html.push(this.ref);
		html.push(".goToPage(this.value)\"");
		html.push(" onkeydown=\"");
        html.push("ListPaginator.keyHandle(event)\"");
		html.push(" value='");
		html.push(this.currentPage);
		html.push("'>");
		html.push(LC.getLabel("Paginator", "of", this.totalPages));
	} else {
		html.push("&nbsp;");
		html.push(this.currentPage);
	}
	return html.join('');
}

ListPaginator.prototype.getRecordCounts = function() {
	if (this.totalRecords === 0) {
		return "0";
	} else {
		var html = [];
		html.push("<span class='selectorTarget'");
		html.push(" id='")
		html.push(this.id + ListPaginator.rppId + ListPaginator.target);
		html.push("'");
		html.push(" onmousedown=\"");
		html.push("ListPaginator.showSelector('");
		html.push(this.id + ListPaginator.rppId + ListPaginator.target);
		html.push("')\"");
		html.push(" onmouseover=\"");
		html.push("ListPaginator.hoverSelector(this)");
		html.push("\"");
		html.push(" onmouseout=\"");
		html.push("ListPaginator.unhoverSelector(this)");
		html.push("\"");
		html.push(">");
		html.push(this.startingRecord);
		html.push("-");
	
		this.lastRecord = 0;
		if(!this.capped) {
			this.lastRecord = Math.min((this.startingRecord + this.recordsPerPage - 1),this.totalRecords);
		} else {
			this.lastRecord = this.startingRecord + this.recordsPerPage - 1;
		}
		html.push(this.lastRecord);
		if (!this.capped) {
			html.push(" ");
			html.push(LC.getLabel("Paginator", "of", this.totalRecords));
		} else {
		    html.push(" ");
            html.push(LC.getLabel("Paginator", "of", this.totalRecords + "+"));
		}
		html.push(this.getRppSelector());
		html.push("<img class='selectArrow' src='/s.gif' />");
		html.push("</span>");
	
		return html.join('');
	}
}

ListPaginator.prototype.getPrevNextLinks = function() {
	var html = [];
	var jscall = "";

	html.push("<span class='prevNextLinks'>");

	html.push("<span class='prevNext'>");
	// <<
	if (this.currentPage != 1) {
		jscall = this.ref + ".goToPage(1)";
		html.push("<a href=\"javascript:");
		html.push(jscall);
		html.push("\">");
		html.push("<img src='/s.gif' class='first'>");
		html.push("</a>");
	} else {
		html.push("<img src='/s.gif' class='firstoff'>");
	}
	html.push("</span>");

	html.push("<span class='prevNext'>");
	// < Previous
	if (this.currentPage != 1) {
		jscall = this.ref + ".goToPage(" + (this.currentPage-1) + ")";
		html.push("<a href=\"javascript:");
		html.push(jscall);
		html.push("\">");
		html.push("<img src='/s.gif' class='prev'>");
		html.push(LC.getLabel("Paginator", "previous"));
		html.push("</a>")
	} else {
		html.push("<img src='/s.gif' class='prevoff'>");
		html.push(LC.getLabel("Paginator", "previous"));
	}
	html.push("</span>");

	html.push("<span class='prevNext'>");
	// Next >
	if (this.capped || (this.totalPages && this.currentPage != this.totalPages)) {
		jscall = this.ref + ".goToPage(" + (this.currentPage+1) + ")";
		html.push("<a href=\"javascript:");
		html.push(jscall);
		html.push("\">");
		html.push(LC.getLabel("Paginator", "next"));
		html.push("<img src='/s.gif' class='next'>");
		html.push("</a>");
	} else {
		html.push(LC.getLabel("Paginator", "next"));
		html.push("<img src='/s.gif' class='nextoff'>");
	}
	html.push("</span>");

	html.push("<span class='prevNext'>");
	// >>
	if (this.totalPages && this.currentPage != this.totalPages) {
		jscall = this.ref + ".goToPage(" + this.totalPages + ")";
		html.push("<a href=\"javascript:");
		html.push(jscall);
		html.push("\">");
		html.push("<img src='/s.gif' class='last'>");
		html.push("</a>");
	} else {
		html.push("<img src='/s.gif' class='lastoff'>");
	}
	html.push("</span>");

	html.push("</span>");

	return html.join('');
}

ListPaginator.prototype.getSelectedCount = function() {
	var html = [];
	html.push("<span class='selectorTarget selectCount");
	if (this.selectCount > 0) {
		html.push(" selectCountHi");
	}
	html.push("' id='")
	html.push(this.id + ListPaginator.selectionId + ListPaginator.target);
	html.push("'");
	html.push(" onmousedown=\"");
	html.push("ListPaginator.showSelector('");
	html.push(this.id + ListPaginator.selectionId + ListPaginator.target);
	html.push("')\"");
	html.push(" onmouseover=\"");
	html.push("ListPaginator.hoverSelector(this)");
	html.push("\"");
	html.push(" onmouseout=\"");
	html.push("ListPaginator.unhoverSelector(this)");
	html.push("\"");
	html.push(">");
	html.push(this.selectCount);
	html.push(" ");
	html.push(LC.getLabel("Paginator", "selected"));
	html.push(this.getSelectionSelector());
	html.push("<img class='selectArrow' src='/s.gif' />");
	html.push("</span>");
	
	return html.join('');
}

ListPaginator.prototype.goToPage = function (pageNum) {
	if (isNaN(pageNum) || pageNum < 1) {
		pageNum = 1;
    } else if (this.totalPages && pageNum > this.totalPages) {
		pageNum = this.totalPages;
	}

	if (this.handler)
		this.handler(pageNum);
}

ListPaginator.prototype.getRppSelector = function() {
    var html = [];
   	html.push("<table cellpadding='0' cellspacing='0' class='selector rpp' id='");
   	html.push(this.id + ListPaginator.rppId + "'>");

	var opts = ListPaginator.opts;
	for (var i=0; i<opts.length; i++) {
	    var selected = opts[i] == this.recordsPerPage;
        var clazz = selected ? 'optSelected' : 'optUnselected';
        
       	html.push("<tr");
       	html.push(" class='opt ");
       	html.push(clazz);
       	html.push("'");
        html.push(" onmouseover=\"");
		html.push("if (this.className.indexOf('optHover') < 0) { this.className += ' optHover' }");
        html.push("\"");
		html.push(" onmouseout=\"");
		html.push("this.className = this.className.replace('optHover', '')");
		html.push("\"");
		html.push(" onmousedown=\"");
        html.push(this.listRef);
        html.push(".getListData({")
        html.push("rowsPerPage: ");
        html.push(opts[i]);
        html.push(", rolodexIndex: ");
        html.push(this.listRef);
        html.push(".rolodexIndex")
        html.push("})");
		html.push("\">");
        html.push("<td class='optUnselected'>");
        html.push(LC.getLabel("Paginator", "display"));
        html.push("</td>");
        html.push("<td class='rppOpt'>");
       	html.push(opts[i]);
       	html.push("</td>");
        html.push("<td class='optUnselected'>");
        html.push(LC.getLabel("Paginator", "rpp"));
        html.push("</td>");
       	html.push("</tr>");
	}
   	
   	html.push("</table>");
	
	return html.join('');
}

ListPaginator.prototype.getSelectionSelector = function() {
    var html = [];
    var smRef = this.listRef + ".grid.getSelectionModel()";
    
    var recordsOnPage = this.lastRecord - this.startingRecord + 1;
    var notSelectedOnPage = recordsOnPage - this.selectedOnThisPage;
    
    var opts = [{label: LC.getLabel("Paginator", "select_page", "+" + notSelectedOnPage), handler: smRef + ".selectAll()"},
                {label: LC.getLabel("Paginator", "deselect_page", "-" + this.selectedOnThisPage), handler: smRef + ".clearSelections()"},
                {label: LC.getLabel("Paginator", "clear_all_selections", "-" + this.selectCount), handler: smRef + ".clearAllSelections()"}];
    
    html.push("<div class='selector selection' id='");
    html.push(this.id + ListPaginator.selectionId + "'>");
    for (var i=0; i< opts.length; i++) {
        html.push("<div");
        html.push(" class='opt'");
        html.push(" onmouseover=\"");
    	html.push("if (this.className.indexOf('optHover') < 0) { this.className += ' optHover' }");
        html.push("\"");
    	html.push(" onmouseout=\"");
    	html.push("this.className = this.className.replace('optHover', '')");
    	html.push("\"");
    	html.push(" onmousedown=\"");
        html.push(opts[i].handler);
    	html.push("\">");
    	html.push(opts[i].label);
    	html.push("</div>");
    }
	html.push("</div>");
	
	return html.join('');
}

ListPaginator.showSelector = function(id) {
	var el = document.getElementById(id);
	if (el && el.className.indexOf(" selectorOpen") < 0) {
        el.className += " selectorOpen";
	}
}

ListPaginator.hideSelector = function(id) {
	var el = document.getElementById(id);
	if (el) {
	    el.className = el.className.replace(" selectorOpen", "");
	}
}

ListPaginator.hoverSelector = function(el) {
    if (el.className.indexOf(" selectorHover") < 0) {
        el.className += " selectorHover";
    }
}

ListPaginator.unhoverSelector = function(el) {
    el.className = el.className.replace(" selectorHover", "");
}

/**
 * Utility to save open/closed state of setup in browser cookies. 
 * The starting state of the setup tree is initialized in 
 * SetupPageHeader.java, which generates the value for openListSetup below.
 */

var SetupTreeNode = function(){}

// this variable is also referenced in SetupPageHeader.java
SetupTreeNode.prototype.openListSetup = new Array();

SetupTreeNode.prototype.addToOpenSetup = function(item) {
    for (var i = 0; i < SetupTreeNode.prototype.openListSetup.length; i++) {
        if (SetupTreeNode.prototype.openListSetup[i] == null) {
            SetupTreeNode.prototype.openListSetup[i] = item;    
            SetupTreeNode.prototype.updateCookiesSetup();
            return;     
        }
    }
    SetupTreeNode.prototype.openListSetup[SetupTreeNode.prototype.openListSetup.length] = item;
    SetupTreeNode.prototype.updateCookiesSetup();
}

SetupTreeNode.prototype.removeFromOpenSetup = function(item) {   
    for (var i = 0; i < SetupTreeNode.prototype.openListSetup.length; i++) {
        if (SetupTreeNode.prototype.openListSetup[i] == item) {
            SetupTreeNode.prototype.openListSetup[i] = null;            
        }
    }
    SetupTreeNode.prototype.updateCookiesSetup();
}

// class structure: parent->setupFolder->setupLeaf
SetupTreeNode.prototype.getNodes = function(){
	var allNodes = new Array();
	
	var parents = getElementsByClassName('parent');
	allNodes = allNodes.concat(parents);

	var leaves = getElementsByClassName('setupLeaf');
	allNodes = allNodes.concat(leaves);
	
	return allNodes;
	
}

SetupTreeNode.prototype.search = function(){
	if (SetupTreeNode.prototype.isTypingFast()){
		return;
	}
	var val = SetupTreeNode.prototype.getSearchTerm();
	if (!val) {
		SetupTreeNode.prototype.reset();
		return;
	}
	var vals = val.split(' ');
	if (!vals || vals.length == 0){
		return;
	}
	var elements = SetupTreeNode.prototype.getNodes();
	for (var i = 0; elements && i < elements.length; i++){
		var obj = elements[i];
		var topic = obj.id;
	    SetupTreeNode.prototype.searchNode(obj, topic, vals);
	}
}


SetupTreeNode.prototype.searchNode = function(obj, topic, vals){
    if (obj != null) {
    	var containsText = true;
    	var txt = obj.getAttribute(SetupSearchElement.ATT_SEARCH_TEXT);
    	if (!txt){
    		containsText = false;
    	} else {
	    	for (var j = 0; j < vals.length; j++){
	    		if (txt.indexOf(vals[j]) == -1){
	    			containsText = false;
	    			break;
	    		}
	    	}
    	}
        if (containsText) {
        	HTMLTreeNode.prototype.setVisible(obj, true);
        	if (obj.className == 'parent'){
        		obj = HTMLTreeNode.prototype.getNodeChild(topic);
        		HTMLTreeNode.prototype.open(obj, topic);
        	}
        } else {
        	HTMLTreeNode.prototype.setVisible(obj, false);
        	if (obj.className == 'parent'){
        		obj = HTMLTreeNode.prototype.getNodeChild(topic);
        		HTMLTreeNode.prototype.close(obj, topic);
        	}
        }
    }
}

SetupTreeNode.prototype.reset = function(){
	document.getElementById(SetupSearchElement.SETUP_SEARCH_PARAM).value = '';
	var elements = SetupTreeNode.prototype.getNodes();
	for (var i = 0; elements && i < elements.length; i++){
		var obj = elements[i];
	    HTMLTreeNode.prototype.setVisible(obj, true);
	}
}

SetupTreeNode.prototype.getSearchTerm = function(){
	var term = document.getElementById(SetupSearchElement.SETUP_SEARCH_PARAM).value;
	if (term){
		term = term.toLowerCase();
	}
	return term;
}

SetupTreeNode.prototype.updateCookiesSetup = function() {
    var stringlist = "";
    for (var i = 0; i < SetupTreeNode.prototype.openListSetup.length; i++) {
        if (SetupTreeNode.prototype.openListSetup[i] != null) {
            stringlist = stringlist + SetupTreeNode.prototype.openListSetup[i] + ":";
        }
    }
            
    Cookies.prototype.SetCookie(SetupTreeNodeConstants.COOKIE_KEY, stringlist, null, "/");     
}

SetupTreeNode.prototype.TYPING_THRESHOLD_MILLIS = 250;
SetupTreeNode.prototype.LAST_DATE = null;
SetupTreeNode.prototype.TIMEOUT_ID = null;

// if typing fast, will delay search() until after typing is slowed
SetupTreeNode.prototype.isTypingFast = function(){
    
    // clear existing timeout to avoid flood of delayed search calls
    if (SetupTreeNode.prototype.TIMEOUT_ID){    
        clearTimeout(SetupTreeNode.prototype.TIMEOUT_ID);
    }
    
	var d = new Date();
	if (SetupTreeNode.prototype.LAST_DATE == null){
	    SetupTreeNode.prototype.LAST_DATE = d;
	    return true;
	} else {
	    var diff = d.getTime() - SetupTreeNode.prototype.LAST_DATE.getTime();
	    SetupTreeNode.prototype.LAST_DATE = d;
	    if (diff < SetupTreeNode.prototype.TYPING_THRESHOLD_MILLIS){
	        var delayedExec = "SetupTreeNode.prototype.search();";
	        SetupTreeNode.prototype.TIMEOUT_ID = setTimeout(delayedExec, SetupTreeNode.prototype.TYPING_THRESHOLD_MILLIS);
	        return true;
	    } else {
	        return false;
	    }
	}
	
}


/**
 * JS code to handle filtering/querying in a SelectFilterElement.
 */
var SelectFilterElement = function(ctlName, ctlOption, target, targetOption, existing, max, useJs){

    this.controllerName = ctlName;
    this.controllerOption = ctlOption;
    this.targetName = target;
    this.targetOption = targetOption;
    this.existingName = existing;

    // array of selected Option objects
    this.selectedOptions = new Array();

    // array of array of all Option objects
    this.allOptions = new Array();
    this.maxValues = max;
    this.searchQueueCount = 0;
    this.useJsSearch = useJs;
    this.searchStringChanged = false;
    this.itemAdded = false;
}

SelectFilterElement.prototype.getSearchElementId = function(){
    return 'searchValue_' + this.controllerName;
}

SelectFilterElement.prototype.addOptions = function(array){
	for (var i = 0; i < array.length; i++){
		this.addOption.apply(this, array[i]);
	}
}

SelectFilterElement.prototype.addOption = function(type, label, key, searchValue, existingValues) {

    var opt = new Option(label, key);
    opt.searchValue = searchValue;
    var optionsArray = this.allOptions[type];
    if (!optionsArray){
        optionsArray = new Array();
        this.allOptions[type] = optionsArray;
    }
    optionsArray[optionsArray.length] = opt;

    if (existingValues && this.selectedOptions != null && this.selectedOptions[key]) {
        existingValues.options[existingValues.options.length] = new Option(label, key);
    }

}

// doing queueSearch only applies to js searching. otherwise,
// sever-side search results in LOTS of posts to server.
SelectFilterElement.prototype.queueSearch = function() {
    this.searchQueueCount++;
    var callback = this.getJavascriptVarName() + '.doSearch()';
    setTimeout(callback, 300);
}

SelectFilterElement.prototype.doSearch = function() {

    this.searchQueueCount--;
    if (this.searchQueueCount > 0) return;
    // Reset the queue when we do a search
    this.searchQueueCount = 0;

    if (this.useJsSearch){
        this.doSearchJS();
    } else {
        this.doSearchServer();
    }
}

// does a "search" by filtering the values in the select element
SelectFilterElement.prototype.doSearchJS = function() {

    var controller = document.getElementById(this.controllerName);
    var targetField = document.getElementById(this.targetName);
    var existing = document.getElementById(this.existingName);

    var searchEl = document.getElementById(this.getSearchElementId());
    var searchValue = searchEl.value ? searchEl.value.toLowerCase() : "";
    if (searchValue.length == 0) {
        // Just run the whole filter if the input length is 0
        this.filter();
        return;
    }

    targetField.options.length = 0;

    var numMatched = 0;
    var numAdded = 0;
    var optionsOfType = this.allOptions[controller.value];
    if (optionsOfType){
        for (var i = 0; i < optionsOfType.length && numAdded < this.maxValues+1; i++) {
            var option = optionsOfType[i];

            if (existing && this.selectedOptions[option.value]){
                numMatched++;
                continue;
            }

            var match =
                !option.searchValue
                || option.searchValue.length == 0
                || option.searchValue.indexOf(searchValue) == 0
                || option.searchValue.indexOf(' ' + searchValue) > -1;

            if (match){
                if (numAdded < this.maxValues){
                    targetField.options[numAdded] = option;
                }
                numMatched++;
                numAdded++;
            }
        }
    }

    var tooManyValues = numMatched > this.maxValues;
    this.showErrorMessage(tooManyValues);

    if (targetField.options.length == 0) {
        targetField.options[0] = new Option(LC.getLabel("SelectElement", "Required"), '000000000000000');
    }

}

// does a "search" by posting back to the server.
SelectFilterElement.prototype.doSearchServer = function() {
    var form = document.forms[EditPageConstants.pEDIT_PAGE];

    // DuelingListBoxesElement may set javascript to be executed
    // on the form.onsubmit(), so we call it before we submit.
    if (form.onsubmit){
        form.onsubmit();
    }

    form.submit();
}

SelectFilterElement.prototype.handleKeyDown = function(evt) {
    evt = getEvent(evt);
    // Enter key
    if (evt.keyCode == 13 || evt.which == 13) {
        this.queueSearch();
        return false;
    } else {
        this.searchStringChanged = true;
    }
    return true;
}

SelectFilterElement.prototype.handlePropertyChange = function(){
    if (this.useJsSearch){
        this.queueSearch();
    }
}

SelectFilterElement.prototype.showErrorMessage = function(showMsg, errorMessage) {
    var searchEl = document.getElementById(this.getSearchElementId());
    var err = document.getElementById('error_' + this.targetName);
    if (searchEl && err) {
        if (showMsg) {
            err.style.visibility = 'visible';
            err.innerHTML = errorMessage ? errorMessage : LC.getLabel("Search_Filter", "too_many", this.maxValues, this.maxValues);
        } else {
            err.style.visibility = 'hidden';
        }
    }
}

SelectFilterElement.prototype.filter = function() {

// alert(this.targetName + " " + this.existingName);

    var controller = document.getElementById(this.controllerName);
    var targetField = document.getElementById(this.targetName);
    var searchEl = document.getElementById(this.getSearchElementId());
    if (this.useJsSearch && searchEl && searchEl.value.length != 0) {
        searchEl.value = '';
    }

    targetField.options.length = 0;

    // this value is initialized in selectfilterelement.jsp
    if (SelectFilterElement.prototype.NONE_LABEL) {
        targetField.options[0] = new Option(SelectFilterElement.prototype.NONE_LABEL, '000000000000000');
    }

    var counter = 0;
    var numAdded = 0;
    var optionsOfType = this.allOptions[controller.value];
    if (optionsOfType){

        // if there's a set of already-selected options, then we test
        // against that set before adding them to the target.
        var testForAlreadySelected = this.existingName;

        if (testForAlreadySelected){
            this.initSelectedOptionsFromUi();
        }

        // populating target field based on the options loaded with addOption().
        for (var i = 0; i < optionsOfType.length && (!searchEl || numAdded < this.maxValues+1); i++) {

            var option = optionsOfType[i];

            // If there existing values are there, check against the map before adding
            if (testForAlreadySelected && this.selectedOptions[option.value]) {
                continue;
            }

            counter++;

            // If search exists, then they only get up to maxValues
            if (!searchEl || numAdded < this.maxValues) {
                targetField.options[targetField.options.length] = option;
                numAdded++;
            }
        }

    }

    var tooManyValues = counter > this.maxValues;
    this.showErrorMessage(tooManyValues);

    if (targetField.options.length == 0) {
        targetField.options[0] = new Option(LC.getLabel("SelectElement", "Required"), '000000000000000');
    }
}

// After every change, we re-initialize the map so we can have fast lookup on it
SelectFilterElement.prototype.initSelectedOptionsFromUi = function() {

    if (this.existingName){

        this.selectedOptions = new Array();

        var existing = document.getElementById(this.existingName);
        if (existing){
            for (var i = 0; i < existing.options.length; i++) {
                if (existing.options[i].value.length > 0) {
                    this.selectedOptions[existing.options[i].value] = true;
                }
            }
        }
    }

}

// called from SelectFilterElement.java, when setting bodyOnLoad()
SelectFilterElement.prototype.init = function() {

    // The filter needs to be run at lease once.
    this.filter();

    // If existing is there, make sure we set the onchange event so we can keep track
    // of what is selected.
    if (this.existingName){
        var existing = document.getElementById(this.existingName);
        if (existing){
            existing.selectFilterEl = this;
            existing.onchange = function(){
                this.selectFilterEl.initSelectedOptionsFromUi();
            };
        }
    }

    // Initialize the default controller option
    if (this.controllerOption && this.controllerName){
        var controller = document.getElementById(this.controllerName);
        if (controller.options != null && controller.options != undefined) {
            for (var i = 0; i < controller.options.length; i++) {
                if (controller.options[i].value == this.controllerOption) {
                    controller.options[i].selected = true;
                }
            }
        }
    }

    // Initialize the default target option
    if (this.targetOption){
        var targetField = document.getElementById(this.targetName);
        for (var i = 0; i < targetField.options.length; i++) {
            if (targetField.options[i].value == this.targetOption) {
                targetField.options[i].selected = true;
            }
        }
    }

}

// name as defined in SelectFilterElement.getJavascriptVarName().
SelectFilterElement.prototype.getJavascriptVarName = function(){
    return this.targetName + 'Var';
}

// filtering the drop-down based on the controller is really just showing
// the right corresponding drop-down and hiding the others.
SelectFilterElement.prototype.filterDropdown = function(name, currTypeSelect) {
    var selected = currTypeSelect.selectedIndex;
    for (var i = 0; i < currTypeSelect.options.length; i++){
        var option = currTypeSelect.options[i].value;
        var optionList = name + '_' + option;
        var currSelect = document.getElementById(optionList);
        if (i == selected){
            currSelect.style.display = 'inline';
        } else {
            currSelect.style.display = 'none';
        }
    }
}

SelectFilterElement.prototype.moveLeft = function() {
    this.filter();
}

SelectFilterElement.prototype.beforeMoveRight = function() {
    this.itemAdded = true;
}


/**
 * Preference bit vectors in js, stores index, name, and current value. Setting a preference
 * to a different value will automatically make an asynchronous request to save the value to the
 * db. Since only a few preferences are accessible/settable through javascript there's no need to
 * compress them into bit vectors. This only handles boolean preferences right now.
 * 
 * @author jmooney
 * @since 150
 */
function PreferenceBits(/* array of {index, name, value} */ preferences) {
    this.bitsByName = {};
    for (var i = 0; i < preferences.length; i++) {
        var pref = preferences[i];
        this.bitsByName[pref.name] = {index: pref.index, val: pref.value };
    }
}

PreferenceBits.prototype.getBoolean = function(/* string */ name) {
    return this.bitsByName[name].val;
}

PreferenceBits.prototype.getIndexByName = function(/* string */ name) {
    return this.bitsByName[name].index;
}

PreferenceBits.prototype.setBoolean = function(/* string */ name, /* boolean */ val) {
    if (typeof val == "boolean") {
        var current = this.bitsByName[name];
        if (current && current.val != val) {
            this.bitsByName[name].val = val;
            this.save(name);
        }
    }
}

PreferenceBits.prototype.save = function(name) {
    var pref = this.bitsByName[name];
    if (pref) {
        // don't care about the response
        XBrowser.postHttpResponse("/_ui/common/request/servlet/PreferenceServlet",
                                  function(response) {},
                                  XBrowser.buildPost({val: pref.val, bit: pref.index}));
    }
}

/**
 * Lookup schema

/**

  we require a map, give as JSON:

  CrtLookups.fields = {
      "Account": {
          "Name" : { label: "Account Name", lookup : null },
          "Owner" : { label: "Account Owner", lookup : "User", lookupLabel: "User"} },
      "User": {
      }
  };

  CrtLookups.primaryObjects = {
      "070..." : { table: "Account", label: "Accounts" },
      "070..." : { table: "Contact", label: "Contacts", detailField: "Account" }
  }

  detail field is used to filter out the lookup that simply points back to
  the parent object

  CrtLookups.initialState = [
      { path: "070abc.Owner.Role", field: "", colId: "073x..."}
  ];


*/

// selected state, which flattens the CrtLookupNode data.  used as input and output
// objectPath = "070abc000001.Owner.Role.Parent"
function CrtField(objectPath, field) {
    this.objectPath = objectPath;
    this.field = field;
}

function CrtFieldCollection() {
    this.fieldsMap = {};
}

CrtFieldCollection.prototype.addField = function(path, fieldName) {
    var field = new CrtField(path, fieldName);
    this.fieldsMap[field.objectPath + '|' + field.field] = field;
}

CrtFieldCollection.prototype.removeField = function(path, fieldName) {
    delete this.fieldsMap[path + '|' + fieldName];
}

CrtFieldCollection.prototype.hasField = function(path, fieldName) {
    var field = this.fieldsMap[path + '|' + fieldName];
    if (field && field != null) {
        return true;
    } else {
        return false;
    }
}

CrtFieldCollection.prototype.clone = function() {
    var copy = new CrtFieldCollection();
    for(var key in this.fieldsMap) {
        copy.fieldsMap[key] = this.fieldsMap[key];
    }
    return copy;
}

// do we really need table and label?  should we just have a pointer to the static fields record?  yes/maybe
function CrtLookupNode(crtObjectId, fieldFromParent, table, label) {
    this.crtObjectId = crtObjectId;
    this.table = table;
    this.label = label;
    this.fieldFromParent = fieldFromParent;
}

CrtLookupsUi.init = function(fields, primaryObjects) {
    var ui = new CrtLookupsUi(fields, primaryObjects);
    return ui;
}

function CrtLookupsUi(fields, primaryObjects) {
    this.fields = fields; // metadata
    this.primaryObjects = primaryObjects;

    this.lookupElem = document.getElementById('lookupBox');
    this.pathElem = document.getElementById('pathBox');

    this.initialSelectedFields = new CrtFieldCollection();
    this.selectedFields = this.initialSelectedFields.clone();
}

CrtLookupsUi.prototype.openOverlayWithPrimary = function() {
    //remove all selection in the layout
    MoveableItem.clearSelectedItems();

    // Parse the picklist value to determine the primaryObject
    var object = CrtObjects.getSelectedValue(document.getElementById(CrtLayoutElement.FIELD_TYPE_SELECT_NAME));
    var iUnderscore = object.indexOf('_');
    if (iUnderscore > -1) {
        object = object.substring(0, iUnderscore);
    }

    // Get the appropriate metadata for the primary object
    this.primaryObjId = object;
    var primaryObject = this.primaryObjects[object];

    // Bring up the overlay
    if (!CrtLookupsUi.lookup) {
        CrtLookupsUi.lookup = document.getElementById('lookupLayer1');
        CrtLookupsUi.lookup = new iframeShim(CrtLookupsUi.lookup);
    }

    //set the lookup header labels
    var headerElem = document.getElementById(CrtLookupConstants.LOOKUP_HEADER);
    var viaLookup = LC.getLabel("CRTLookupLayer","viaLookup");
    var html = '';
    html += '<h3>'+LC.getLabel("CRTLookupLayer","layerHeader")+ ' <span id="headerPrimObj">' + primaryObject.label + '</span> '+ viaLookup +'</h3>';
    html += '<p>' + LC.getLabel("CRTLookupLayer","layerDesc") + ' "' + primaryObject.label + '".' + '</p>';
    headerElem.innerHTML = html;

    this.showGrayout(true);

    //reposition the lookup layer to the center of the window when we open the overlay
    this.repositionLookup();

    CrtLookupsUi.lookup.setStyle('visibility', 'visible');
    //mac needs to set display as well or else scrollbar problems
    CrtLookupsUi.lookup.setStyle('display', 'block');

    //set initial state path to colId Map
    if (CrtLayoutElement.initialStateColIdMap == null) {
        CrtLayoutElement.initialStateColIdMap = {};
        for (var i=0; i< CrtLookups.initialState.length; i++) {
            CrtLayoutElement.initialStateColIdMap[CrtLookups.initialState[i].path+CrtLayoutElement.FIELD_SEP+CrtLookups.initialState[i].field] = CrtLookups.initialState[i].colId;
        }
    }

    //set the initial selected fields for this primary object
    if (CrtLayoutElement.availableSections[CrtLayoutElement.getLookupSectionId(this.primaryObjId)]) {
        this.initialSelectedFields = CrtLayoutElement.availableSections[CrtLayoutElement.getLookupSectionId(this.primaryObjId)].getFieldCollection();
        this.selectedFields = this.initialSelectedFields.clone();
    } else {
        this.initialSelectedFields = new CrtFieldCollection();
        this.selectedFields = this.initialSelectedFields.clone();
    }

    // Initialize our state
    this.path = [];
    this.path.push(new CrtLookupNode(object, null, primaryObject.table, primaryObject.label));
    this.currentTable = primaryObject.table;

    // Render
    this.renderPrimary();

}

CrtLookupsUi.GRAYOUT = 'grayout';

CrtLookupsUi.prototype.repositionLookup = function() {
    var scrollPos = getScrollY()+ getWindowHeight() / 600 * 200;
    CrtLookupsUi.lookup.setStyle('top',scrollPos+'px');
}

CrtLookupsUi.prototype.showGrayout = function(show) {
    var grayout = document.getElementById('overlayLayer1');
    if (!grayout) {
        var body = document.getElementsByTagName("body")[0];
        var node = document.createElement('div');
        node.className = 'overlayLayer';
        node.id = CrtLookupsUi.GRAYOUT;
        //body.appendChild(node);
        body.insertBefore(node, body.firstChild);
        grayout = document.getElementById(CrtLookupsUi.GRAYOUT);
    }
    if (show) {
        var pageDims = this.getPageSizeWithScroll();
        var left = -1 * getObjX(grayout);
        var top = -1 * getObjY(grayout);
        grayout.style.left = left + 'px';
        grayout.style.top = top + 'px';
        grayout.style.width = pageDims[0] + 'px';
        grayout.style.height = pageDims[1] + 'px';
        grayout.style.visibility = 'visible';
    } else {
        grayout.style.visibility = 'hidden';
    }
}

CrtLookupsUi.prototype.getPageSizeWithScroll = function() {
    if (window.innerHeight && window.scrollMaxY) {// Firefox
        yWithScroll = window.innerHeight + window.scrollMaxY;
        xWithScroll = window.innerWidth + window.scrollMaxX;
    } else if (document.body.scrollHeight > document.body.offsetHeight){ // all but Explorer Mac
        yWithScroll = document.body.scrollHeight;
        xWithScroll = document.body.scrollWidth;
    } else { // works in Explorer 6 Strict, Mozilla (not FF) and Safari
        yWithScroll = document.body.offsetHeight;
        xWithScroll = document.body.offsetWidth;
    }
    var arrayPageSizeWithScroll = [xWithScroll,yWithScroll];
    return arrayPageSizeWithScroll;
}

CrtLookupsUi.prototype.getInitialFieldCollection = function() {
   var lookups = new CrtFieldCollection();
   for (var i=0; i< CrtLookups.initialState.length; i++) {
       lookups.addField(CrtLookups.initialState[i].path,CrtLookups.initialState[i].field);
       CrtLayoutElement.initialStateColIdMap[CrtLookups.initialState[i].path+CrtLayoutElement.FIELD_SEP+CrtLookups.initialState[i].field] = CrtLookups.initialState[i].columnId;
   }

   return lookups;
}

CrtFieldCollection.prototype.getAllFieldKeys = function() {
    var fieldKeys = [];
    for (var fieldKey in this.fieldsMap) {
        fieldKeys.push(fieldKey);
    }
    return fieldKeys;
}

CrtFieldCollection.prototype.size = function() {
    var size=0;
    for (var i in this.fieldsMap) {
        if (this.fieldsMap[i]) {
            size++;
        }
    }
    return size;

}
CrtFieldCollection.prototype.isEmpty = function() {
    var isEmpty = true;
    for (var i in this.fieldsMap) {
        if (this.fieldsMap[i]) {
            isEmpty = false;
        }
    }
    return isEmpty;
}



//subtracts the input fields from this collection
//return a new collection
CrtFieldCollection.prototype.subtract = function(fieldsToSubtract) {
    var remainingFields = this.clone();
    var fieldKeys = fieldsToSubtract.getAllFieldKeys();
    for (var i=0; i<fieldKeys.length; i++) {
        if (remainingFields.fieldsMap[fieldKeys[i]]) {
            delete remainingFields.fieldsMap[fieldKeys[i]];
        }
    }
    return remainingFields;
}

CrtFieldCollection.prototype.getField = function(fieldKey) {
    return this.fieldsMap[fieldKey];
}

CrtLookupsUi.prototype.saveOverlay = function() {
    var removedFields= this.initialSelectedFields.subtract(this.selectedFields);
    if (!removedFields.isEmpty()) {
        this.removeFields(removedFields);
    }
    var newlyAddedFields = this.selectedFields.subtract(this.initialSelectedFields);
    if (!newlyAddedFields.isEmpty()) {
        this.addFields(newlyAddedFields);
    }

    //render the lookup Section
    var lookupSection = CrtLayoutElement.availableSections[CrtLayoutElement.getLookupSectionId(this.primaryObjId)];
    if (lookupSection) {
        lookupSection.renderFields();
        lookupSection.swapToSectionDiv();
    }
    this.closeOverlay();

}

CrtLookupsUi.prototype.closeOverlay = function() {
    this.showGrayout(false);
    CrtLookupsUi.lookup.setStyle('visibility', 'hidden');
    CrtLookupsUi.lookup.setStyle('display', 'none');
}

CrtLookupsUi.prototype.removeFields = function(removedFields) {
    //get the lookupSection object
    var lookupSection = CrtLayoutElement.availableSections[CrtLayoutElement.getLookupSectionId(this.primaryObjId)];

    //if we have no selected any fields, remove the entire section
    if (lookupSection) {
        if (this.selectedFields.isEmpty()) {
            //remove the section element and object and options picklist
            lookupSection.remove();
            delete CrtLayoutElement.availableSections[CrtLayoutElement.getLookupSectionId(this.primaryObjId)];
            return;
        }
        //else just remove the fields
        else {
            lookupSection.removeFieldCollection(removedFields);
        }
    }

}

CrtLookupsUi.prototype.addFields = function(addedFields) {
     //get the lookupSection object
     var lookupSection = CrtLayoutElement.availableSections[CrtLayoutElement.getLookupSectionId(this.primaryObjId)];

      //if we don't have a lookup section, we have to make a new picklist option and construct the section
      if(!lookupSection) {
        var selectedElement = document.getElementById(CrtLayoutElement.FIELD_TYPE_SELECT_NAME);
        var primObjDivId = selectedElement.options[selectedElement.selectedIndex].value;
        //header title
        //HACK getting it from the parent select element value
        var headerTitle = selectedElement.options[selectedElement.selectedIndex].text+' ' +LC.getLabel("CRTLookupLayer","viaLookupParen");
        var lookupSectionId = CrtLayoutElement.getLookupSectionId(this.primaryObjId);
        var lookupDivId = CrtLayoutElement.getLookupDivId(lookupSectionId);

        lookupSection = new CrtLookupSection(lookupSectionId, lookupDivId, headerTitle);
        lookupSection.addPicklist(primObjDivId);
      }
      lookupSection.insertFieldCollection(addedFields,this.primaryObjects,this.fields);
}

CrtLayoutElement.getLookupSectionId = function(primObjId) {
    return primObjId + "_" + LookupsUi.LOOKUPS;
}

CrtLayoutElement.getLookupDivId = function(sectionId) {
    return sectionId+CrtLayoutElement.SECTION_DIV_SUFFIX+LookupsUi.LOOKUPS;
}
CrtLookupsUi.prototype.renderPrimary = function() {
    this.setLinksDisabled(true);
    var html = '';

    var primaryObject = this.primaryObjects[this.primaryObjId];

    // Presume that this.currentTable is a primary table
    var fields = this.getFields(this.currentTable);
    for(var fieldName in fields) {
        var field = fields[fieldName];
        if (field.lookup && fieldName != primaryObject.detailField) {
            html += '<br><a href="javascript: CrtLookups.ui.navigateAhead(\'' + fieldName + '\');"> ' + field.label + ' &#187; </a>';
        }
    }
    this.lookupElem.innerHTML = html;
    this.renderPath();
}

/**
 * Given the current path, navigate through a field to go deeper.
 */
CrtLookupsUi.prototype.navigateAhead = function(fieldName) {
    var field = this.getField(this.currentTable, fieldName);
    this.path.push(new CrtLookupNode(null /* todo; how to find id's? */, fieldName, field.lookup, field.label));
    this.currentTable = field.lookup;
    this.renderLookups();
}

/**
 * Navigate to a specific point on the current path.  Since the current
 * path is a stack, any point on the path is navigable by popping the stack.
 */
CrtLookupsUi.prototype.navigateBreadcrumb = function(iBreadcrumb) {
    this.path.length = iBreadcrumb + 1; // pop everything up to the breadcrumb
    if (this.path.length == 1) {
        var node = this.path[0];
        this.currentTable = node.table;
        this.renderPrimary();
    } else {
        var node = this.path[iBreadcrumb];
        var previousNode = this.path[iBreadcrumb - 1];
        this.currentTable = this.getField(previousNode.table, node.fieldFromParent).lookup;
        this.renderLookups();
    }
}

// renders this.currentTable
CrtLookupsUi.prototype.renderLookups = function() {
    this.renderCheckBoxes();
    this.setLinksDisabled(false);
    this.renderPath();
}

CrtLookupsUi.prototype.renderCheckBoxes = function() {
    var html = '';
    var fields = this.getFields(this.currentTable);
    for(var fieldName in fields) {
        var field = fields[fieldName];
        var checked = (this.isSelected(fieldName) ? 'checked' : '');
        if (field.lookup) {
            html += '<input type=checkbox ' + checked + ' onclick="CrtLookups.ui.toggleField(this, \'' + fieldName + '\');"> ' + field.label;
            if (this.path.length <= CrtLookupConstants.LOOKUP_DEPTH_LIMIT) {
                 html += ' &nbsp; <a href="javascript: CrtLookups.ui.navigateAhead(\'' + fieldName + '\');"> ' + LC.getLabel("CRTLookupLayer","viewRelatedFields") + '</a>';
            }
            html += '<br>';
        } else {
            html += '<input type=checkbox ' + checked + ' onclick="CrtLookups.ui.toggleField(this, \'' + fieldName + '\');"> ' + field.label + '<br>';
        }
    }
    this.lookupElem.innerHTML = html;
}

CrtLookupsUi.prototype.setLinksDisabled = function(disabled) {
    var controlElem = document.getElementById(CrtLookupConstants.CONTROL_ELEM_1);
    var innerHTML = '';

    //this label has to be called separately or else we get undefine for some weird reason
    var clearAll = LC.getLabel("CRTLookupLayer","ClearAll");
    if (disabled) {
        controlElem.className = 'crtDisabledLink';

        innerHTML = LC.getLabel("Report","SelectAll") + ' | ' + clearAll;
    } else {
        controlElem.className = '';
        innerHTML = '<a href="javascript: CrtLookups.ui.selectAll();">'+LC.getLabel("Report","SelectAll")+'</a> | <a href="javascript: CrtLookups.ui.clearAll();">'+clearAll+'</a>';
    }
    controlElem.innerHTML = innerHTML;
}

CrtLookupsUi.prototype.selectAll = function() {
    var fields = this.getFields(this.currentTable);
    for (var fieldName in fields) {
        if (!this.selectedFields.hasField(this.getFlatPath(), fieldName)) {
            this.selectedFields.addField(this.getFlatPath(), fieldName);
        }
    }
    this.renderCheckBoxes();
}

CrtLookupsUi.prototype.clearAll = function() {
    var fields = this.getFields(this.currentTable);
    for (var fieldName in fields) {
        if (this.selectedFields.hasField(this.getFlatPath(), fieldName)) {
            this.selectedFields.removeField(this.getFlatPath(), fieldName);
        }
    }

    this.renderCheckBoxes();
}

CrtLookupsUi.prototype.renderPath = function() {
    var html = '<b>'+LC.getLabel("CRTLookupLayer","Path")+ ': </b>&nbsp;';

    var previousTable;
    for(var i = 0; i < this.path.length; i++) {
        var node = this.path[i];

        // Get the labels of the path elements
        var nodeText;
        if (node.fieldFromParent == null) {
            nodeText = this.primaryObjects[node.crtObjectId].label;
            previousTable = node.table;
        } else {
            var field = this.getField(previousTable, node.fieldFromParent);
            nodeText = field.label;
            previousTable = field.lookup;
        }

        var delimiter = '';
        if (i == 1) delimiter = '&#187;';
        if (i > 1) delimiter = '>';
        html += ' ' + delimiter + ' <a href="javascript: CrtLookups.ui.navigateBreadcrumb(' + i + ');">' + nodeText + '</a>';
    }
    if (this.path.length > CrtLookupConstants.LOOKUP_DEPTH_LIMIT) {
        html += '<div class="maxLimit">'+LC.getLabel("CRTLookupLayer","maxDepthLimit") + "</div>";
    }

    this.pathElem.innerHTML = html;
}

CrtLookupsUi.prototype.toggleField = function(checkbox, fieldName) {
    if (checkbox.checked) {
        this.selectedFields.addField(this.getFlatPath(), fieldName);
    } else {
        this.selectedFields.removeField(this.getFlatPath(), fieldName);
    }
}

CrtLookupsUi.prototype.isSelected = function(fieldName) {
    return this.selectedFields.hasField(this.getFlatPath(), fieldName);
}

CrtLookupsUi.prototype.getFlatPath = function() {
    var flatPath;
    for(var i = 0; i < this.path.length; i++) {
        var node = this.path[i];
        if (node.fieldFromParent == null) {
            flatPath = node.crtObjectId;
        } else {
            flatPath += '.' + node.fieldFromParent;
        }
    }
    return flatPath;
}

CrtLookupsUi.prototype.getFields = function(table) {
    return this.fields[table];
}

CrtLookupsUi.prototype.getField = function(tableName, fieldName) {
    return this.fields[tableName][fieldName];
}

/**
 * Holds data about fields on a detail page for inline editing.
 * 
 * @author jmooney
 * @since 150
 */
function InlineEditData(json) {
    this.isEditable = json[InlineEditConstants.EDITABLE];
    this.sysMod = json[InlineEditConstants.LAST_MOD];
    this.id = json[InlineEditConstants.ENTITY_ID];
    this.fields = {};
    this.dependencyGroups = [];
    this.hasCompoundFields = false;
    this.allFieldData = json[InlineEditConstants.FIELD_DATA];
    this.dynamicDataUrl = json[InlineEditConstants.DYNAMIC_DATA];
    this.loadedDynamicData = false;
    this.sentRequest = false;
    this.currentField = null;
    sfdcPage.initInlineEdit(this);
}

InlineEditData.prototype.init = function() {
    this.createFields();
    if (this.hasCompoundFields) {
        InlineEditField.overlay = new InlineEditDialog();
        InlineEditField.overlay.register();
    }
    var self = this;
    addEvent(document, "click", function() { self.closeCurrentField(); }, false);
}

InlineEditData.prototype.createFields = function() {
    if (this.allFieldData) {
        for (var i = 0; i < this.allFieldData.length; i++) {
            var fieldData = this.allFieldData[i];
            var field = InlineEditField.createField(fieldData);
            this.fields[fieldData.fieldId] = field;
            if (field) {
                if (field.compound) {
                    this.hasCompoundFields = true;
                }
            }
        }
        // create dependencies after all fields are loaded
        for (var i in this.fields) {
            var f = this.fields[i];
            if (f && f.controllerId) {
                this.createDependency(f);
                this.hasCompoundFields = true;
            }
        }
    }
}

InlineEditData.prototype.createDependency = function(field) {
    if (field.group) {
        // already in a group, nothing to do
        return;
    }
    // try to find existing group of a controller, and add to that group
    var f = this.getField(field.controllerId);
    var existingGroup = null;
    while (f != null) {
        existingGroup = f.group;
        if (existingGroup) {
            break;
        }
        f = this.getField(f.controllerId);
    }
    if (existingGroup) {
        // found a group, add fields until we get back to f
        var temp = field;
        var start = existingGroup.length;
        while (temp != f) {
            existingGroup.splice(start, 0, temp.id);
            temp.group = existingGroup;
            if (temp instanceof BooleanField) {
                // tell boolean fields to wait for the rest of the dependency to load
                temp.waitForLoad = true;
            }
            temp = this.getField(temp.controllerId);
        }
    } else {
        // have to create a new group
        var newGroup = [];
        var temp = field;
        while (temp != null) {
            newGroup.unshift(temp.id);
            temp.group = newGroup;
            if (temp instanceof BooleanField) {
                // tell boolean fields to wait for the rest of the dependency to load
                temp.waitForLoad = true;
            }
            temp = this.getField(temp.controllerId);
        }
        this.dependencyGroups.push(newGroup);
    }
}

InlineEditData.prototype.openField = function(field) {
    if (field.group) {
        field = this.fields[field.group[0]];
    } else if (!this.isCurrentField(field)) {
        this.closeCurrentField();
    }
    this.currentField = field;
    if (field.waitForLoad && !this.loadedDynamicData) {
        this.loadDynamicData();
        return;
    } else if (field.group) {
        this.openGroup(field.group);
    } else {
        field.openField();
    }
}

InlineEditData.prototype.openGroup = function(group) {
    var first = this.fields[group[0]];
    if (!first.created) {
        var div = document.createElement("div");
        div.className = "inlineEditDiv";
        document.body.appendChild(div);
        // create a table for the edit elements in the group
        var html = [];
        html.push("<table border=0>");
        for (var i = 0; i < group.length; i++) {
            var f = this.fields[group[i]];
            html.push("<tr><td class='labelCol'>");
            html.push(f.getFieldLabel());
            html.push("</td><td></td></tr>");
            if (f.state == InlineEditState.EDIT) {
                f.createEditDiv();
            } else {
                f.createDummy();
            }
        }
        html.push("</table>");
        div.innerHTML = html.join('');
        // after creating all select elements we can load the dependencies and insert into the table
        for (var i = 0; i < group.length; i++) {
            var f = this.fields[group[i]];
            var node;
            if (f.state == InlineEditState.EDIT) {
                f.load();
                div.firstChild.rows[i].lastChild.appendChild(f.editDiv);
            } else {
                div.firstChild.rows[i].lastChild.innerHTML = f.initialHTML;
            }
        }
        InlineEditField.overlay.addField(first.id, div, LC.getLabel("DependentElement", "dependentFields"));
    }
    InlineEditField.overlay.setActiveField(first.id);
    InlineEditField.overlay.setMaxWidth(400);
    InlineEditField.overlay.show();
}

InlineEditData.prototype.isCurrentField = function(field) {
    return this.currentField && this.currentField == field && !this.currentField.group;
}

InlineEditData.prototype.closeCurrentField = function() {
    if (this.currentField) {
        if (this.currentField.group) {
            this.closeGroup(this.currentField.group);
            this.currentField = null;
        } else {
            this.currentField.closeField();
            this.currentField = null;
        }
    }
}

InlineEditData.prototype.closeGroup = function(group) {
    for (var i = 0; i < group.length; i++) {
        var f = this.fields[group[i]];
        if (f.state == InlineEditState.EDIT) {
            var newValue = f.getValueFromEdit();
            if (f.isDifferentValue(newValue)) {
                if (!f.changed) {
                    f.changed = true;
                    addStyleClass(f.readDiv, "inlineEditModified");
                }
                f.currentValue = newValue;
                f.updateReadElement();
                if (f.changed) {
                    f.readDiv.appendChild(f.undoButton);
                    f.undoButton.style.display = "inline";
                }
            } else if (f.changed) {
                f.changed = false;
                f.currentValue = newValue;
                delStyleClass(f.readDiv, "inlineEditModified");
                f.updateReadElement();
                f.undoButton.style.display = "none";
            }
        }
    }
    InlineEditField.overlay.hide();
}

InlineEditData.prototype.resetCurrentField = function() {
    this.resetField(this.currentField);
    this.currentField = null;
}

InlineEditData.prototype.resetFieldById = function(id) {
    this.resetField(this.fields[id]);
}

InlineEditData.prototype.resetField = function(field) {
    if (field) {
        if (field.group) {
            this.resetGroup(field.group);
        } else {
            field.reset();
        }
    }
}

InlineEditData.prototype.resetGroup = function(group) {
    for (var i = 0; i < group.length; i++) {
        var f = this.fields[group[i]];
        if (f.state == InlineEditState.EDIT) {
            f.reset();
        }
    }
    InlineEditField.overlay.hide();
}

InlineEditData.prototype.getField = function(id) {
    if (id) {
        return this.fields[id];
    }
    return null;
}

InlineEditData.prototype.save = function() {
    if (this.isEditable) {
        this.closeCurrentField();
        var saveData = {};
        saveData[InlineEditConstants.ENTITY_ID] = this.id;
        saveData[InlineEditConstants.LAST_MOD] = this.sysMod;
        saveData[EditPageConstants.pSAVE] = "1"
        for (var id in this.fields) {
            var field = this.fields[id];
            // don't post data from read only fields, but do post from none fields because they are usually editable
            if (field && field.doPost()) {
                field.clearError();
                field.addSaveData(saveData);
            }
        }
        var self = this;
        XBrowser.postHttpResponse("/ui/common/InlineEditEntitySave",
                                  function(response) { self.handleResponse(response.responseText); },
                                  XBrowser.buildPost(saveData),
                                  // check the errorMsg??
                                  function(response) {
                                      var url = escape(window.location.pathname+window.location.search);
                                      window.location.replace("/ex/errorduringprocessing.jsp?retURL=" + url);
                                  }
                                  );
    }
}

InlineEditData.prototype.handleResponse = function(responseText) {
    var response = Util.evalAjaxServletOutput(responseText);
    if (response[InlineEditConstants.SUCCESS]) {
        sfdcPage.refreshDetail();
    } else {
        this.handleErrors(response);
    }
}

InlineEditData.prototype.handleErrors = function(response) {
    sfdcPage.setError(response[InlineEditConstants.NON_SPECIFIC_ERRORS]);
    var specific = response[InlineEditConstants.VALIDATION_ERRORS];
    var first;
    for (var id in specific) {
        var f = this.getField(id);
        // error could be on a field that isn't on the page if somebody changed metadata after page 
        if (f) {
            // try to find the first simple field with an error and open it
            if (!f.overlay && !f.group) {
                // all fields have same offsetParent so use local y coord
                if (!first || first.tableCell.offsetTop > f.tableCell.offsetTop) {
                    first = f;
                }
            }
            f.setError(specific[id]);
        }
    }
    if (first) {
        this.openField(first);
    }
}

InlineEditData.prototype.revert = function() {
    if (this.isEditable) {
        this.closeCurrentField();
        var resetGroups = {};
        for (var id in this.fields) {
            var field = this.fields[id];
            if (field) {
                if (field.changed) {
                    // groups need to be reset separately
                    if (field.group) {
                        resetGroups[field.group[0]] = true;
                    } else {
                        field.reset();
                    }
                } else {
                    field.clearError();
                }
            }
        }
        for (var id in resetGroups) {
            this.resetGroup(this.fields[id].group);
        }
    }
}

InlineEditData.prototype.loadDynamicData = function() {
    if (!this.sentRequest) {
        this.sentRequest = true;
        var self = this;
        XBrowser.createDynamicScript(this.dynamicDataUrl, function() { self.dynamicDataLoaded(); });
    }
}

InlineEditData.prototype.dynamicDataLoaded = function() {
    if (!this.loadedDynamicData) {
        this.loadedDynamicData = true;
        if (this.currentField.waitForLoad) {
            this.openField(this.currentField);
        }
    }
}


/**
  A MotifElement just tracks the relevent peices of the MotifElement

  @author polcari
  @since 144

  @paramName  This is the parameter name which prepends in the inputElements
*/

function MotifElement(id, descCellId, iconId, _motifKey) {
  if (arguments.length > 0) {
    this.init(id, descCellId, iconId, _motifKey);
  }
}

MotifElement.prototype.init	= function(id, descCellId, iconId, _motifKey) {
    this.motifElement = document.getElementById(id);
    this.motifDescCell = document.getElementById(descCellId);
    this.motifIcon = document.getElementById(iconId);
    this.motifKey = _motifKey;

    this.motifElement.motifElement = this;
}

MotifElement.prototype.getDescription = function() {
  return this.motifDescCell.firstChild.nodeValue;
}
/**
  A select element with details displayed on the right

  @author eli
  @since 148

*/
function MailmergeTemplateSelectElement(_id, _items, _fileDownloadUrl) {
  this.id = _id;
  this.items = _items;
  this.fileDownloadUrl = _fileDownloadUrl;
  var element = this;
  sfdcPage.appendToOnloadQueue(function() {element.init()});
}

MailmergeTemplateSelectElement.prototype.init = function() {
  var selectEle = document.getElementById(this.id);
  var mmtseEle = this;
  var previewEle = document.getElementById(MailmergeTemplateSelectElementConst.TEMPLATE_VIEW_BUTTON + '_' + this.id);
  if (previewEle) {
	  addEvent(previewEle, 'mouseup', function() {MailmergeTemplateSelectElement.showPreview(mmtseEle.fileDownloadUrl, selectEle);}, false);
  }
  addEvent(selectEle, 'mousemove', function() {MailmergeTemplateSelectElement.showDetails(mmtseEle.id, selectEle, mmtseEle.items);}, false);
  addEvent(selectEle, 'change', function() {MailmergeTemplateSelectElement.showDetails(mmtseEle.id, selectEle, mmtseEle.items);}, false);
  MailmergeTemplateSelectElement.showDetails(mmtseEle.id, selectEle, mmtseEle.items);
}

MailmergeTemplateSelectElement.showDetails = function(_id, selectEle, items) {
  if (selectEle.selectedIndex < 0)
  	return;
  var selectedOption = selectEle.options[selectEle.selectedIndex];
  var templateItem = (selectedOption) ? items[selectedOption.value] : null;
  if (templateItem == null)
  	return;
  var tName = templateItem[MailmergeTemplateSelectElementConst.TEMPLATE_TITLE];
  var description = templateItem[MailmergeTemplateSelectElementConst.TEMPLATE_DESCRIPTION];
  document.getElementById(MailmergeTemplateSelectElementConst.TEMPLATE_TITLE + '_' + _id).innerHTML = tName;
  document.getElementById(MailmergeTemplateSelectElementConst.TEMPLATE_DESCRIPTION + '_' + _id).innerHTML = description;
}

MailmergeTemplateSelectElement.showPreview = function(url, selectEle) {
  if (selectEle.selectedIndex < 0)
  	return;
  window.open(url + "?file=" + selectEle.options[selectEle.selectedIndex].value, '_blank');
}
/**
 * Functional Dialog with a scrollable content area and a summary. Can be movable but not resizable.
 * 
 * @author jmooney
 * @since 150
 */

function FunctionalDialog(id, isModal, title, isMovable) {
    this.id = id;
    this.isModal = isModal;
    this.isMovable = isMovable;
    this.extraClass = "functionalDialog";
    this.width = OverlayDialog.MAX_WIDTH;
    this.maxHeight = OverlayDialog.MAX_HEIGHT;
    this.setupDefaultButtons();
    this.title = title;
    this.hasSummaryElement = true;
    this.addEvents();
}

FunctionalDialog.prototype = new OverlayDialog();

FunctionalDialog.MAX_HEIGHT = 600;
FunctionalDialog.MIN_HEIGHT = 120;

FunctionalDialog.prototype.setMaxHeight = function(maxHeight) {
    this.maxHeight = maxHeight > FunctionalDialog.MAX_HEIGHT ? FunctionalDialog.MAX_HEIGHT : maxHeight;
}

FunctionalDialog.prototype.setInnerHeight = function() {
    // gotta add a bit for the scrollbars
    var inner = this.getContentElement();
    var height = inner.offsetHeight + (Math.min(this.maxHeight, getWindowHeight() - 40) - this.dialog.offsetHeight);
    inner.style.height = Math.max(FunctionalDialog.MIN_HEIGHT, height) + "px";
}

FunctionalDialog.prototype.createContent = function() {
    var content = document.getElementById(this.id + "Content");
    var html = [];
    html.push("<h2 id='");
    html.push(this.id);
    html.push("Header'>");
    html.push(this.header);
    html.push("</h2>");
    if (this.info) {
        html.push("<p id='");
        html.push(this.id);
        html.push("Info'>");
        html.push(this.info);
        html.push("</p>");
    }
    html.push("<div class='");
    if (this.hasSummaryElement) {
        html.push("scrollableArea");
    } else {
        html.push("scrollableAreaBottomBorder");
    }
        
    html.push("' id='");
    html.push(this.id);
    html.push("Inner'></div>");
    if (this.hasSummaryElement) {
        html.push("<div id='");
        html.push(this.id);
        html.push("Split' class='split'><img src='/img/overlaypointer.gif' class='pointer'></div><div class='summaryArea' id='");
        html.push(this.id);
        html.push("Summary'></div>");
    }

    this.createButtons(html);
    content.innerHTML = html.join("");
}

/**
 * convenience method to set the innerHTML of the scrollable content area
 */
FunctionalDialog.prototype.setContentInnerHTML = function(html) {
    this.getContentElement().innerHTML = html;
}

/**
 * convenience method to import another node into the scrollable content area
 */
FunctionalDialog.prototype.importContentNode = function(element) {
    this.setContentInnerHTML("");
    this.getContentElement().appendChild(element);
}

/**
 * returns the content element
 */
FunctionalDialog.prototype.getContentElement = function() {
    return document.getElementById(this.id + "Inner");
}

/**
 * convenience method to set the innerHTML of the summary
 */
FunctionalDialog.prototype.setSummaryInnerHTML = function(html) {
    this.getSummaryElement().innerHTML = html;
}

/**
 * convenience method to import nodes into the summary area
 */
FunctionalDialog.prototype.importSummaryNode = function(element) {
    this.setSummaryInnerHTML("");
    this.getSummaryElement().appendChild(element);
}

/**
 * returns the summary element
 */
FunctionalDialog.prototype.getSummaryElement = function() {
    return document.getElementById(this.id + "Summary");
}

/**
 * Hide summary element and related split element.
 */
FunctionalDialog.prototype.hideSummaryElement = function() {
    if (!this.hasSummaryElement) return; // don't need to do anything

    this.hasSummaryElement = false;
    var summary = this.getSummaryElement();
    var split = document.getElementById(this.id + "Split");
    var inner = this.getContentElement();
    if (summary && split && inner) {
        summary.style.display = 'none';
        split.style.display = 'none';
        inner.className = "scrollableAreaBottomBorder";
    }
}

var RuleFilterPage = {};

RuleFilterPage.toggleReassignElements = function (baseName, baseTemplateName) {
    var isChecked = document.getElementById(baseName+RuleFilterPageConstants.NO_REASSIGN_SUFFIX).checked

    document.getElementById(baseName).disabled = isChecked;
    document.getElementById(baseName + MultiLookupInputElement.MULTI_LOOKUP_SELECT_SUFFIX).disabled = isChecked;
    document.getElementById(baseName + LookupInputElement.pLOOKUP_WIDGET).style.display = (isChecked) ? 'none' : 'inline';
    document.getElementById(baseName).parentNode.parentNode.firstChild.style.display = (isChecked) ? 'none' : 'inline';
    document.getElementById(baseTemplateName).disabled = isChecked;
    document.getElementById(baseTemplateName + LookupInputElement.pLOOKUP_WIDGET).style.display = (isChecked) ? 'none' : 'inline';
};

/**
 * @author zzhou
 * since 148
 * AvailableSection fields javascript code; also see AvailableSection.js, CrtLayout.js, Lookups.js
 */

CrtLayoutElement.initAvailField = function(sectionId, fieldValue, fieldLabel, inLayout, isLookup) {
    var availField = new AvailableField(sectionId,fieldValue,fieldLabel, inLayout, isLookup);
    CrtLayoutElement.availableSections[sectionId].addField(availField);
}

function AvailableField(sectionId,fieldValue,fieldLabel, inLayout, isLookup) {
    this.id = fieldValue;
    this.sectionId = sectionId;
    this.fieldValue = fieldValue;
    this.fieldLabel = escapeHTML(fieldLabel);
    this.isSelected = false;
    this.pageNum = 1;
    this.inLayout = inLayout;
    this.isLookup = isLookup;
    //this takes too long to set for lookup fields -- set it when we actually hover
    this.displayName = this.isLookup ? null : this.fieldLabel;

    //TODO type
    this.type = 's';
    this.mousingOver = false;

}

AvailableField.prototype.getFieldValue = function() {
    return this.fieldValue;
}

AvailableField.prototype.render = function() {
    var className = 'availField';
    if (this.inLayout) {
        className += ' usedAvailField';
    } else {
        className += ' unusedAvailField';
    }
    if (this.isSelected) {
        className += ' ' +CrtLayoutElement.CSS_CLASS_SELECTED_ITEM;
    }
    if (!this.elem) {
        this.elem = document.getElementById(this.id);
    }
    if (this.elem) {
        this.elem.className = className;
    }

}

AvailableField.prototype.formatDName = function() {
    if (this.fieldLabel.length > CrtLayoutElement.MAX_DISPLAY_FIELD_LENGTH) {
        return this.fieldLabel.substring(0,CrtLayoutElement.MAX_DISPLAY_FIELD_LENGTH-2)+"...";
    }
    else {
        return this.fieldLabel;
    }
}

AvailableField.prototype.setToUsed = function() {
    var self = this;
    self.inLayout = true;
    if (this.mouseOverDiv) {
        this.mouseOverDiv.innerHTML = '';
        this.mouseOverDiv.style.display = 'none';
        this.mouseOverDiv = null;
        this.mousingOver = false;
    }
}

AvailableField.prototype.setToAvailable = function() {
    this.inLayout = false;
}

AvailableField.prototype.handleMouseOver = function(evt) {
    var evt = getEvent(evt);
    this.posX = getMouseX(evt);
    this.posY = getMouseY(evt);
    if (!this.inLayout && !CrtLayoutElement.dragMove && !this.mousingOver) {
        var self = this;
        this.timeOut = setTimeout(function() {self.setupMouseOverDiv();},CrtLayoutElement.HOVER_TIME_OUT)
        this.mousingOver = true;
    }
}

AvailableField.prototype.handleMouseOut = function (evt) {
    if (this.inLayout) {
        return;
    }
    document.getElementById(CrtLayoutElement.HOVER_DIV).style.display = 'none';
    clearTimeout(this.timeOut);
    this.mousingOver = false;
}

AvailableField.prototype.handleMouseDown = function(evt) {
      if (this.inLayout) {
          CrtLayoutElement.clearTextSelection();
          return;
      }
      var evt = getEvent(evt);
      if (!evt.shiftKey && !evt.ctrlKey && !this.isSelected) {
          this.toggleSelected(false);
      }
      CrtLayoutElement.mouseDown = true;
}

AvailableField.prototype.handleMouseClick = function(evt) {
    if (this.inLayout) {
        CrtLayoutElement.clearTextSelection();
        return;
    }
    var evt = getEvent(evt);
    if (evt.ctrlKey) {
        this.toggleSelected(true);
    } else {

    }
}

AvailableField.prototype.toggleSelected = function(isCtrlSelect) {
        if (this.isSelected) {
            this.removeSelection(false);
        }
        else {
            if (!isCtrlSelect) {
                MoveableItem.clearSelectedItems();
            }
            this.addSelection();
        }
}

//remove this field from the layout; used currently by the lookup sections
AvailableField.prototype.removeFromLayout = function() {
    if (this.inLayout) {
        var itemObj = CrtLayoutElement.lookupItemPosMap[this.fieldValue];
        //set this cell to empty and return the id of the table to reformat
        itemObj.handleMoved();
    }
}

AvailableField.prototype.removeSelection = function(noBucketRemove) {
    if (!noBucketRemove) {
        this.moveableItem.removeSelection();
    }
    this.moveableItem = null;
    this.removeSelectionFormatting();
}

AvailableField.prototype.removeSelectionFormatting = function() {
    this.isSelected = false;
    this.render();
}

AvailableField.prototype.handleMoved = function() {
    this.setToUsed();
    this.removeSelectionFormatting();
}

AvailableField.prototype.addSelection = function() {
    var addSelection;
    this.moveableItem = this.createMoveableItem();
    addSelection = this.moveableItem.addSelection();
    //are we mixing the selection Bucket?
    if (addSelection) {
        this.addSelectionFormatting();
    }
}

AvailableField.prototype.createMoveableItem = function() {
    return new MoveableItem(this.fieldValue,this.fieldLabel,this.displayName, null, this.type, this, false, false, this.isLookup, false);
}

AvailableField.prototype.addSelectionFormatting = function() {
    this.isSelected = true;
    this.render();
}

AvailableField.prototype.handleMoveTo = function() {
    this.setToAvailable();
    this.render();
}

AvailableField.prototype.setupMouseOverDiv = function(evt) {
    var moElem = document.getElementById(CrtLayoutElement.HOVER_DIV);
    var html = '';
    var posx = this.posX-210;
    var posy = this.posY-80;
    html += '<div class="mouseOverHeader">'+ this.fieldLabel + (this.isLookup ? ' ' + LC.getLabel("CRTLookupLayer","viaLookupParen") : '') + '</div>';
    if (!this.displayName) {
        this.displayName = CrtLayoutElement.getDisplayPath(this.fieldValue,true);
    }
    html += '<div class="mouseOverBody">'+LC.getLabel("CrtLayout","CustomLabel")+': '+ this.displayName + '<br>';
    if (this.isLookup) {
        html += '<br>';
        html += LC.getLabel("CrtLayout","lookupPath") + ' ' + CrtLayoutElement.getDisplayPath(this.fieldValue,false);
        html += '<br>';
    }
    html += '<br>' + LC.getLabel("CrtLayout","availFieldHover");
    moElem.innerHTML = html;
    moElem.style.display = 'block';
    moElem.style.left = posx+"px";
    moElem.style.top = posy+"px";
    return moElem;
}

/**
 * Function to handle the Save and Cancel functionality on the Email Address Edit page related
 * to Email Author.
 * @author ccopek
 * @since 150
 */

function EmailAddrEdit() {}

EmailAddrEdit.prototype.changeToCancelRetURL = function() {
    var qs = new QueryString("");
    qs.add(EmailAddrEditConstants.pSAVE_CANCEL, "true");

    document.editPage.elements['retURL'].value = UrlMap.getURL("EmailAuthorPopupCloser") + qs.toString();
 }

function ImageSelectElement (hiddenElementId, imageId, partialImgURL) {
 var self = this;
 this.inputElement = document.getElementById(hiddenElementId);
 this.image = document.getElementById(imageId);
 this.partialImageURL = partialImgURL;  //org-specific

//hook this onto the hidden input box, as that's the main id for ImageInputElements
 this.inputElement.imageSelectElement = this;

 this.inputElement.onchange =
 function() {
  //this should set the visible image
  self.image.src = self.partialImageURL + self.inputElement.value;
  }
}

ImageSelectElement.prototype.isNull = function() {
  return (!((this.inputElement) && (this.inputElement.value) && (this.inputElement.value.length > 0)));
}


/*
* @author mpolcari
* @since 144
*/
function ListPage() {}

ListPage.prototype = new GenericSfdcPage();

/**
 *  javascript object for report wizard
 */
function Reports() {}

Reports.prototype = new GenericSfdcPage();

Reports.prototype.registerTopNEvents = function() {
    var topnSelect = document.getElementById('topn');
    addEvent(topnSelect, 'change', this.showTopNSections, false);
}

Reports.prototype.showTopNSections = function() {
    var topnselect = document.getElementById('topn');
    var sortrow = document.getElementById('sortbyrow');
    var orderrow = document.getElementById('orderrow');
    var box = document.getElementById('topn_custom');
    var section = document.getElementById('top_custom_section');

    if (topnselect.value == 'all') {
        sortrow.style.display = 'none';
        orderrow.style.display = 'none';
        section.style.display = 'none';
        sortrow.style.display = 'none';
    } else if (topnselect.value == 'custom') {
        sortrow.style.display = '';
        orderrow.style.display = '';
        section.style.display = 'inline';
        box.focus();
    } else {
        sortrow.style.display = '';
        orderrow.style.display = '';
        section.style.display = 'none';
    }
}

/** functions for floating column headers */
Reports.prototype.initFch = function() {
    // Grab some key elements
    this.headerMarker = document.getElementById(ReportsFch.FCH_AREA);
    this.headerMarkerY = getObjY(this.headerMarker) + 20;

    // The offset here produces an "overhang" effect.
    // It needs to equal Reports.css.floatingHeader.padding-left/right
    // -1 is for the border
    this.headerX = getObjX(this.headerMarker) - 1 - 3;
    this.floatingHeader = document.getElementById(ReportsFch.FLOATING_HEADER);

    // Init the floating header to invisible
    this.isVisible = false;
    this.floatingHeader.style.display = 'none';
    if (XBrowser.userAgent.isIE6) {
        this.floatingHeader.style.position = 'absolute';
    }
    this.matchHeaderSize();

    // Attach events
    var self = this;
    addEvent(window, 'scroll', function() { self.handleFchScroll() }, false);
    addEvent(window, 'resize', function() { self.matchHeaderSize() }, false);
}

/**
 * Match the look-and-feel of the real header
 */
Reports.prototype.matchHeaderSize = function() {
    var floatingRow = this.floatingHeader.childNodes[0].rows[0]; // this.floatingHeader is a table
    var floatingCells = floatingRow.cells;
    var row = document.getElementById(ReportsFch.HEADER_ROW);
    if (!row) return; // hide details
    this.floatingHeader.style.width = row.offsetWidth + 'px';
    for(var i = 0; i < row.cells.length; i++) {
        var cell = row.cells[i];
        // -7 is for the existing padding
        floatingCells[i].style.width = (cell.offsetWidth - 7) + 'px';
    }

    var left = XBrowser.userAgent.isIE6 ? this.headerX : this.headerX - getScrollX();
    this.floatingHeader.style.left = left + 'px';
    this.headerBottomY = this.headerMarkerY + this.headerMarker.offsetHeight - 70 - this.floatingHeader.offsetHeight;
}

Reports.prototype.handleFchScroll = function() {
    var scrollY = getScrollY();
    var inRange = scrollY >= this.headerMarkerY && scrollY < this.headerBottomY;
    if (!this.isVisible) {
        if (inRange) {
            // Moved below the top (the regular header), so display the floating header
            this.matchHeaderSize();
            this.floatingHeader.style.display = 'block';
            // this.floatingHeader.offsetHeight equals 0 until the floating header is actually visible
            this.headerBottomY = this.headerMarkerY + this.headerMarker.offsetHeight - 70 - this.floatingHeader.offsetHeight;
            this.isVisible = true;
        }
    } else /* isVisible */ {
        if (!inRange) {
            // Moved above the top (the regular header), so hide the floating header
            this.floatingHeader.style.display = 'none';
            this.isVisible = false;
        } else /* inRange */ {
            if (XBrowser.userAgent.isIE6) {
                // For IE, re-position manually while visible
				this.floatingHeader.style.top = (getScrollY() - 85) + 'px';
				
				// Horizontal fixity
            	// The conditional here is meant to be true whenever we are using position: fixed-- for everything except IE6
            	// IE6 uses position: absolute so horizontal fixity is already established
				this.floatingHeader.style.left = (this.headerX - getScrollX()) + 'px';
            }

        }
    }
}

Reports.oldSummaryValue = null;

Reports.saveOldSummaryValueIfExists = function() {
    if(document.getElementById(ReportConstants.pSubTotalBy0) != null) {
        Reports.oldSummaryValue = document.getElementById(ReportConstants.pSubTotalBy0).value;
    }
}

Reports.runReportPageOnSubmit = function(formName, format, numBreaks) {
    if(Reports.oldSummaryValue != document.getElementById(ReportConstants.pSubTotalBy0).value) {
        if (document.forms[formName][format].value == 't' && document.getElementById(ReportConstants.pSubTotalBy0).value == '') {
            document.forms[formName][format].value = 'tt';

            //we also need to clear all the breaks
            for (var i = 0; i < numBreaks; i++) {
                document.forms[formName]['break' + i].value = '';
            }
        } else if (document.forms[formName][format].value == 'tt' && document.getElementById(ReportConstants.pSubTotalBy0).value != '') {
            document.forms[formName][format].value = 't';
        }
    }
}

Reports.formatPageOnSubmit = function(formName, numBreaks) {
    if (document.getElementById('format_tabular').checked == true) {
        for (var i = 0; i < numBreaks; i++) {
            document.forms[formName]['break' + i].value = '';
        }
    }
}




/**
 * Lookup hover detail object.
 * @author jmooney
 * @since 148
 */
function LookupHoverDetail(id, url) {
    this.lookup = getElementByIdCS(id);
    this.width = 302;
    this.bubbleOffset = XBrowser.userAgent.isIE6 ? 5 : 14;
    this.height = 262;
    this.hover = document.createElement("div");
    this.hover.id = id + "Hover";
    this.hover.className = "individualPalette lookupHoverDetail";
    this.hover.innerHTML = "<div class=\"topLeft\">" + LC.getLabel("Global", "loading") + "</div>";
    document.body.appendChild(this.hover);
    var self = this;
    addEvent(this.hover, "mouseover", function() { self.show(); } , true);
    addEvent(this.hover, "mouseout", function() { self.hide(); }, true);
    this.hover = new iframeShim(this.hover);
    this.originalClass = "";
    this.fadingOut = null;
    this.fadingIn = null;
    this.loaderURL = url;
    this.loaded = false;
}

LookupHoverDetail.SHOW_DELAY = 800;
LookupHoverDetail.HIDE_DELAY = 250;
LookupHoverDetail.stopLoading = false;
// map from id to hover object
LookupHoverDetail.hovers = {};

// static function to retrieve a hover detail using a 15 char ID
LookupHoverDetail.getHover = function(id, url) {
    if (LookupHoverDetail.hovers[id]) {
        return LookupHoverDetail.hovers[id];
    }
    var hover = new LookupHoverDetail(id, url);
    LookupHoverDetail.hovers[id] = hover;
    return hover;
}

// show the hover detail
LookupHoverDetail.prototype.show = function() {
    if (this.fadingOut) {
        clearTimeout(this.fadingOut);
        this.fadingOut = null;
	} else {
        var self = this;
	    this.fadingIn = setTimeout( function() { self.showNow(); }, LookupHoverDetail.SHOW_DELAY);
    }
}

LookupHoverDetail.prototype.showNow = function() {
    if (!this.loaded) {
    	if (this.loaderURL != null) {
    		var self = this;
    		XBrowser.getHttpResponse(this.loaderURL, function(response) { self.load(response.responseText); }, function(response) { self.load(response.responseText); });
    	} else {
    		// we haven't loaded, and we have no URL to load from, so don't do anything.
    		return;
    	}
    }
    this.position();
    this.hover.setStyle("display", "block");
    this.fadingIn = null;
}

// hide the hover detail
LookupHoverDetail.prototype.hide = function() {
    if (this.fadingIn) {
        clearTimeout(this.fadingIn);
        this.fadingIn = null;
    } else {
        var self = this;
        this.fadingOut = setTimeout(function() { self.hideNow(); }, LookupHoverDetail.HIDE_DELAY);
    }
}

LookupHoverDetail.prototype.hideNow = function() {
    this.hover.setStyle("display", "none");
    this.fadingOut = null;
}

// loads the mini detail from the responseText
LookupHoverDetail.prototype.load = function(responseText) {
	this.hover.div.innerHTML = responseText;
	Util.evalScriptsUnderElement(this.hover.div);
	this.originalClass = this.hover.div.firstChild.className;
	this.position();
	this.loaded = true;
}

LookupHoverDetail.prototype.position = function() {
    var lookupX = getObjX(this.lookup);
    var lookupY = getObjY(this.lookup);
    var lookupW = this.lookup.offsetWidth;
    var lookupH = this.lookup.offsetHeight;
	var winX = getScrollX();
	var winY = getScrollY();
	var winWidth = getWindowWidth();
	var winHeight = getWindowHeight();
    var bubbleClass = this.originalClass + " ";
    var hoverX, hoverY;
    if (lookupY + lookupH + this.height < winY + winHeight) {
    	bubbleClass += "top";
    	hoverY = lookupY + lookupH;
    } else {
    	bubbleClass += "bottom";
    	hoverY = lookupY - this.height;
    }
    if (lookupX + lookupW - this.bubbleOffset + this.width < winX + winWidth) {
    	bubbleClass += "Left";
    	hoverX = lookupX + lookupW / 2 - this.bubbleOffset;
    } else {
    	bubbleClass += "Right";
    	hoverX = lookupX + lookupW / 2 - this.width; 
    }
    
    this.hover.setStyle("left", hoverX + "px");
    this.hover.setStyle("top", hoverY + "px");
    this.hover.div.firstChild.className = bubbleClass;;
}
/**
 * Class contains JavaScript methods for manipulating dueling lists.
 * TODO there are several static methods here that should eventually be refactored into
 * instance methods.
 *
 * @author mpaksoy
 * @since 150
 *
 */

/**
 * Constructor
 *
 * @param selectionIds Array of selection element ids. These are used to read and restore the selection list
 * contents.
 * @param warnId
 * @param removeWarnIf Function to call to decide whether to warn the user when removing an option.
 * @param removeWarningtext Warning message to display when removing an option.
 */
function DuelingListBoxesElement(selectionIds, warnId, removeWarnIf, removeWarningText) {
    this.sListIds=selectionIds;
    this.warnDiv=warnId;
    this.removeWarnIf=removeWarnIf;
    this.removeWarningText=removeWarningText;
}

/**
 * Sets a flag to make sure the state is stored only once.
 * Stores state using storeState()
 */
DuelingListBoxesElement.prototype.storeStateOnce = function() {
    if (this.isStored) {
        return;
    }
    this.isStored=true;
    this.storeState();
}

/**
 * Note: use storeStateOnce() to prevent overriding the initial state.
 * Stores the ordering, values and labels of option elements inside all selection lists.
 */
DuelingListBoxesElement.prototype.storeState = function() {
    this.selectContents=new Array();
    for (var i = 0; i < this.sListIds.length; i++) {
        var curSelect = document.getElementById(this.sListIds[i]);
        if (!curSelect) {
            continue;
        }
        this.selectContents[i]=new Array();
        for (var j = 0; j < curSelect.options.length; j++) {
            this.selectContents[i][j]=[curSelect.options[j].text, curSelect.options[j].value];
        }
    }
}

/**
 * Restore selection list contents from stored state.
 */
DuelingListBoxesElement.prototype.resetSelection = function() {
    if (!this.isStored)
        return;

    for (var i=0; i < this.sListIds.length; i++) {
        var curSelect = document.getElementById(this.sListIds[i]);
        if (!curSelect) {
            continue;
        }

        Util.refreshDynamicSelect(curSelect, this.selectContents[i]);
    }
}

/**
 * Displays a warning message using the warnDiv field (should be set using constructor)
 */
DuelingListBoxesElement.prototype.quickWarn = function(message) {
    DuelingListBoxesElement.warning(this.warnDiv, message);
}

/**
 * Removes the warning message using the warnDiv field (should be set using constructor)
 */
DuelingListBoxesElement.prototype.quickUnwarn = function() {
    DuelingListBoxesElement.removeWarning(this.warnDiv);
}

// instMove* methods are wrappers around the corresponding static move* methods that store selection box state on first
// modification
DuelingListBoxesElement.prototype.instMoveDown = function(sourceSelect, topSourceValue, radicalValue, unmovableAlertMessage,
        warnDivId) {
    this.storeStateOnce();
    DuelingListBoxesElement.moveDown(sourceSelect, topSourceValue, radicalValue, unmovableAlertMessage, warnDivId);
}

DuelingListBoxesElement.prototype.instMoveUp = function(sourceSelect, topSourceValue, radicalValue, unmovableAlertMessage,
        warnDivId) {
    this.storeStateOnce();
    DuelingListBoxesElement.moveUp(sourceSelect, topSourceValue, radicalValue, unmovableAlertMessage,
            warnDivId);
}

DuelingListBoxesElement.prototype.instMoveBottom = function(sourceSelect, warnDivId) {
    this.storeStateOnce();
    DuelingListBoxesElement.moveBottom(sourceSelect, warnDivId);
}

DuelingListBoxesElement.prototype.instMoveTop = function(sourceSelect, warnDivId) {
    this.storeStateOnce();
    DuelingListBoxesElement.moveTop(sourceSelect, warnDivId);
}


DuelingListBoxesElement.prototype.instMoveOption = function(sourceSelect, targetSelect, keepSourceLabel, unmovableSourceValues,
        unmovableAlertMessages, keepTargetLabel, cannotBeEmpty, cannotBeEmptyMessage, warnDivId) {
    this.storeStateOnce();
    DuelingListBoxesElement.moveOption(sourceSelect, targetSelect, keepSourceLabel, unmovableSourceValues,
        unmovableAlertMessages, keepTargetLabel, cannotBeEmpty, cannotBeEmptyMessage, warnDivId, this.removeWarnIf, this.removeWarningText);
}

DuelingListBoxesElement.prototype.instSaveAllSelected = function(fromSelectArray, toArray, delim, escape, emptyLabel) {
    DuelingListBoxesElement.saveAllSelected(fromSelectArray, toArray, delim, escape, emptyLabel);
}

/**
 * Displays the given warning message in the given warning box.
 *
 * @param warnId warning box div id
 * @param message the inner html of the warn text div is replaced with this
 */
DuelingListBoxesElement.warning = function(warnId, message) {
    if (!warnId) {
        return;
    }
    var warnDiv = document.getElementById(warnId);
    if (warnDiv) {
        warnDiv.innerHTML = LC.getLabel("Global", "colonSeparatedWords", LC.getLabel("Global", "error"), message);
        warnDiv.style.display = "block";
    }
}

/**
 * Removes the warning message from the given warning box div.
 *
 * @param warnId warning box div id
 */
DuelingListBoxesElement.removeWarning = function (warnId) {
    if (!warnId) {
        return;
    }
    var warnDiv = document.getElementById(warnId);
    if (warnDiv) {
        warnDiv.innerHTML = ""
        warnDiv.style.display = "none";
    }
}

DuelingListBoxesElement.moveTop = function(sourceSelect, warnDivId) {

    if (sourceSelect.length > 1) {
        var options = sourceSelect.options;

        // find which ones are selected...
        var selectedIds = new Array ();
        var index = 0;

        for (var i = 0; i < sourceSelect.length; i++) {
            if (options[i].selected) {
                selectedIds[index] = i;
                index++;
            }
        }

        // Move each selected option up to the topmost available
        // position.  The first one in the selected list gets position 0,
        // second one gets position 1, and so on.
        var selId;
        for (var i = 0; i < selectedIds.length; i++) {
            selId = selectedIds[i];
            // delta is how many positions up to move the selected item
            // to get it into the target position, which is position "i"
            delta = selId-i;
            for (var j = 0 ; j < delta; j++) {
                DuelingListBoxesElement.privateMoveUp (options, selId-j);
                options[selId-j].selected = false;
                options[(selId-j)-1].selected = true;
                }
        }

        sourceSelect.focus ();

        // invoke if the Slect Element has local function
        if (sourceSelect["onLocalMoveTop"])
            sourceSelect.onLocalMoveTop();
    }
    DuelingListBoxesElement.removeWarning(warnDivId);
}

DuelingListBoxesElement.moveBottom = function(sourceSelect, warnDivId) {

    if (sourceSelect.length > 1) {
        var options = sourceSelect.options;

        // find which ones are selected...
        var selectedIds = new Array ();
        var index = 0;

        for (var i = 0; i < sourceSelect.length; i++) {
            if (options[i].selected) {
                selectedIds[index] = i;
                index++;
            }
        }

        // move each selected option down - starting from the end
        // of the selected items array, we'll move each item down to
        // the next lowest position (i.e., last one in the array ends up at
        // the very bottom, nth one in the array ends up (array length - n) from
        // the bottom
        // targetPos is position the element is moving to
        var targetPos = sourceSelect.length-1;
        var selId;
        for (var i = selectedIds.length-1; i >= 0 ; i--) {
            selId = selectedIds[i];
            // delta is how much to move down from the current position to get to the target position
            var delta = targetPos-selId;
            for (var j = 0 ; j < delta; j++) {
                DuelingListBoxesElement.privateMoveDown (options, selId+j);
                options[selId+j].selected = false;
                options[(selId+j)+1].selected = true;
                }
            targetPos--;
        }

        sourceSelect.focus ();

        // invoke if the Slect Element has local function
        if (sourceSelect["onLocalMoveBottom"])
            sourceSelect.onLocalMoveBottom();
    }
    DuelingListBoxesElement.removeWarning(warnDivId);
}

/*
 * Do not call this function directly.
 * As it does NO bounds checking.
 * Please use the moveUp or moveTop calls.
 */
DuelingListBoxesElement.privateMoveUp = function(options, index) {
    var newOption = new Option (options[index-1].text, options[index-1].value);
    options[index-1].text = options[index].text;
    options[index-1].value = options[index].value;
    options[index].text = newOption.text;
    options[index].value = newOption.value;
}

/*
 * Do not call this function directly.
 * As it does NO bounds checking.
 * Please use the moveDown or moveBottom calls.
 */
DuelingListBoxesElement.privateMoveDown = function(options, index) {
    var newOption = new Option (options[index+1].text, options[index+1].value);
    options[index+1].text = options[index].text;
    options[index+1].value = options[index].value;
    options[index].text = newOption.text;
    options[index].value = newOption.value;
}

DuelingListBoxesElement.moveDown = function(sourceSelect, topSourceValue, radicalValue, unmovableAlertMessage,
        warnDivId) {
    var seenWarn=false;
    if (sourceSelect.length > 1) {
        var options = sourceSelect.options;

        // find which ones are selected
        var selectedIds = new Array ();
        var index = 0;
        if (topSourceValue != null) {
            // make sure we don't move the top value down, unless the second value is the radical value and it's not being moved
            if (topSourceValue == options[0].value && options[0].selected && (options[1].value != radicalValue || options[1].selected)) {
                options[0].selected = false;
                if (unmovableAlertMessage != null) {
                    DuelingListBoxesElement.warning(warnDivId, unmovableAlertMessage);
                    seenWarn=true;
                }
            }
            // when a radical value is specified, also check the second value:
            // second value can't be moved down if it's the topValue
            if (radicalValue && options[1].value == topSourceValue && options[1].selected) {
                options[1].selected = false;
                if (unmovableAlertMessage != null) {
                    DuelingListBoxesElement.warning(warnDivId, nmovableAlertMessage);
                    seenWarn=true;
                }
            }
        }

        for (var i = sourceSelect.length-2; i >= 0; i--) {
            if (sourceSelect.options[i].selected) {
                // add any remaining selected elements to our array of elements to move
                selectedIds[index] = i;
                index++;
            }
        }

        // move each selected element down
        var selId;
        for (var i = 0; i < selectedIds.length; i++) {
            selId = selectedIds[i];
            DuelingListBoxesElement.privateMoveDown (options, selId);
            options[selId].selected = false;
            options[selId+1].selected = true;
        }

        sourceSelect.focus ();

        // invoke if the Slect Element has local function
        if (sourceSelect["onLocalMoveDown"])
            sourceSelect.onLocalMoveDown();
    }
    if (!seenWarn) {
        DuelingListBoxesElement.removeWarning(warnDivId);
    }
}

DuelingListBoxesElement.moveUp = function(sourceSelect, topSourceValue, radicalValue, unmovableAlertMessage,
        warnDivId) {
    if (sourceSelect.length > 1) {
        var options = sourceSelect.options;

        // find which ones are selected...
        var selectedIds = new Array ();
        var index = 0;
        if (topSourceValue != null) {
            // second value can't be moved up if first value is topValue, unless second value is the radical value
            if (options[0].value == topSourceValue && options[1].selected && options[1].value != radicalValue) {
                options[1].selected = false;
                if (unmovableAlertMessage != null) {
                    DuelingListBoxesElement.warning(warnDivId, unmovableAlertMessage);
                    return;
                }
            }
            // when a radical value is specified, apply the same rule to the third value:
            // third value can't be moved up if second value is topValue OR if second value is going to be moved up
            if (radicalValue && options[2].selected && (options[1].value == topSourceValue || options[1].selected)) {
                options[2].selected = false;
                if (unmovableAlertMessage != null) {
                    DuelingListBoxesElement.warning(warnDivId, unmovableAlertMessage);
                    return;
                }
            }
            // notice the return statements:  if any one option cannot be moved up, then
            // do not move up any of the options
        }
        for (var i = 1; i < sourceSelect.length; i++) {
            if (options[i].selected) {
                selectedIds[index] = i;
                index++;
            }
        }

        // move each selected option up
        var selId;
        for (var i = 0; i < selectedIds.length; i++) {
            selId = selectedIds[i];
            DuelingListBoxesElement.privateMoveUp (options, selId);
            options[selId].selected = false;
            options[selId-1].selected = true;
        }

        sourceSelect.focus ();

        // invoke if the Slect Element has local function
        if (sourceSelect["onLocalMoveUp"])
            sourceSelect.onLocalMoveUp();
    }
    DuelingListBoxesElement.removeWarning(warnDivId);
}


DuelingListBoxesElement.moveOption = function(sourceSelect, targetSelect, keepSourceLabel, unmovableSourceValues,
                        unmovableAlertMessages, keepTargetLabel, cannotBeEmpty, cannotBeEmptyMessage, warnDivId, removeWarnIf, removeWarningText) {
	// Adding a warning placeholder for when a user tries to remove the default landing tab in Customize My Tabs.
	if (removeWarnIf && removeWarnIf()){
		if (!((Modal.confirm && Modal.confirm(removeWarningText)) || (!Modal.confirm && window.confirm(removeWarningText))))
			return;
	}

    var seenWarn=false;
    var sourceOptions = sourceSelect.options;

    var canMove;
    var option;

    // find which ones are selected...
    var selectedIds = new Array ();
    var index = 0;
    if (sourceSelect.cannotBeEmpty || cannotBeEmpty) {
        var numSelected = 0;
        for (var i = 0; i < sourceSelect.length; i++) {
            if (sourceSelect.options[i].selected) numSelected++;
        }
        if (numSelected == sourceSelect.options.length) {
            if (sourceSelect.handleEmptyList) {
                sourceSelect.handleEmptyList();
            }
            if (cannotBeEmptyMessage) {
                DuelingListBoxesElement.warning(warnDivId, cannotBeEmptyMessage);
            }
            return;
        }
    }

    for (var i = 0; i < sourceSelect.length; i++) {
        option = sourceOptions[i];
        if (option.selected) {
            canMove = (option.text != keepSourceLabel);
            if (canMove && unmovableSourceValues != null) {
                // make sure we don't move any options defined as unmovable
                for (var j = 0; j < unmovableSourceValues.length; j++) {
                    if (unmovableSourceValues[j] == option.value) {
                        canMove = false;
                        if (unmovableAlertMessages[j] != null) {
                            DuelingListBoxesElement.warning(warnDivId, unmovableAlertMessages[j]);
                            seenWarn=true;
                        }
                        break;
                    }
                }
            }

            // if this option can be moved we add it to our array of elements to move
            if (canMove) {
                selectedIds[index] = i;
                index++;
            } else {
                // if we can't move this option, then unselect it
                option.selected = false;
            }
        }
    }

    // move them over one by one
    var targetOptions = targetSelect.options;
    if (selectedIds.length > 0) {
        targetSelect.selectedIndex = -1;
        for (var i = 0; i < selectedIds.length; i++) {
            option = new Option (sourceOptions[selectedIds[i]].text, sourceOptions[selectedIds[i]].value);
            option.title = sourceOptions[selectedIds[i]].title;

            // replace the target value if its the last one
            if (targetOptions.length == 1 && targetOptions[0].text == keepTargetLabel) {
                targetOptions[0] = option;
                targetOptions[0].selected = true;
            } else {
                targetOptions[targetOptions.length] = option;
                targetOptions[targetOptions.length-1].selected = true;
            }
        }
    }

    // notify the Select Elements that their contents have changed
    if (targetSelect["onchange"]) {
        targetSelect.onchange();
    }
    if (sourceSelect["onchange"]) {
        sourceSelect.onchange();
    }

    // remove selected values from the source, starting with the last one selected
    for (var i = selectedIds.length - 1; i > -1; i--) {
        sourceSelect.remove(selectedIds[i]);
    }

    // Workaround here for a bug in IE:
    // If you have a select element with many values, and you've scrolled to
    // the bottom and move an option from the top-most element you can now see,
    // IE would not refresh the select element, leaving a hole in the list.
    // By forcing the select element disabled and back, it seems to refresh the
    // element properly.
    sourceSelect.disabled = true;
    sourceSelect.disabled = false;

    // make sure we don't get an empty list
    if (sourceOptions.length == 0) {
        sourceOptions[0] = new Option (keepSourceLabel, keepSourceLabel);
    }

    // if we moved anything, put the focus on the target list box
    if (selectedIds.length > 0) targetSelect.focus ();

    // invoke if the Slect Element has local function
    if (targetSelect["onLocalMoveOptions"])
        targetSelect.onLocalMoveOptions();
    if (sourceSelect["onLocalMoveOptions"])
        sourceSelect.onLocalMoveOptions();
    if (! seenWarn) {
        DuelingListBoxesElement.removeWarning(warnDivId);
    }
}

/**
 * Used when submitting a dueling list boxes element.
 * Stores all the values into hidden form parameters so we can get them out
 */
DuelingListBoxesElement.saveAllSelected = function(fromSelectArray, toArray, delim, escape, emptyLabel) {
    var i,j,escapedValue;
    // loop through all the select elements
    for (i = 0; i < fromSelectArray.length; i++) {
        toArray[i].value = ''; // clear out the value to start
        // now loop through all the values in the select element
        for (j = 0; j < fromSelectArray[i].length; j++) {
            // copy over the value as long as it is not the emptyLabel
            if (!(fromSelectArray[i].length == 1 && fromSelectArray[i].options[0].value == emptyLabel)) {
                var val = fromSelectArray[i].options[j].value.replace(new RegExp(escape+escape,"g"), escape+escape);
                toArray[i].value += val.replace(new RegExp(delim,"g"), escape+delim);
            }

            // add the delimiter (except after the last one)
            if (j + 1 < fromSelectArray[i].length) {
                toArray[i].value += delim;
            }
        }
    }
}

/**
 * Implementation of QueryString object in JS.
 * It's not guaranteed to handle UTF8 encoding properly;
 * feel free to add/test it.
 */
var QueryString = function(qs, allowMultipleValuesForParam) {

	this.allowMultipleValuesForParam = allowMultipleValuesForParam;
    this.params = new Object();

    if (qs == null)
        qs = location.search.substring(1, location.search.length);

    if (qs.length == 0) return;

    qs = qs.replace(/\+/g, ' ');
    var args = qs.split('&');

    for (var i = 0 ; i < args.length ; i++) {
        var index = args[i].indexOf('=');
        if (index > 0) {
            var name = decodeURIComponent(args[i].substr(0, index));
            var value = decodeURIComponent(args[i].substr(index+1));
			this.add(name, value);
        }
    }
}

QueryString.prototype.get = function (name, defaultVal) {
    var value = this.params[name];
    if (value) {
        return value;
    }
    else
        if (defaultVal){
            return defaultVal;
        } else {
            return null;
        }
}

QueryString.prototype.add = function(name, value) {
	if(!this.allowMultipleValuesForParam){
    	this.params[name] = value;
	} else {
		var valueArray =  this.params[name];
		if(!valueArray) {
        	valueArray = new Array();
        	valueArray[0] = value;
        } else {
        	valueArray[valueArray.length] = value;
        }
        this.params[name] = valueArray;
	}
}

QueryString.prototype.remove = function(name) {
    this.params[name] = null;
}

QueryString.prototype.toString = function() {
    var str = "?";
    for (var name in this.params) {
        var value = this.params[name];
        if (value != undefined) {
        	if(!this.allowMultipleValuesForParam){
            	str = str + name + "=" + encodeURIComponent(value) + "&";
        	} else {
        		for (var ind = 0; ind < value.length; ind++){
        			if(value[ind]) {
        				str = str + name + "=" + encodeURIComponent(value[ind]) + "&";
        			}
        		}
        	}
        }
    }
    return str;
}



/**
*     Manages the skiplinks and associated hovering lists
*     at the top of the detail page
*     see RelatedListPanelElement
* @author mpolcari
* @since 142.ml
*/
function RelatedListPanel(rlPanelId) {
  this.panelId = rlPanelId;
  this.currentListId = null;
  this.delayingHide = null;
  this.delayingShow = null;
  this.numLists = 0;
  this.linksHtml = [];
  this.isConsole = location.search.indexOf(Desktop['IS_DESKTOP']) > -1;
}

RelatedListPanel.prototype.getPanelNode = function() {
  return document.getElementById(this.panelId);
}

RelatedListPanel.prototype.getPanelShadowNode = function() {
  return (this.getPanelNode()) ? this.getPanelNode().parentNode : null;
}

RelatedListPanel.prototype.getIFrameNode = function() {
  return DomUtil.findDescendantWithTag(this.getPanelNode(), 'iframe');
}

RelatedListPanel.prototype.registerList = function(relatedList) {
  this.linksHtml.push(this.getHoverableLinkHTML(relatedList));
}

/**
* Adds the hoverLinks to the panel
*      must be run after onLoad()
*/
RelatedListPanel.prototype.addListsToPanel = function() {
  var linksNode = this.getHoverableLinksNode();
  if (linksNode.innerHTML.indexOf("linklet") < 0) {
    linksNode.innerHTML = this.linksHtml.join('<span class="pipe"> | </span>');
  }
  linksNode.style.visibility = 'visible';
}

RelatedListPanel.prototype.getHoverableLinkHTML = function (relatedList) {
  var buf = [];
  buf.push('<a class="linklet" href="#');
  buf.push(relatedList.getLinkTarget());
  buf.push('" id="');
  buf.push(this.getLinkId(relatedList.listId));
  buf.push('"');
  if(!relatedList.isOnlySkipLink){
	  buf.push(' onmouseover="sfdcPage.relatedListPanel.showRLDelayed(\'');
	  buf.push(relatedList.listId);
	  buf.push('\')" onmouseout="sfdcPage.relatedListPanel.hideRLDelayed(\'');
	  buf.push(relatedList.listId);
	  buf.push('\')" onclick="sfdcPage.relatedListPanel.hideRL(\'');
	  buf.push(relatedList.listId);
  }
  buf.push('\')"><span class="listTitle">');
  buf.push(relatedList.getTitle());
  buf.push(this.getCountIndicator(relatedList));
  buf.push('</span></a>');
  return  buf.join('');
}

RelatedListPanel.prototype.getCountIndicator = function (relatedList) {
  var html = [];
  html.push('<span class="count">[');
  html.push(relatedList.getNumberVisibleRows());
  if (relatedList.hasMore()) {
    html.push('<span class="plus">+</span>');
  }
  html.push(']</span>');
  return html.join('');
}

RelatedListPanel.prototype.getHoverableLinksNode = function() {
  return this.getPanelShadowNode().nextSibling;
}

RelatedListPanel.prototype.showRLDelayed = function(rlId) {
  this.clearhidemenu();
  if (this.currentListId && (this.currentListId != rlId)) {
    this.hideRL(this.currentListId);
    this.populateRL(rlId);
    this.showRL(rlId);
  } else {
    //clearshowmenu();
    var self = this;
    this.delayingShow = setTimeout(function() {self.showRL(rlId);}, 500);
    this.populateRL(rlId); // This way the time it takes to populate the list is not part of the timing delay
  }
}

RelatedListPanel.prototype.hideRLDelayed = function(rlId, delay) {
  this.clearshowmenu();
  if (!delay) delay = 50;
  if (!rlId) rlId = this.currentListId;
  var self = this;
  this.delayingHide = setTimeout(function() { self.hideRL(rlId); }, delay);
}

RelatedListPanel.prototype.getStyleSheetHtml = function() {
  var sheetHtml = []
  for (var i = 0; i< document.styleSheets.length; i++){
    if (document.styleSheets[i].owningElement && document.styleSheets[i].owningElement.outerHTML) {
      sheetHtml.push(document.styleSheets[i].owningElement.outerHTML);
    }
  }
  return sheetHtml.join('');
}

RelatedListPanel.prototype.populateRL = function(rlId) {
  if (!rlId) rlId = this.currentListId;

  if (this.currentListId != rlId) {
    var panelFrameNode = this.getIFrameNode();
    if (!panelFrameNode) return;
    var relatedListNode = document.getElementById(rlId);
    var iFrameDoc =  panelFrameNode.contentWindow.document;

    if (!(relatedListNode && iFrameDoc)) return;
    this.currentListId = rlId;
    if (iFrameDoc.importNode) { //ffox
      iFrameDoc.body.innerHTML = '';
      iFrameDoc.body.appendChild(iFrameDoc.importNode(relatedListNode, false));
      iFrameDoc.body.firstChild.innerHTML = relatedListNode.innerHTML;
    } else if (relatedListNode.outerHTML) {
      iFrameDoc.body.innerHTML = relatedListNode.outerHTML; // ie
    } else {
      return false;
    }
    var self = this;
    setTimeout(function() { self.fixContent(); }, 1);  //fire this asynchronously
    panelFrameNode.contentWindow.navigateToUrl = function(url) {
    	// window here actually refers to contentWindow.parent because of the context it's executed in, strange huh?
        window.navigateToUrl(url);
      };
  }
}

//forceResize: without forceResize, we will not resize the iframe
//             if the rl in question is already displayed
RelatedListPanel.prototype.showRL = function(rlId, forceResize) {
    this.clearhidemenu();

    if (rlId != this.currentListId) return;  //if the id's don't match, the panel has been cleared since the last hover.  It should not display
    var panelShadowNode = this.getPanelShadowNode();
    if (!panelShadowNode) return;
    var panelFrameNode = this.getIFrameNode();
    var linkletNode = document.getElementById(this.getLinkId(rlId));
    var relatedListNode = DomUtil.findDescendantWithClassName(document.getElementById(rlId), 'bPageBlock');
    if (!( panelFrameNode && linkletNode)) return;
    if (linkletNode.className.indexOf('linkletOn') > 0 && (!forceResize)) return;
    panelShadowNode.style.top = (linkletNode.offsetTop + linkletNode.offsetHeight) + "px";
    if (this.isConsole) {
    	//console has no margins, so this needs to be narrower
        panelShadowNode.style.left = (getObjX(this.getHoverableLinksNode()) - 4) + "px";
        panelShadowNode.style.width = (relatedListNode.offsetWidth - 3) + "px";
    } else {
        panelShadowNode.style.left = (getObjX(this.getHoverableLinksNode()) - 14) + "px";
        panelShadowNode.style.width = (relatedListNode.offsetWidth + 13) + "px"; //5 for each margin + 2 for shadow + 1 for border
    }
    panelFrameNode.style.height = (relatedListNode.offsetHeight + 5) + "px";
    panelShadowNode.style.display = 'block';
    linkletNode.className += ' linkletOn';
}


RelatedListPanel.prototype.hideRL = function(rlId) {
  if (!(Modal.isBlocked())) {
    this.clearshowmenu();
    if (!rlId) rlId = this.currentListId;
    this.currentListId = null;
    var panelShadowNode = this.getPanelShadowNode();
    var linklet = document.getElementById(this.getLinkId(rlId));
    if (linklet) linklet.className = 'linklet';
    if (panelShadowNode) panelShadowNode.style.display = 'none';
  }
}

RelatedListPanel.prototype.clearhidemenu = function(){
  if (this.delayingHide) {
    clearTimeout(this.delayingHide);
  }
}

RelatedListPanel.prototype.clearshowmenu = function(){
  if (this.delayingShow) {
    clearTimeout(this.delayingShow);
  }
}

RelatedListPanel.prototype.getLinkId = function (relatedListId) {
  return relatedListId + '_link';
}

RelatedListPanel.prototype.fixContent = function() {
  var targetableTags = ['a', 'form'];

    var iframeWin = this.getIFrameNode().contentWindow;

  for (var i = 0, tag; tag = targetableTags[i]; i++) {
    var tags = iframeWin.document.body.getElementsByTagName(tag);
    for (var k = 0, node; node = tags[k]; k++) {
      if (!node.target) { node.target = '_parent'; }
    }
  }
    var scripts = iframeWin.document.body.getElementsByTagName("script");
    for (var i = 0; i < scripts.length; i++) {
        iframeWin.eval(scripts[i].innerHTML);
    }
}


   function AdvCurrencyEnable() {}

   AdvCurrencyEnable.checkSaveButton = function(checkCheckBox) {
		var checked;
		if (checkCheckBox) {
			checked = document.getElementById(AdvancedCurrencyEnable.pENABLE).checked;
		} else {
			checked = ! document.getElementById(AdvancedCurrencyEnable.pENABLE).checked;
		}
 		//check if any of the input values are checked so that we allow the user to save by enabling the save button
   		if (checked) {
   			document.getElementsByName(AdvancedCurrencyEnable.enableButton)[0].className = 'btn';
            document.getElementsByName(AdvancedCurrencyEnable.enableButton)[0].disabled = false;
   		} else {
        	document.getElementsByName(AdvancedCurrencyEnable.enableButton)[0].className = 'btnDisabled';
            document.getElementsByName(AdvancedCurrencyEnable.enableButton)[0].disabled = true;
   		}
   }

var MultiSelectPicklist = {};

MultiSelectPicklist.loadMSP = function(id) {
    var sElem = getElementByIdCS(id + '_selected');
    var uElem = getElementByIdCS(id + '_unselected');
    
    //this is a stupid hack to keep the optgroup labels from disappearing
    if (isSafari) {
	    for(i=0; i < sElem.childNodes.length; i++) {
        	var ch = sElem.childNodes[i]
	        if (ch.nodeName == "OPTGROUP") {
	        	ch.appendChild(document.createElement("p"));
	        }
	    }
	    
   	    for(i=0; i < uElem.childNodes.length; i++) {
        	var ch = uElem.childNodes[i]
	        if (ch.nodeName == "OPTGROUP") {
	        	ch.appendChild(document.createElement("p"));
	        }
	    }
    }
    
    MultiSelectPicklist.resizeMSP(sElem, uElem);
}

MultiSelectPicklist.resizeMSP = function(sElem, uElem) {
    if (!sElem || !uElem) return;
    if (!sElem.style.width) {
        var selW = (sElem.scrollWidth > uElem.scrollWidth) ? sElem.scrollWidth : uElem.scrollWidth;
        selW = selW + 35;
        sElem.style.width = selW + "px";
        uElem.style.width = selW + "px";

    }
}

MultiSelectPicklist.handleMSPChange = function(sel) {
    var sElem = getElementByIdCS(sel.id + '_selected');
    var uElem = getElementByIdCS(sel.id + '_unselected');

    //Safari handles optgroups differently and requires explicit DOM manipulation
    if (isSafari) {
    	var sDepth;
    	var uDepth;
    	
	    for(i=0; i < sElem.childNodes.length; i++) {
        	var ch = sElem.childNodes[i]
	        if (ch.nodeName == "OPTGROUP") {
	        	sDepth = i;
				var chlen = ch.childNodes.length
        	    for(j=0; j<chlen; j++) {
            	    ch.removeChild(ch.childNodes[0]);
            	}
            	ch.appendChild(document.createElement("p"));
        	}
    	}
    	
    	for(i=0; i < uElem.childNodes.length; i++) {
        	var ch = uElem.childNodes[i]
	        if (ch.nodeName == "OPTGROUP") {
				uDepth = i;
				var chlen = ch.childNodes.length
        	    for(j=0; j<chlen; j++) {
            	    ch.removeChild(ch.childNodes[0]);
            	}
            	ch.appendChild(document.createElement("p"));
        	}
    	}
    	
    	for (i=0; i < sel.options.length; i++) {
    		if (sel.options[i].value != picklistNAMarker) {
			    var o = document.createElement("option");
			    o.text = sel.options[i].text;
			    o.value = i;
    			
    			if (sel.options[i].selected) {
    				sElem.childNodes[sDepth].appendChild(o);
    			} else {
    				uElem.childNodes[uDepth].appendChild(o);
    			}
    		}
    	}
    } else {
	    var sI = 0;
	    var uI = 0;

    	sElem.length = 0;
	    uElem.length = 0;
	    
	    for (var i = 0; i < sel.options.length; i++) {
	        if (sel.options[i].value != picklistNAMarker) {
	           if (sel.options[i].selected) {
	                sElem.options[sI] = new Option(sel.options[i].text, i);
	                sI++;
	            } else {
	                uElem.options[uI] = new Option(sel.options[i].text, i);
	                uI++;
	            }
	        }
	    }
    }

    MultiSelectPicklist.resizeMSP(sElem, uElem);
}

MultiSelectPicklist.handleMSPSelect = function(selId) {
    var mainElem = getElementByIdCS(selId);
    var uElem = getElementByIdCS(selId + '_unselected');
    for (var i = 0; i < uElem.options.length; i++) {
        if (uElem.options[i].selected) {
            mainElem.options[parseInt(uElem.options[i].value)].selected = true;
        }
    }
    MultiSelectPicklist.handleMSPChange(mainElem);
}

MultiSelectPicklist.handleMSPUnSelect = function(selId) {
    var mainElem = getElementByIdCS(selId);
    var sElem = getElementByIdCS(selId + '_selected');
    for (var i = 0; i < sElem.options.length; i++) {
        if (sElem.options[i].selected) {
            mainElem.options[parseInt(sElem.options[i].value)].selected = false;
        }
    }
    MultiSelectPicklist.handleMSPChange(mainElem);
}
/**
 * This class basically has a bunch of static methods.  It's a class for namespace protection.
 * 
 *  @author emoses
 *  @since 144
 */
function ProfileEditClass(warningmsg) {
	this.crudDeleteWarningMsg = warningmsg;
	this.isPropagating = false;
};

//A global to deal with namespacing issues with the "this" keyword.  Must be instancated on the profile edit page.
var ProfileEdit;

ProfileEditClass.prototype.changeAndPropagate = function(element, newState){
	if (!element) return;
	
	var wasFlipped = element.checked != newState;	
	// If we're not making a change, don't bother propagating.  Simpler this way.
	if (!wasFlipped) return;
	
	element.checked = newState;
	if (element.id.indexOf("crud") === 0){
		ProfileEdit.handleCrudDependencyClick(element, wasFlipped);
	} else {
		ProfileEdit.handlePermDependencyClick(element);
	}
}

ProfileEditClass.prototype.doDependencies = function(id, map, newState){
	if (id in map){
		var dependents = map[id];
		for (var i = 0; i < dependents.length; i++){
			var dependent = document.getElementById(dependents[i]);
			if (dependent){
				ProfileEdit.changeAndPropagate(dependent, newState);
			}
		}
	}
}

ProfileEditClass.prototype.handlePermDependencyClick = function(checkbox){
	if (checkbox.checked){
		//This was just checked
		ProfileEdit.doDependencies(checkbox.id, permDependencies, true);
	} else {
		//This was just unchecked
		ProfileEdit.doDependencies(checkbox.id, permAntecedents, false);
	}
}

ProfileEditClass.prototype.handleCrudDependencyClick = function(checkbox, wasFlippedIn){
	//If the call is coming from the checkbox element itself, wasFlippedIn will be undefined, and we can
	//be sure that the checkbox was actually flipped.  Otherwise, use the value that was passed in
	var wasFlipped = arguments.length > 1 ? wasFlippedIn : true;

	if (checkbox.checked){
		ProfileEdit.doDependencies(checkbox.id, permDependencies, true);
		if (checkbox.id.indexOf(ProfileEditConstants.CRUD_CREATE) === 0){
			var crudid = checkbox.id.substring(ProfileEditConstants.CRUD_CREATE.length);
			ProfileEdit.changeAndPropagate(document.getElementById(ProfileEditConstants.CRUD_READ + crudid), true);
		} else if (checkbox.id.indexOf(ProfileEditConstants.CRUD_UPDATE) === 0){
			var crudid = checkbox.id.substring(ProfileEditConstants.CRUD_UPDATE.length);
			ProfileEdit.changeAndPropagate(document.getElementById(ProfileEditConstants.CRUD_READ + crudid), true);
		} else if (checkbox.id.indexOf(ProfileEditConstants.CRUD_DELETE) === 0){
			var crudid = checkbox.id.substring(ProfileEditConstants.CRUD_DELETE.length);
			ProfileEdit.changeAndPropagate(document.getElementById(ProfileEditConstants.CRUD_UPDATE + crudid), true);
			ProfileEdit.changeAndPropagate(document.getElementById(ProfileEditConstants.CRUD_READ + crudid), true);
		}
	} else {
		if (checkbox.id.indexOf(ProfileEditConstants.CRUD_READ) === 0){
			var crudid = checkbox.id.substring(ProfileEditConstants.CRUD_READ.length);
			ProfileEdit.changeAndPropagate(document.getElementById(ProfileEditConstants.CRUD_CREATE + crudid), false);
			ProfileEdit.changeAndPropagate(document.getElementById(ProfileEditConstants.CRUD_UPDATE + crudid), false);
			ProfileEdit.changeAndPropagate(document.getElementById(ProfileEditConstants.CRUD_DELETE + crudid), false);
		} else if (checkbox.id.indexOf(ProfileEditConstants.CRUD_UPDATE) === 0){
			var crudid = checkbox.id.substring(ProfileEditConstants.CRUD_UPDATE.length);
			ProfileEdit.changeAndPropagate(document.getElementById(ProfileEditConstants.CRUD_DELETE + crudid), false);
		} else if (checkbox.id.indexOf(ProfileEditConstants.CRUD_DELETE) === 0){
			var crudid = checkbox.id.substring(ProfileEditConstants.CRUD_DELETE.length);
			if (crudid in childrenToParents && wasFlipped && !this.isPropagating){
				if (childrenToParents[crudid].length > 0){
						alert(this.crudDeleteWarningMsg);
				}
			}
		}
		if (!this.isPropagating){
			this.isPropagating = true;
			ProfileEdit.doDependencies(checkbox.id, permAntecedents, false);
			this.isPropagating = false;
		} else {
			ProfileEdit.doDependencies(checkbox.id, permAntecedents, false);
		}
	}
		
}

/**
 *  This is a singleton class. Its one instance will live in TabSetLimiter.prototype.theTabSetLimiter.
 *  To create a new one, simply make a call to "new TabSetLimiter(n)", where n is the number of allowable tabsets
 *
 *  The public funcitons are registerControl(TabSetControl) and handleChange(TabSetControl).
 *  @author emoses
 */
function TabSetLimiter(newLimit){ 
	//singleton
	if(TabSetLimiter.prototype.theTabSetLimiter){ return TabSetLimiter.prototype.theTabSetLimiter; }
	TabSetLimiter.prototype.theTabSetLimiter = this;
	
	var limit = newLimit;
	var limitedControls = [];
	var checkedControls = []; //queue
	var self = this;
	
	function checkLimits(){
		while (checkedControls.length > limit){
			if (checkedControls[0].defaultC.checked){
				//Move the second item to the front of the queue
				var temp = checkedControls[1];
				checkedControls[1] = checkedControls[0];
				checkedControls[0] = temp;
			}
			var currControl = checkedControls.shift();
			if (!currControl){
				alert("Error: Inconsistent state.");
			}
			currControl.visibleC.checked = false;
		}
	}
	
	this.registerControl = function(control){
		if (!control) return;
		if (limit == 1){
			control.visibleC.disabled = true;
		}
		limitedControls.push(control);
		if (control.visibleC.checked){
			checkedControls.push(control);
		}
		checkLimits();
	}
	
	this.handleChange = function(control){;
		var found = false;
		for (var i = 0; i < limitedControls.length; i++){
			if (limitedControls[i] === control){
				found = true;
				break;
			}
		}
		if (!found) return;
		
		if (control.visibleC.checked){
			//If it's already in checkedControls, we don't have to do anything.
			//This might happen if a checked control gets switched to default.
			for (var i = 0; i < checkedControls.length; i++){
				if (checkedControls[i] === control){
					return;
				}
			}
			checkedControls.push(control);
			checkLimits();
		} else {
			for (var i = 0; i < checkedControls.length; i++){
				if (checkedControls[i] === control){
					checkedControls.splice(i, 1);
					break;
				}
			}
		}
	}
}
	
/**
 * @author emoses
 * 
 * This represents a "visible" checkbox paired with a "default" radio button.  
 * Make sure that any time a change is made, if there's a TabSetLimiter instanciated,
 * that its handleChange method gets called
 */
function TabSetControl(visibleid, defaultid, isCustom){
	var self = this;
	this.visibleC = document.getElementById(visibleid);
	this.defaultC = document.getElementById(defaultid);
	
	if (this.visibleC == null || this.defaultC == null){
		return false;
	}
	
	this.handleDefaultChange = function(){
		if (self.defaultC.checked){
			self.visibleC.checked = true;
			self.visibleC.disabled = true;
			otherDefaults = document.getElementsByName(self.defaultC.name);
			if (!(TabSetLimiter.prototype.theTabSetLimiter) || TabSetLimiter.prototype.theTabSetLimiter.limit > 1){
				for (var i = 0; i < otherDefaults.length; i++){
					if (otherDefaults[i] != self.defaultC){
						otherDefaults[i].assocCheckbox.disabled = false;
					}
				}
			}
			if (TabSetLimiter.prototype.theTabSetLimiter){
				TabSetLimiter.prototype.theTabSetLimiter.handleChange(self);
			}
		}
	}
	
	this.handleVisibleChange = function(e){
		var target = getEventTarget(getEvent(e));
		TabSetLimiter.prototype.theTabSetLimiter.handleChange(self);
	}
	
	//init code
	addEvent(self.defaultC, 'click', self.handleDefaultChange);
	self.defaultC.assocCheckbox = self.visibleC;
	if (self.defaultC.checked) { self.visibleC.disabled = true; }
	if (TabSetLimiter.prototype.theTabSetLimiter != null && isCustom){
		TabSetLimiter.prototype.theTabSetLimiter.registerControl(self);
		addEvent(self.visibleC, 'click', self.handleVisibleChange, false);
	}
}
	
	
function WebLinkUi(){}

// Update the options for openType according to the displaytype
WebLinkUi.prototype.updateOpenType = function(openType, newWinVal, allow) {
    var typeSelect = document.getElementById(openType);
    var opts = typeSelect.options;
    if (typeSelect._saveOpts == null) {
        typeSelect._saveOpts = new Array(opts.length);
        for (var i = 0; i < opts.length; ++i) {
           typeSelect._saveOpts[i] = opts[i];
        }
    }
    var selectedVal = opts[typeSelect.selectedIndex].value;
    if (selectedVal == newWinVal && !allow) {
        selectedVal = opts[0].value;
    }
    opts.length = 0;
    for (var i = 0; i < typeSelect._saveOpts.length; ++i) {
        var opt = typeSelect._saveOpts[i];
        opt.selected = (opt.value == selectedVal);
        if (allow || opt.value != newWinVal) {
            opts[opts.length] = opt;
        }
    }
}

// Hides or shows RequireRowSelection according to displaytype
WebLinkUi.prototype.updateRequireRowSelectionVisibility = function(rowSectionId, show){
	this.setDisplay(rowSectionId, show);
}

WebLinkUi.prototype.setContentType = function(id, isJs, jsValue, defValue) {
    var elem = document.getElementById(id);
    if (elem==null) return;
    if (isJs) {
       elem.value = jsValue;
    } else if (elem.value == jsValue) {
        var opts = elem.options;
        if (opts != null) {
            for (var i = 0; i < opts.length; ++i) {
               if (opts[i].value == defValue) {
                   opts[i].selected = true;
                   return;
                }
            }
            opts[0].selected = true;
        }
    }
}

WebLinkUi.prototype.currentDisplayedDiv = null;
WebLinkUi.prototype.displayDiv = function(div) {
    if (WebLinkUi.prototype.currentDisplayedDiv) {
        WebLinkUi.prototype.currentDisplayedDiv.style.display = 'none';
    }

    var d = document.getElementById(div);
    d.style.display = 'block';
    d.style.zIndex = 0;
    WebLinkUi.prototype.currentDisplayedDiv = d;
}


WebLinkUi.prototype.setDisplay = function(id, vis) {
    var d = document.getElementById(id);
    if (d) {
        if (vis) {
            d.style.display = 'block';
        } else {
            d.style.display = 'none';
        }
     }
}

/*
 * keyCode constants (note: NOT the same as ASCII, as returned by charCode)
 * These are returned only by onkeydown and onkeyup events.
 * Onkeypress returns either an ASCII value or (in Firefox) 0.
 * Note that some of these differ by OS and keyboard layout.
 * These values are for a standard English keyboard on Windows XP.
 * Some function keys do not trigger onkey* events in Safari.
 * Most keycodes are the same across platforms, with the only significant
 * differences being with function and modifier keys.  When in doubt, test.
 */

/**
 * Note when checking KEY_ENTER on keyup events that if the sequence
 * started with KEY_PROCESS onkeydown, then the user may be using IME to enter
 * characters (such as Japanese Hiragana).  The enter in this situation
 * should not be treated as accept/submit/etc.
 * http://bugforce.soma.salesforce.com/bug/bugDetail.jsp?id=100000000000qY0
 */
/* common keys */
var KEY_BACKSPACE = 8;
var KEY_TAB = 9;
var KEY_ENTER = 13;
var KEY_ESC = 27;
var KEY_SPACE = 32;

/* directions */
var KEY_PAGEDOWN = 33;
var KEY_PAGEUP = 34;
var KEY_ARROW_L = 37;
var KEY_ARROW_U = 38;
var KEY_ARROW_R = 39;
var KEY_ARROW_D = 40;

/* modifiers */
var KEY_SHIFT = 16;
var KEY_CTRL = 17;
var KEY_ALT = 18;
var KEY_CAPSLOCK = 20;

/* numbers (above the letters) */
var KEY_0 = 48;
var KEY_1 = 49;
var KEY_2 = 50;
var KEY_3 = 51;
var KEY_4 = 52;
var KEY_5 = 53;
var KEY_6 = 54;
var KEY_7 = 55;
var KEY_8 = 56;
var KEY_9 = 57;

/* letters */
var KEY_A = 65;
var KEY_B = 66;
var KEY_C = 67;
var KEY_D = 68;
var KEY_E = 69;
var KEY_F = 70;
var KEY_G = 71;
var KEY_H = 72;
var KEY_I = 73;
var KEY_J = 74;
var KEY_K = 75;
var KEY_L = 76;
var KEY_M = 77;
var KEY_N = 78;
var KEY_O = 79;
var KEY_P = 80;
var KEY_Q = 81;
var KEY_R = 82;
var KEY_S = 83;
var KEY_T = 84;
var KEY_U = 85;
var KEY_V = 86;
var KEY_W = 87;
var KEY_X = 88;
var KEY_Y = 89;
var KEY_Z = 90;

/* special Windows-only keys */
var KEY_WINDOWS_L = 91;
var KEY_WINDOWS_R = 92;
var KEY_SELECT = 93;

/* numbers (numpad) */
var KEY_NUMPAD_0 = 96;
var KEY_NUMPAD_1 = 97;
var KEY_NUMPAD_2 = 98;
var KEY_NUMPAD_3 = 99;
var KEY_NUMPAD_4 = 100;
var KEY_NUMPAD_5 = 101;
var KEY_NUMPAD_6 = 102;
var KEY_NUMPAD_7 = 103;
var KEY_NUMPAD_8 = 104;
var KEY_NUMPAD_9 = 105;
var KEY_NUMPAD_MULTIPLY = 106;
var KEY_NUMPAD_PLUS = 107;
var KEY_NUMPAD_MINUS = 109;
var KEY_NUMPAD_DECIMAL = 110;
var KEY_NUMPAD_DIVIDE = 111;

/* function keys */
var KEY_F1 = 112;
var KEY_F2 = 113;
var KEY_F3 = 114;
var KEY_F4 = 115;
var KEY_F5 = 116;
var KEY_F6 = 117;
var KEY_F7 = 118;
var KEY_F8 = 119;
var KEY_F9 = 120;
var KEY_F10 = 121;
var KEY_F11 = 122;
var KEY_F12 = 123;

/* everything else */
var KEY_PAUSE = 19;
var KEY_END = 35;
var KEY_HOME = 36;
var KEY_INSERT = 45;
var KEY_DELETE = 46;
var KEY_NUMLOCK = 144;
var KEY_SCROLLLOCK = 145;
var KEY_SEMICOLON = 186;
var KEY_EQUALS = 61;
var KEY_COMMA = 188;
var KEY_DASH = 109;
var KEY_PERIOD = 190;
var KEY_FORWARDSLASH = 191;
var KEY_GRAVE = 192;
var KEY_OPENBRACKET = 219;
var KEY_BACKSLASH = 220;
var KEY_CLOSEBRACKET = 221;
var KEY_APOSTROPHE = 222;
var KEY_PROCESS = 229;

/*
 * @author ldelascurain
 * @since 154
 *
 */

function PortalTabSetEditor( selectToUpdateId ) {
	this.selectToUpdateId = selectToUpdateId;
};

PortalTabSetEditor.prototype.update = function( availableSelectId ) {
	var selectedTabs = document.getElementById(availableSelectId);
	var selectToUpdate = document.getElementById(this.selectToUpdateId);
	var selectedDefault = selectToUpdate.options[selectToUpdate.selectedIndex].value;
	var options = selectedTabs.options;
	var optionsArr = [];
	var isSelectedInOptions = false;

	for (var i=0;i<options.length;i++) {
		var option = options[i];
		optionsArr[i] = [option.text, option.value];
		if (option.value==selectedDefault){
			isSelectedInOptions = true;
		}
	}

	if (!isSelectedInOptions) {
		selectedDefault = optionsArr[0].value;
	}

	Util.refreshDynamicSelect(selectToUpdate, optionsArr, false, selectedDefault);
};

/**
 * Functions for handling the defaulting of Additional To, CC and BCC fields on the Email Author
 * page.  A lookup popup window is opened where additional values can be selected and populated
 * back on the Email Author page.
 * @author ccopek
 * @since 150
 */

function EmailCCBccLookup() {}

EmailCCBccLookup.prototype.storeAddrs = function(select, names, addrs, skipValue) {
	names.value = "";
  	addrs.value = "";
  	if (select != null) {
    	var isFirst = true;
    	for (var i=0; i<select.length; i++) {
      		if (select.options[i] != null && select.options[i].value != '' && select.options[i].value != skipValue) {
        		if (isFirst) {
	            	isFirst = false;
        		}
        		else {
          			names.value += EmailAuthorConstants.EMAIL_ADDR_DELIM;
          			addrs.value += EmailAuthorConstants.EMAIL_ADDR_DELIM;
        		}

        		names.value += select.options[i].text;
        		addrs.value += select.options[i].value;
      		}
    	}
	}
}

EmailCCBccLookup.prototype.storeAllAddresses = function(skipValue) {
    EmailCCBccLookup.prototype.storeAddrs(document.getElementById(EmailCCBccLookupConstants.ADDITIONAL_TO_ID),
    		   document.getElementById(EmailCCBccLookupConstants.ADDITIONAL_TO_NAME_ID),
    		   document.getElementById(EmailCCBccLookupConstants.ADDITIONAL_TO_ADDR_ID),
    		   skipValue);
	EmailCCBccLookup.prototype.storeAddrs(document.getElementById(EmailCCBccLookupConstants.CC_ID),
    		   document.getElementById(EmailCCBccLookupConstants.CC_NAME_ID),
    		   document.getElementById(EmailCCBccLookupConstants.CC_ADDR_ID),
    		   skipValue);
    EmailCCBccLookup.prototype.storeAddrs(document.getElementById(EmailCCBccLookupConstants.BCC_ID),
    		   document.getElementById(EmailCCBccLookupConstants.BCC_NAME_ID),
    		   document.getElementById(EmailCCBccLookupConstants.BCC_ADDR_ID),
    		   skipValue);
}

EmailCCBccLookup.prototype.changeContactType = function(skipValue) {
	EmailCCBccLookup.prototype.storeAllAddresses(skipValue);
	var form = document.forms[EditPageConstants.pEDIT_PAGE];
    form.submit();
    return true;
}

var FilterEdit = function(){}

FilterEdit.prototype.disableDiv = function(divId,disableIt) {
    var obj = document.getElementById(divId)
    if (obj!=null) {
      obj.disabled = disableIt;
      obj.selectedIndex = obj.options.length - 1;
    }
}

// after server-side search, we set focus on the search element.
FilterEdit.prototype.setFocusOnSearch = function() {
    var els = document.getElementsByName(FilterEditPageConstants.pSEARCH_ANCHOR);
    if (els && els.length == 1){
        var anchor = els[0];
        anchor.focus();
    }
}
/**
  A MotifInputElement consists of the MotifElement, and hidden inputs for the motifkey, Icon & description

  @author polcari
  @since 144

  @param paramName - The parameter name which prepends in the inputElements
*/
function MotifInputElement(paramName) {

  this.paramName = paramName;

  this.motifKeyInput = document.getElementById(paramName + MotifInputElementConst.FIELD_NAME_MOTIF);
  this.motifElement = document.getElementById(paramName + MotifInputElementConst.MOTIF_ELEMENT_SUFFIX);
  this.motifElementObj = this.motifElement.motifElement;

  this.motifDescInput = document.getElementById(paramName + MotifInputElementConst.FIELD_NAME_DESCRIPTION);
  this.motifDescCell = this.motifElementObj.motifDescCell;

  this.motifIconInput = document.getElementById(paramName + MotifInputElementConst.FIELD_NAME_ICON);
  this.motifIcon = this.motifElementObj.motifIcon;

  //leave a hooks so we can find this later
  this.motifElement.motifInputElement = this;  // this is the actual box with the color & the icon.
  document.getElementById(paramName).motifInputElement = this; // this is the surrounding box
}

// methods to set icon
MotifInputElement.prototype.setIconSrc = function (newSrc) {
  this.motifIcon.src = newSrc;
}
MotifInputElement.prototype.setIconValue = function (newVal) {
  this.motifIconInput.value = newVal;
}
// method to set motifKey
MotifInputElement.prototype.setMotifKey = function (newKey) {
  this.motifKeyInput.value = newKey;
}

// method to set cellname
MotifInputElement.prototype.setDescription = function(desc) {
  if (this.motifDescCell.firstChild) {
    this.motifDescCell.firstChild.nodeValue = desc;
  } else {
    this.motifDescCell.appendChild(document.createTextNode(desc));
  }
}

  //function for opening window
MotifInputElement.prototype.openWindow = function (url, width, height) {
  openPopup(url, this.paramName + 'MotifPickerWindow', width, height, 'width=' + width + ',height=' + height + ',dependent=yes,resizable=yes,toolbar=no,status=no,directories=no,menubar=no,scrollbars=1', true);
}

// Test to see if this element is null
MotifInputElement.prototype.isNull = function() {
  return (!((this.motifKeyInput.value) && (this.motifKeyInput.value.length > 0)));
}



var HTMLTreeNode = function(){}

HTMLTreeNode.prototype.toggleHTMLTree = function(topic) {

    var obj = HTMLTreeNode.prototype.getNodeChild(topic);
    if (obj != null) {
        var visible = HTMLTreeNode.prototype.isVisible(obj);
        if (visible) {
        	HTMLTreeNode.prototype.close(obj, topic);
		    SetupTreeNode.prototype.removeFromOpenSetup(topic);
        } else {
        	HTMLTreeNode.prototype.open(obj, topic);
		    SetupTreeNode.prototype.addToOpenSetup(topic);	
        }
    }
}

HTMLTreeNode.prototype.isVisible = function(obj){
	return obj.style.display != 'none';
}

HTMLTreeNode.prototype.setVisible = function(obj, visible){
	if (obj){
		if (visible){
			obj.style.display = '';
		} else {
			obj.style.display = 'none';
		}
	}
}

HTMLTreeNode.prototype.getNode = function(topic){
	
    var informationDiv=document.getElementById('treeInformation');
    if (informationDiv == null){
        return;
    }
	
    return document.getElementById(topic);
	
}

HTMLTreeNode.prototype.getNodeChild = function(topic){
	
    var informationDiv=document.getElementById('treeInformation');
    if (informationDiv == null){
        return;
    }
	
	var id = topic + informationDiv.getAttribute('child');
    return document.getElementById(id);
	
}

HTMLTreeNode.prototype.open = function(obj, topic) {
	
    var informationDiv=document.getElementById('treeInformation');
    if (informationDiv == null){
        return;
    }
	
    obj.style.display='block';

    var key=document.getElementById(topic + informationDiv.getAttribute('icon'));
    if (key != null){
	    var currentTitle = key.getElementsByTagName('img')[0].title;
	    var image=key.getElementsByTagName('img')[0];
	    image.src=informationDiv.getAttribute('minusSrc');
	    image.title = HTMLTreeNode.prototype.changePreTitle(currentTitle,informationDiv.getAttribute('collapse'));
	    image.alt = HTMLTreeNode.prototype.changePreTitle(currentTitle,informationDiv.getAttribute('collapse'));
    }
}

HTMLTreeNode.prototype.close = function(obj, topic) {

    var informationDiv=document.getElementById('treeInformation');
    if (informationDiv==null){
        return;
    }

    obj.style.display='none';

    var key = document.getElementById(topic + informationDiv.getAttribute('icon'));
    if (key != null){
	    var currentTitle = key.getElementsByTagName('img')[0].title;
	    var image=key.getElementsByTagName('img')[0];
	    image.src=informationDiv.getAttribute('plusSrc');
	    image.title = HTMLTreeNode.prototype.changePreTitle(currentTitle,informationDiv.getAttribute('expand'));
	    image.alt = HTMLTreeNode.prototype.changePreTitle(currentTitle,informationDiv.getAttribute('expand'));
    }
}

HTMLTreeNode.prototype.changePreTitle = function(currentTitle, preTitle){
    return preTitle+" "+currentTitle.substr(currentTitle.indexOf('-'));
}

// if section is null or invalid there is a fall-back mechanism that will 
// attempt to open up needed section by the topic given.
// HTMLTreeNode.prototype.openHTMLTree() is referenced from functions.js and help.js
HTMLTreeNode.prototype.openHTMLTree = function(sectionEsc,topicEsc) {
    var section = (sectionEsc) ? unescapeJsInHtml(sectionEsc) : null;
    var topic = (topicEsc) ? unescapeJsInHtml(topicEsc) : null;
    var informationDiv = document.getElementById('treeInformation');
    if (informationDiv==null){
        return;
    }
    // highlight the needed topic
    if (topic!=null){
         HTMLTreeNode.prototype.unHighlightAll();

         var leaf = document.getElementById(topic +informationDiv.getAttribute('leaf'));
         if (leaf && leaf.className){
             leaf.className="setupHighlightLeaf"	;
             informationDiv.setAttribute('lastHighlight',topic +informationDiv.getAttribute('leaf'));
         }
     }
     // get the secton to expand
     var obj=document.getElementById(section +informationDiv.getAttribute('child'));
     if (obj==null && topic!=null){

         /**
         * Try to open up a secton by going to the parent
         */
         var leaf = document.getElementById(topic +informationDiv.getAttribute('leaf'));
         if (leaf!=null){
             var divParent = leaf.parentNode;
            if (divParent!=null && divParent.id.indexOf(informationDiv.getAttribute('child')) >0){
                section = divParent.id.substr(0,divParent.id.indexOf(informationDiv.getAttribute('child')));
                obj=divParent;
            }
         }
     }
    if (obj != null) {
        var key=document.getElementById(section +informationDiv.getAttribute('icon'));
        var currentTitle = key.getElementsByTagName('img')[0].title;
        obj.style.display='block';
        var image=key.getElementsByTagName('img')[0];
        image.src=informationDiv.getAttribute('minusSrc');
        image.title = HTMLTreeNode.prototype.changePreTitle(currentTitle,informationDiv.getAttribute('collapse'));
        image.alt = HTMLTreeNode.prototype.changePreTitle(currentTitle,informationDiv.getAttribute('collapse'));
        var divParent = obj.parentNode;
        if (divParent!=null){
            divParent = divParent.parentNode;
            if (divParent!=null && divParent.id.indexOf(informationDiv.getAttribute('child')) >0){
                var section = divParent.id.substr(0,divParent.id.indexOf(informationDiv.getAttribute('child')));
                HTMLTreeNode.prototype.openHTMLTree(section,null);
            }
      }
      if (topic!=null){
            window.scrollTo(0,key.offsetTop)
        }
    }else if (topic!=null){
        // if this topic section was not part of any section
        var leaf = document.getElementById(topic + informationDiv.getAttribute('leaf'));
        if (leaf!=null){
            window.scrollTo(0,leaf.offsetTop)
        }
    }
}

HTMLTreeNode.prototype.unHighlightAll = function(){
         var informationDiv = document.getElementById('treeInformation');
         if (informationDiv==null){
            return;
         }
        var lastHighlight = informationDiv.getAttribute('lastHighlight');
        if (lastHighlight==null){
            return;
        }
        var elementH =  document.getElementById(lastHighlight);
        if (elementH!=null && elementH.className==informationDiv.getAttribute('highlightClass')){
            elementH.className =informationDiv.getAttribute('leafClass');
        }
}


HTMLTreeNode.prototype.populateTheTreeInformation = function(font,child,icon,leaf,expand,collapse,plusSrc,minusSrc,highlightClass,leafClass){

    var informationDiv = document.getElementById('treeInformation');
    if (informationDiv==null){
        return;
    }
    informationDiv.setAttribute('font',font);
    informationDiv.setAttribute('child',child);
    informationDiv.setAttribute('icon',icon);
    informationDiv.setAttribute('leaf',leaf);
    informationDiv.setAttribute('expand',expand);
    informationDiv.setAttribute('collapse',collapse);
    informationDiv.setAttribute('plusSrc',plusSrc);
    informationDiv.setAttribute('minusSrc',minusSrc);
    informationDiv.setAttribute('highlightClass',highlightClass);
    informationDiv.setAttribute('leafClass',leafClass);
    informationDiv.setAttribute('lastHighlight','none');
}






function CriteriaInput(oppLabels, numFilters, prevEntityData) {
	this.oppLabels = oppLabels;
	this.numFilters = numFilters;
	
	this.currentEntityData = prevEntityData;
	this.entityCache = {};
	if (prevEntityData){
		this.entityCache[prevEntityData.entityName] = prevEntityData;
	}
	
	var self = this;
	
	this.handleFieldChange = function(e){
		var field = getEventTarget(getEvent(e));
		self.updateOperator(field, self.getOp(field));
	}
	
	this.init();
}

CriteriaInput.prototype.init = function(){
	for (var i = 1; i <= this.numFilters; i++){
		var field = document.getElementById(CriteriaInputConstants.pCOL + i);
		//initialize any fields that might already be selected
		if (field.selectedIndex > 0){
			this.updateOperator(field, this.getOp(field));
		}
		addEvent(field, 'change', this.handleFieldChange, false);	
	}
}

CriteriaInput.prototype.setEntity = function(entityData, checkPrevVals){
	if (entityData !== this.currentEntityData){
		this.currentEntityData = entityData;
		this.refreshElementsFromData(checkPrevVals);
	}
}

CriteriaInput.prototype.refreshElementsFromData = function(checkPrevVals){
	for (var i = 1; i <= this.numFilters; i++){
		
		var newSel = Util.refreshDynamicSelect(
			document.getElementById(CriteriaInputConstants.pCOL + i),
			this.currentEntityData.getFieldOptions(),
			true);
		addEvent(newSel, 'change', this.handleFieldChange, false);
		document.getElementById(CriteriaInputConstants.pOP + i).selectedIndex = 0;
		document.getElementById(CriteriaInputConstants.pVAL + i).value = "";
		document.getElementById(CriteriaInputConstants.pLOOKUP + i).style.display = 'none';
	}
} 

CriteriaInput.prototype.updateOperator = function(fieldSel, opSel){
	var oldWidth;
	//IE doesn't have a width when called from init()
	if (opSel.offsetWidth > 0)
		oldWidth = opSel.offsetWidth + 'px';
	
	var opList = null;
	var fieldVal = fieldSel.options[fieldSel.selectedIndex].value;
	if (fieldVal){
		opList = this.currentEntityData.getOperators(fieldVal);
	} else {
		opList = null;
	}
	
	var prevSelectedVal = opSel.options[opSel.selectedIndex].value;
	var optionsList = []
	if (opList){
		for (var i = 0; i < opList.length; i++){
			optionsList.push([this.oppLabels[opList[i]], opList[i]]);
		}
	}
	opSel = Util.refreshDynamicSelect(opSel, optionsList, true, prevSelectedVal);
	if (oldWidth){
		opSel.style.width = oldWidth;
	} else {
		opSel.style.width = "98%";
	}
	
	var lookupEl = this.getLookup(fieldSel);
	if (this.currentEntityData.needsLookup(fieldVal)){
		lookupEl.style.display = 'block';
	} else {
		lookupEl.style.display = 'none';
	}
}

CriteriaInput.prototype.getLookup = function(fieldEl){
	var num = fieldEl.id.substring(CriteriaInputConstants.pCOL.length, fieldEl.id.length);
	return document.getElementById(CriteriaInputConstants.pLOOKUP + num);
}

CriteriaInput.prototype.getOp = function(fieldEl){
	var num = fieldEl.id.substring(CriteriaInputConstants.pLOOKUP.length, fieldEl.id.length);
	return document.getElementById(CriteriaInputConstants.pOP + num);
}

function CriteriaEntityData(entityName, fields){
	this.entityName = entityName;
	this.fields = fields;
}

CriteriaEntityData.prototype.getFieldOptions = function(){
	if (this.fieldOptions){
		return this.fieldOptions;
	}
	this.fieldOptions = []
	for (var i = 0; i < this.fields.length; i++){
		this.fieldOptions.push([this.fields[i].label, this.entityName + '.' + this.fields[i].name]);
	}
	return this.fieldOptions;
}

CriteriaEntityData.prototype.getOperators = function(fieldName){
	var colType = ColumnType[this.getFieldByName(fieldName).columnType];
	if (colType.filterQueryOperators){
		return colType.filterQueryOperators;
	} else {
		return colType.queryOperators;
	}
}

CriteriaEntityData.prototype.getFieldByName = function(entityFieldName){
	var field;
	var fieldName = entityFieldName.split('.')[1];
	for (var i = 0; i < this.fields.length; i++){
		if (this.fields[i].name === fieldName){
			field = this.fields[i];
			break;
		}
	}
	return field
}

CriteriaEntityData.prototype.needsLookup = function(fieldName){
	if (!fieldName){
		return false;
	}
	//HACK.  See FilterView
	if (fieldName == 'MEMBER_STATUS' || fieldName == 'CAMPAGN_MEMBER.STATUS' || fieldName == 'Lead.CampaignMemberStatus'){
		return false;
	}

	return ColumnType[this.getFieldByName(fieldName).columnType].needsLookup;
}
	
/**
 * Animation related functions and constants
 * @author mpaksoy
 * @since 150
 */
var Animation = {
    // This function is created under window when animations are in progress.
    ANIMATION_SLAVE : '_animationEventHandler',
    
    RESIZE_HEIGHT_STEPS : 8,
    RESIZE_HEIGHT_DELAY : 20, // milliseconds
    
    animations : {},
    
     /**
     * Animates the given element resizing it from from the starting height to final height.
     * @param elem DOMElement to manipulate
     * @param heightBefore height of the element at the beginning (the element is initialized according to this)
     * @param heightAfter height of the element at the end.
     *                    if set to -1, element's unmodified height as indicated by scrollHeight is used.
     * @param finalize function called once the resize animation is complete
     */
    animateResizeHeight : function(/*DOMElem*/ elem, /*number*/ heightBefore, /*number*/ heightAfter, /*function*/ finalize) {
        if (!elem) return;

        var savedState;
        var autoFinalHeight = false;
        if (Animation.animations[elem]) { // stop old animation
            savedState = Animation.animations[elem];
            savedState.clean();
        } else {
            savedState = {};
            savedState.height = XBrowser.getElementStyle(elem, 'height');
            savedState.overflow = elem.style.overflow;
        }

        Animation.animations[elem] = savedState;
        elem.style.overflow = 'hidden';

        if (heightAfter === -1) {
            elem.style.height = heightBefore + 'px';
            elem.style.display = 'block'
            heightAfter = XBrowser.getActualHeight(elem, true);
            autoFinalHeight = true;
        }

        var self = this;
        var series = Animation._getLinearSeries(heightBefore, heightAfter, Animation.RESIZE_HEIGHT_STEPS);
        if (autoFinalHeight && XBrowser.userAgent.isFirefox) {
            // Firefox does not like it when we end animation at the exact final height of the
            // element. So we skip the last step of the animation to force Firefox to redraw
            // correctly.
            series.pop();
        }
        var i = 0;

        savedState.clean = function() {
            elem.style.height = savedState.height;
            elem.style.overflow = savedState.overflow;
            clearInterval(savedState.intervalHandle);
            Animation.animations[elem] = null;
            if (finalize) finalize();
        };

        savedState.stepper = function() {
            if (i < Animation.RESIZE_HEIGHT_STEPS) {
                var curHeight = series[i];
                elem.style.height = curHeight + 'px';
                i++;
            } else {
                savedState.clean();
            }
        };
        savedState.intervalHandle = setInterval(savedState.stepper, Animation.RESIZE_HEIGHT_DELAY);
        savedState.stepper();
    },
    
    /** Animate element coming into view. Wrapper around animateResizeHeight. */
    rollIn : function(element, finalize) {
        Animation.animateResizeHeight(element, 1,-1, finalize);
    },
    
    /** Animate element going out of view. Wrapper around animateResizeHeight. */
    rollOut: function(element, finalize) {
        element.style.display = 'block';
        Animation.animateResizeHeight(element, XBrowser.getActualHeight(element), 1, function() {
                element.style.display = 'none';
                if (finalize) finalize();
            });
    },
    
    /**
     * Bring element into view, wait delay milliseconds, and bring element out of view.
     * Nice for notifications.
     */
    rollInRollOut : function(element, delay, finalize) {
        Animation.rollIn(element, function() {
                setTimeout(function() {Animation.rollOut(element, finalize)}, delay)
            });
    },
    
    /**
     * Fade in/out the element from the starting opacity to the final opacity.
     * @param elem DOMElement to manipulate
     * @param opacityBefore percent opacity at the beginning
     * @param opacityBefore percent opacity at the end
     * @param finalize function called once the resize animation is complete
     */
    animateOpacity : function(/*DOMElem*/ elem, /*number*/ opacityBefore, /*number*/ opacityAfter, /*function*/ finalize) {
        if (!elem) return;
        
        if (window[Animation.ANIMATION_SLAVE]) { // animation in progress, stop
            return;
        }
    
        // clean up parameters
        if (opacityBefore < 0) {
            opacityBefore = 0;
        } else if (opacityBefore > 100) {
            opacityBefore = 100;
        }
        if (opacityAfter < 0) {
            opacityAfter = 0;
        } else if (opacityAfter > 100) {
            opacityAfter = 100;
        }
    
        // TODO relative step sizes! (duration/smoothness based animation)
        var STEP = 5; // percent opacity
        var DELAY = 20; // milliseconds
        var self = this;

        var isIncreasing = (opacityBefore < opacityAfter);
        currentOpacity = Animation.setOpacity(elem, opacityBefore);
        if (opacityBefore == opacityAfter) {
            return
        }
        window[Animation.ANIMATION_SLAVE] = function() {
            if ((isIncreasing && (currentOpacity > opacityAfter)) ||
                ((!isIncreasing) && (currentOpacity < opacityAfter))) {
                window[Animation.ANIMATION_SLAVE] = false;
                Animation.setOpacity(elem, opacityAfter);
                if (finalize) finalize();
                return;
            }
    
            if (isIncreasing) {
                currentOpacity = Animation.setOpacity(elem, currentOpacity+STEP);
            } else {
                currentOpacity = Animation.setOpacity(elem, currentOpacity-STEP);
            }
            setTimeout('window.'+Animation.ANIMATION_SLAVE+'();', DELAY);
        }
    
        window[Animation.ANIMATION_SLAVE]();
    },
    
    // wrapper around animateOpacity
    fadeOut : function(/*DOMElem*/ elem, /*function*/ finalize) {
        Animation.animateOpacity(elem, 100, 0, finalize);
    },
    
    // wrapper around animateOpacity
    fadeIn : function(/*DOMElem*/ elem, /*function*/ finalize) {
        Animation.animateOpacity(elem, 0, 100, finalize);
    },
    
    // HELPER FUNCTIONS
    /**
     * Cross browser compatible opacity setter
     * @param element DOMElement to modify
     * @param opacity percent opacity to set (70 means 70%)
     * @return new opacity value
     */
    setOpacity : function(/*DOMElement*/ element, /*number*/ opacity) {
        if (XBrowser.userAgent.isIE) {
            element.style.filter = 'alpha(opacity='+opacity+')';
        } else {
            element.style.opacity = opacity/100;
        }
        return opacity;
    },
    
    /**
     * Crows browser compatible, opacity clear.
     * Makes element fully opaque/visible.
     */
    clearOpacity : function(/*DOMElement*/ element) {
        if (XBrowser.userAgent.isIE) {
            element.style.filter = 'alpha(opacity=100)';
        } else {
            element.style.opacity = 1;
        }
    },

    // PRIVATE HELPERS
    /**
     * Get an array of numbers that reprepsents a linear progression from the start point to end point.
     * The series always includes start and end points.
     * @param start starting point for series
     * @param end ending point for series
     * @param steps number of elements in the retured array
     * @return array of floating point numbers
     */
    _getLinearSeries : function(/* int */ start, /* int */ end, /* int */ steps) {
        ret = [];
        steps -= 1; // count the beginning point as a step
        ret.push(start)
        step = (end - start) / steps;
        var current = start;
        for (var i = 0; i < (steps - 1); i++) {
            current += step;
            ret.push(current);
        }
        ret.push(end);
        return ret;
    }
}

/**
  PickableMotifElement mirrors the java class of the same name
  It is a subclass of MotifElement & is used on MotifPicker.java

  @author polcari
  @since 144


  @param motifElementId - The motifElement that this is attached to
  @param motifInputElementId - the parent's param
*/
function PickableMotifElement(id, descCellId, iconId, _motifKey, motifInputElementId) {
  this.init(id, descCellId, iconId, _motifKey); //superclass c'tr
  var self = this;
  if (window.opener) {
    this.parentMotifInputElementObj = window.opener.document.getElementById(motifInputElementId).motifInputElement;
  }
  this.motifElement.onclick = function () {
    //copy class
    self.parentMotifInputElementObj.motifElement.className = self.motifElement.className;
    //copy cell text
    self.parentMotifInputElementObj.setDescription(self.getDescription());
    //copy icon
    if (self.motifIcon && self.motifIcon.src) {
      self.parentMotifInputElementObj.setIconSrc(self.motifIcon.src);
      self.parentMotifInputElementObj.setIconValue('');
    }
    //copy input box
    self.parentMotifInputElementObj.setMotifKey(self.motifKey);
    window.blur();
    window.close();
    return false;
  };
}

//subclass of MotifElement
PickableMotifElement.prototype = new MotifElement;

//static function used on the motifpicker
PickableMotifElement.toggleUsedMotifVisibility = function(showThem) {
  var allMotifs = document.getElementsByTagName("a");

  for (var i = 0; i < allMotifs.length; i++) {
    if ((showThem) && (allMotifs[i].style.display == 'none') && (allMotifs[i].className.indexOf('motifElement') > -1)) {
      allMotifs[i].style.display = 'block';
    } else if ((!showThem) && (allMotifs[i].className) && (allMotifs[i].className.indexOf('usedMotif') > -1)) {
      allMotifs[i].style.display = 'none';
    }
  }
}

PickableMotifElement.hideUsedStyle = function() {
  document.getElementById("hideUsedStyle").style.display = 'none';
  document.getElementById("showUsedStyle").style.display = 'block';
  PickableMotifElement.toggleUsedMotifVisibility(false);
  return false;
}

PickableMotifElement.showUsedStyle = function() {
  document.getElementById("showUsedStyle").style.display = 'none';
  document.getElementById("hideUsedStyle").style.display = 'block';
  PickableMotifElement.toggleUsedMotifVisibility(true);
  return false;
}

/**
 * Handles inline editing on lists
 * 
 * @author jmooney
 * @since 154
 */
function ListInlineEditData(data) {
    this.viewport = data.viewport;
    this.isEditable = data[InlineEditConstants.EDITABLE];
    this.columns = {};
    this.currentColumn = null;
    this.currentRow = null;
    if (this.isEditable) {
        this.isMassEditable = data[InlineEditConstants.MASS_EDITABLE];
        this.entityType = data[InlineEditConstants.ENTITY_TYPE];
        this.isPersonAccount = data[InlineEditConstants.IS_PERSON];
        this.dynamicDataUrl = data[InlineEditConstants.DYNAMIC_DATA];
        this.nameLabel = data[InlineEditConstants.NAME_LABEL];
        var self = this;
        // TODO: this should load on demand
        // picklist script clears itself automatically
        if (this.dynamicDataUrl) {
            XBrowser.createDynamicScript(this.dynamicDataUrl, function() { self.dynamicDataLoaded(); });
        }
        this.layoutInfo = data[InlineEditConstants.LAYOUT_INFO];
        for (var i = 0; i < data.shownColumns.length; i++) {
            var column = data.shownColumns[i];
            var columnLayout = this.layoutInfo[column.fieldId];
            column.state = columnLayout ? columnLayout[0] : "READONLY";
            column.required = columnLayout ? columnLayout[1] : false;
            // hack for person accounts since filter uses wrong entityinfo
            if (this.isPersonAccount && column[InlineEditConstants.OVERRIDE_TYPE]) {
                column[InlineEditConstants.OVERRIDE_TYPE] = "PERSONNAME";
            } else if (!this.isPersonAccount && this.entityType == "Account" &&
                       (column.columnId == "LastName" || column.columnId == "FirstName" || column.columnId == "Salutation")) {
                column.state = "NONE";
            }
            this.columns[column.columnName] = new ListFilterColumn(column);
        }
        if (!ListInlineEditData.dialog) {
            ListInlineEditData.dialog = new SimpleDialog("massEdit");
            ListInlineEditData.dialog.displayX = true;
            ListInlineEditData.dialog.setWidth(520);
            ListInlineEditData.dialog.extraClass = "inlineEditDialog";
            ListInlineEditData.dialog.register();
        }
    }
}

ListInlineEditData.dialog = null;

ListInlineEditData.prototype.dynamicDataLoaded = function() {
    
}

ListInlineEditData.prototype.getColumnById = function(id) {
    return this.columns[id];
}

ListInlineEditData.prototype.openColumn = function(rowId, columnId, initialValue) {
    var column = this.columns[columnId];
    if (column && column.state == InlineEditState.EDIT) {
        this.currentColumn = column;
        this.currentRow = rowId;
        var numRows = this.viewport.grid.getSelectionModel().getCount();
        var canMassEdit = this.isMassEditable && numRows > 1;
        var html = [];
        html.push("<div class='fieldTableDiv'><table class='fieldTable' border='0'><tr class='fieldRow'><td class='labelCol'>");
        html.push(this.currentColumn.label);
        html.push("</td><td class='dataCol'>");
        html.push("<div id='massEditFieldDiv' class='");
        if (this.currentColumn.required) {
            html.push("inlineEditRequiredDiv");
        } else {
            html.push("inlineEditDiv");
        }
        html.push("'></div></td></tr></table></div>");
        if (canMassEdit) {
            html.push("<table class='fieldTable'><tr class='selectionRow'><td class='labelCol'>");
            html.push(LC.getLabel("MassListEdit", "EditLabel"));
            html.push("</td><td class='dataCol'>");
            html.push("<div class='radio'><input type='radio' name='massOrSingleEdit' id='singleEditRadio' checked='checked'><label for='singleEditRadio'>");
            html.push(LC.getLabel("MassListEdit", "SingleEdit"));
            html.push("</label></div><div class='radio'><input type='radio' name='massOrSingleEdit' id='massEditRadio'><label for='massEditRadio'>");
            html.push(LC.getLabel("MassListEdit", "MultiEdit", numRows));
            html.push("</label></div></td></tr></table>");
        }
        html.push("<div class='inlineEditButtons'>");
        html.push("<input class='btn' type='button' value='");
        html.push(LC.getLabel("Buttons", "save"));
        html.push("' id='saveButton'><input class='btn' type='button'value='");
        html.push(LC.getLabel("Buttons", "cancel"));
        html.push("' id='cancelButton'>");
        html.push("</div>");
        ListInlineEditData.dialog.setContentInnerHTML(html.join(''));
        ListInlineEditData.dialog.setTitle(LC.getLabel("List", "edit") + " " + this.currentColumn.label);
        var editDiv = document.getElementById("massEditFieldDiv");
        this.currentColumn.createEditElements(editDiv, canMassEdit ? null : initialValue);
        var self = this;
        document.getElementById('saveButton').onclick = function() { self.save(); };
        document.getElementById('cancelButton').onclick = function() {self.closeColumn()};
        if (column.columnType.isDate) {
            // move the date picker into the overlay
            var datePicker = document.getElementById(DatePickerIds.DOM_ID);
            document.getElementById(ListInlineEditData.dialog.getContentId()).appendChild(datePicker);
        }
        ListInlineEditData.dialog.show();
        this.currentColumn.onDisplay();
    }
}

ListInlineEditData.prototype.save = function() {
	var saveData = {};
	var radio = document.getElementById("massEditRadio");
	if (this.isMassEditable && radio && radio.checked) {
    	saveData[InlineEditConstants.IDS] = this.viewport.grid.getSelectionModel().selections.keys;
	} else {
	    saveData[InlineEditConstants.IDS] = this.currentRow;
	}
	saveData[InlineEditConstants.ENTITY_TYPE] = this.entityType;
	saveData[InlineEditConstants.NULLABLE] = !this.currentColumn.required;
	this.currentColumn.addSaveData(saveData);
	ListInlineEditData.dialog.hide();
	this.viewport.beforeSave();
	var self = this;
	XBrowser.postHttpResponse("/_ui/common/udd/object/InlineEditListSave", function(response) { self.handleSaveResponse(response.responseText) }, XBrowser.buildPost(saveData));
}

ListInlineEditData.prototype.closeColumn = function() {
    ListInlineEditData.dialog.hide();
    this.currentColumn = null;
}

ListInlineEditData.prototype.handleSaveResponse = function(responseText) {
    var json = Util.evalAjaxServletOutput(responseText);
    if (json.error) {
        // TODO: do something appropriate
        var div = document.createElement("div");
        div.innerHTML = json.error;
        ListInlineEditData.dialog.getContentElement().appendChild(div);
        ListInlineEditData.dialog.show();
    } else if (json.fieldError) {
        this.currentColumn.setError(json.fieldError);
        ListInlineEditData.dialog.show();
    } else {
        if (json.errorsByRow) {
            var numSaved = json.saved.length || 0;
            this.createErrorWindow(numSaved, json.errorsByRow);
        }
    }
	this.viewport.afterSave(json.saved, this.currentColumn);
}

// yeah, this is ugly, wanna fight about it?
ListInlineEditData.prototype.createErrorWindow = function(numSaved, errorsByRow) {
    var errorWin = window.open("", "errorWin", "width=720,height=400,resizable=yes", false);
    if (errorWin) {
        var d = errorWin.document;
        d.writeln('<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">');
        d.writeln('<html><head><title>Errors</title>');
        DynamicCss.writeCss(null, d, true);
        d.writeln('<link rel="stylesheet" type="text/css" href="/EXT/ext-2.1/resources/css/ext-all.css" />');
        d.writeln('<style type="text/css">.x-grid3-col-error{white-space: normal}</style>')
        d.writeln('<script src="/EXT/ext-2.1/ext.js"></script>');
        d.writeln('<script type="text/javascript">');
        d.writeln('Ext.onReady(function() {');
        d.writeln('    var sm = new Ext.grid.CheckboxSelectionModel();');
        d.writeln('    new Ext.Viewport({');
        d.writeln('        layout: "border",');
        d.writeln('        items: [{');
        d.writeln('            region: "north",');
        d.writeln('            contentEl: "topNav"');
        d.writeln('        }, {');
        d.writeln('            xtype: "grid",');
        d.writeln('            region: "center",');
        d.writeln('            id: "errorGrid",');
        d.writeln('            autoExpandColumn: "error",');
        d.writeln('            sm: sm,');
        d.writeln('            ctCls: "errorConsole",');
        d.writeln('            store: new Ext.data.JsonStore({');
        d.writeln('                root: "errorsByRow",');
        d.writeln('                fields: [');
        d.writeln('                    { name: "entityId", type: "string" },');
        d.writeln('                    { name: "name", type: "string" },');
        d.writeln('                    { name: "errorDesc", type: "string" }');
        d.writeln('                ],');
        d.writeln('                data: { errorsByRow: [');
        var total = 0;
        for (var i in errorsByRow) {
            if (total != 0) {
                d.write(',');
            }
            total++;
            d.write('{ entityId: "');
	        d.write(i);
	        d.write('", name: ');
            d.write('"');
            d.write(errorsByRow[i].name.replace(/"/g, "\\\""));
            d.write('"');
            d.write(', errorDesc: "');
            d.write(errorsByRow[i].errorDesc.replace(/"/g, "\\\""));
            d.writeln('"}');
	    }
        d.writeln('                ]}');
        d.writeln('            }),');
        d.writeln('            columns: [');
        d.writeln('                sm,');
        d.write('                { id: "name", dataIndex: "name", sortable: false, menuDisabled: true, width: 150, header: "');
        d.write(this.nameLabel);
        d.writeln('", renderer: function(value, metadata, record, rowIndex, colIndex, store) {');
        d.writeln('                    var html = [];');
        d.writeln('                    html.push("<img src=\'/s.gif\' class=\'errorSmall\'>");');
        d.writeln('                    if (value === "") {');
        d.write('                        html.push("');
        d.write(LC.getLabel("MassListEdit", "NoName"));
        d.writeln('");');
        d.writeln('                    } else {');
        d.writeln('                        html.push("<a target=\'_blank\' href=\'/");');
        d.writeln('                        html.push(record.data.entityId);');
        d.writeln('                        html.push("\'>");');
        d.writeln('                        html.push(value);');
        d.writeln('                        html.push("</a>");');
        d.writeln('                    }');
        d.writeln('                    return html.join("");');
        d.writeln('                } },');
        d.write('                { id: "error", header: "');
        d.write(LC.getLabel("MassListEdit", "ErrorColumn"));
        d.writeln('", dataIndex: "errorDesc", menuDisabled: true, sortable: false }');
        d.writeln('            ]');
        d.writeln('        }]');
        d.writeln('    });');
        d.writeln('    var grid = Ext.getCmp("errorGrid");');
        d.writeln('    Ext.fly("clearSelected").on("click", function(e) {');
        d.writeln('        var selections = grid.getSelectionModel().getSelections();');
        d.writeln('        for (var i = 0; i < selections.length; i++) {');
        d.writeln('            grid.getStore().remove(selections[i]);');
        d.writeln('        }');
        d.writeln('        grid.getView().refresh();');
        d.writeln('    });');
        d.writeln('    grid.on("cellclick", function(grid, rowIndex, columnIndex, e) {');
        d.writeln('        if (grid.getColumnModel().getDataIndex(columnIndex) == "name" && e.getTarget("a", 1)) {');
        d.writeln('            Ext.fly(grid.getView().getCell(rowIndex, columnIndex)).addClass("viewedError");');
        d.writeln('            Ext.fly(grid.getView().getCell(rowIndex, columnIndex + 1)).addClass("viewedError");');
        d.writeln('        ');
        d.writeln('        }');
        d.writeln('    });');
        d.writeln('});');
        d.write('</script></head><body class="');
        d.write(this.viewport.filter.bodyClass);
        d.writeln('"><div id="topNav" class="primaryPalette errorConsoleHeader"><div class="errorSummary">');
        d.write("<img src='/s.gif' class='confirmSmall'>");
        if (numSaved == 1) {
            d.writeln(LC.getLabel("MassListEdit", "OneSuccessful"));
        } else {
            d.writeln(LC.getLabel("MassListEdit", "ManySuccessful", numSaved));
        }
        d.write("</div><div class='errorSummary'><img src='/s.gif' class='errorSmall'>");
        if (total == 1) {
            d.writeln(LC.getLabel("MassListEdit", "OneError"));
        } else {
            d.writeln(LC.getLabel("MassListEdit", "ManyErrors", total));
        }
        d.write("</div><div class='errorTitle'>");
        d.write(LC.getLabel("MassListEdit", "Summary"));
        d.write('<input type="button" class="btn" id="clearSelected" value="');
        d.write(LC.getLabel("MassListEdit", "ClearSelected"));
        d.writeln('"></div></div></body></html>');
        d.close();
        errorWin.focus();
   }
}


/* Alerts the user with a message, and blocks the form from submiting.
 * This hack is needed because firefox will still submit a form even if an alert is shown. */
function alertBlockSubmit (msg) {
  window.ffInAlert = true;
  alert(msg);
  window.ffInAlert = false;
}

function Modal(){}

Modal.confirm = function(msg) {
  top.ffInAlert = true;
  var ans = window.confirm(msg);
  top.ffInAlert = false;
  return ans;
}

Modal.isBlocked = function () {
  return top.ffInAlert;
}

/**
 * Introducing a brand new flavor of UserContext, this time in javascript! Variables passed down from
 * java MUST be declared here or they will not be set.
 * 
 * @author jmooney
 * @since 148
 */
var UserContext = {
	
    initialized : false,
    locale : "",
    language: "",
    startOfWeek : 0,
    dateFormat : "",
    dateTimeFormat : "",
    ampm: null,
    today : "",
    isAccessibleMode : false,
    userPreferences : null,

    initialize : function(values) {
    	if (!values){
    		UserContext.initializeFromServlet();
    		return;
    	}
    	UserContext.processValues(values);
    },
    
    initializeFromServlet : function(){
		var url = "/_ui/system/context/UserContextServlet";
		XBrowser.getHttpResponse(url, function(request) {
		    var values = Util.evalAjaxServletOutput(request.responseText);
    	    UserContext.processValues(values);
		} );
    },
    
    processValues : function (values) {
        for (var key in values) {
            // force strict variable declaration
            if (typeof UserContext[key] != "undefined") {
                if (key == "userPreferences" || key == "orgPreferences") {
                    UserContext[key] = new PreferenceBits(values[key]);
                } else {
                    UserContext[key] = values[key];
                }
            }
        }
        UserContext.initialized = true;
    }
    
};

function FormulaEditor(){};

FormulaEditor.init = function( editorElementId, functionSelectionElementId, formId, validationStatusNotValidated ) {
    FormulaEditor.editorElementId = editorElementId;
    FormulaEditor.functionSelectionElementId = functionSelectionElementId;
    FormulaEditor.formId = formId;
    FormulaEditor.validationStatusNotValidated = validationStatusNotValidated;
    FormulaEditor.setFunctionInfo(FormulaEditor.getSelectedFunction());

}

FormulaEditor.setFunctionInfo = function( functionName ) {
    if (!functionName)
        return;
    document.getElementById('funcFormat').innerHTML = functionNameToPrototypeMap[functionName];
    document.getElementById('funcExplain').innerHTML = functionNameToDescriptionMap[functionName];
}

FormulaEditor.getSelectedFunction = function() {
    functionSelectElement = document.getElementById(FormulaEditor.functionSelectionElementId);
    if (!functionSelectElement)
        return null;

    return functionSelectElement.options[functionSelectElement.selectedIndex].value;
}

FormulaEditor.setListToCategory = function( category, categoryMap, targetId, defaultCategory, preserveFirstOption) {
    var targetSelectElement = document.getElementById(targetId);
    var list = categoryMap[(category != '') ? category : defaultCategory];
    var offset = (preserveFirstOption) ? 1 : 0;

    targetSelectElement.options.length = offset;
    if (!list) return;
    for (var i = 0; i < list.length; i++) {
        targetSelectElement.options[i + offset] = list[i];
    }
}

FormulaEditor.switchMode = function( mode ) {
    if (document.getElementById('editorMode').value == mode)
        return;
    document.getElementById('editorMode').value = mode;
    document.getElementById('changeEditorMode').value = "1";
    document.getElementById(FormulaEditor.formId).submit();
}

FormulaEditor.formulaKeypressEventListener = function() {
    var validationStatus = document.getElementById('validationStatus');
    if(validationStatus) {
        validationStatus.innerHTML = FormulaEditor.validationStatusNotValidated;
    }
}

FormulaEditor.registerFormulaEventListeners = function( name ) {
    // Wire up event listener to change validation status
    setCurrentParamName(name);
    var editorDoc = getDoc();
    if (editorDoc.addEventListener)
        editorDoc.addEventListener("keypress", FormulaEditor.formulaKeypressEventListener, false);
    else
        editorDoc.onkeypress = FormulaEditor.formulaKeypressEventListener;
}

FormulaEditor.insertFieldReference = function( name, fieldSelector, insertCurlyBangDelims ) {
    var value = fieldSelector.options[fieldSelector.selectedIndex].value;
    if (value) {
        FormulaEditor.insertCode(name, value, insertCurlyBangDelims);
        fieldSelector.selectedIndex = 0;
    }
}

FormulaEditor.insertCode = function( name, value, insertCurlyBangDelims ) {
    var insert;
    restoreSelection(document.getElementById(name));
    insert = (insertCurlyBangDelims && !findDelimiters(name, '{!', '}')) ? '{!' + value + '}' : ' ' + value + ' ';
    insertTextAtSelectionInEditor(name, insert);
}

/*
 * @author ldelascurain
 * @since 154
 *
 */

function TabSetPage( selectToUpdateId ) {
	this.selectToUpdateId = selectToUpdateId;
};

TabSetPage.prototype.update = function( availableSelectId ) {
	var selectedTabs = document.getElementById(availableSelectId);
	var selectToUpdate = document.getElementById(this.selectToUpdateId);
	var selectedDefault = selectToUpdate.options[selectToUpdate.selectedIndex].value;
	var options = selectedTabs.options;
	var optionsArr = [];
	var isSelectedInOptions = false;

	for (var i=0;i<options.length;i++){
		var option = options[i];
		optionsArr[i] = [option.text, option.value];
		if (option.value==selectedDefault){
			isSelectedInOptions = true;
		}
	}

	if (!isSelectedInOptions){
		selectedDefault = optionsArr[0].value;
	}

	Util.refreshDynamicSelect(selectToUpdate, optionsArr, false, selectedDefault);
};

var SIDEBAR_DIV_WIDTH = 216;
var SIDEBAR_DIV_EDGE = 19; //width of handle (b/w right edge and window edge when collapsed)
var SIDEBAR_DIV_SPACE = 0; //Between left edge and content when pinned
var SIDEBAR_RIGHT_INC = 20;
var SIDEBAR_TIMESTEP = 8;
var SIDEBAR_OUT_DELAY = 500;
var SIDEBAR_IN_DELAY = 100;
var SIDEBAR_BORDER_WIDTH = 1;	// used to align the handle with the sidebarDiv


/**
 *  Sidebar.  This is the controller object for the collapsible sidebar.
 *
 *  @author emoses
 *  @since 144
 *
 *  @param sidebarDiv      object. A reference to the sidebar div DOM object.
 *  @param enableCollapse  boolean.  True to enable the collapsible sidebar
 *  @param isPinnned	   boolean.  Whether the sidebar is initialized pinned
 *
 *  Note that isPinned is not required if enabledCollapse is false.
 */
function Sidebar(sidebarDiv, enableCollapse, isPinned) {
  this.div = sidebarDiv;
  this.inOutBox = document.getElementById(SidebarConstants.HANDLE_ID);
  // there are 2 handles, one at the bottom, one at the top
  this.handle = document.getElementById(SidebarConstants.PIN_INDICATOR_ID);
  this.handle2 = document.getElementById(SidebarConstants.PIN2_INDICATOR_ID);
  this.pinned = isPinned;

  this.openHandleRE = /\bopen\b/;

  if (!enableCollapse){
    /* Sidebar not enabled.  Kill the cookie if it exists, resize the sidebar to the
     * size of the body, and exit without instanciating this object
     */
    deleteCookie(SidebarConstants.SIDEBAR_PINNED_COOKIE);
  }

  //this is the reportOverview page and has no sidebar
  if ((enableCollapse) && (!this.pinned) && (!document.getElementById(BodyLayout.BODY_TABLE_ID)) && (document.body)) {
    document.body.className = document.body.className + ' hiddenSidebar';
  }

  if ((!enableCollapse) || (!document.getElementById(BodyLayout.BODY_TABLE_ID))) {
    this.handle.style.display = "none";
    this.handle2.style.display = "none";
    this.sizeBodyToSidebar();
    this.sizeToBody();

    return null;
  }


  //Some styles are specific to the collapsible sidebar
  this.div.className = "collapsible";

  /*private members*/
  var self = this;
  var outDelay = -1;
  var locked = false;

  /* instantiate the controller object for the moveIn/moveOut behavior.  This is all callbacks */
  this.mover = new Fader(
    this.div, //object
    function(object, currVal) { return currVal <= -1* (SIDEBAR_DIV_WIDTH-SIDEBAR_DIV_EDGE); },  //textMin
    function(object, currVal) { return currVal >= 0; }, //testMax
    SIDEBAR_TIMESTEP, //timestep
    function(currVal, sign){ return currVal += sign*SIDEBAR_RIGHT_INC; }, // nextStep
    function(object, nextVal){ object.setStyle('left', nextVal + "px"); }, //increment
    0, //startVal
    function(object) { object.style.left = (-1*(SIDEBAR_DIV_WIDTH-SIDEBAR_DIV_EDGE))+ "px"; return -1*(SIDEBAR_DIV_WIDTH-SIDEBAR_DIV_EDGE) }, //finalMin
    function(object) { object.style.left = "0px"; return 0; } //finalMax
  );

  this.handleInOutClick = function(e) {
    if (!locked){
      self.pin();
    }
  };

  this.handleDocumentKeyDown = function(e){
    var evt = getEvent(e);
    var pos = self.mover.getPosition();
    if (evt.altKey && String.fromCharCode(evt.keyCode) === "S"){
      //ALT-s
      //Highlight the text in the sidebar search area
      var searchBox = document.getElementById(SidebarConstants.pSEARCH_SIDEBAR_STR);
      if (searchBox){
        searchBox.focus();
        searchBox.select();
      }
      //reverse
      if (!locked){
        self.pin();
      }
    }
  };

  this.lock = function() {
    locked = true;
  };

  this.unlock = function() {
    locked = false;
  };

  this.init();
}

Sidebar.prototype.sizeToBody = function(){
  var content = document.getElementById(BodyLayout.BODY_TABLE_ID);
  if (content) {
    this.div.style.height = content.offsetHeight + "px";
    var newHeight = content.offsetHeight - SIDEBAR_BORDER_WIDTH;
    if(newHeight >= 0){
    	this.inOutBox.style.height = newHeight + "px";
    }
  }
};

Sidebar.prototype.sizeBodyToSidebar = function(){
  var content = document.getElementById(BodyLayout.BODY_TABLE_ID);
  if ((content) && (this.div.offsetHeight > content.offsetHeight)) {
    content.style.height = (this.div.offsetHeight - SIDEBAR_BORDER_WIDTH) + "px";
  }
};

Sidebar.prototype.sizeBodyToSidebarNoCheck = function(){
  var content = document.getElementById(BodyLayout.BODY_TABLE_ID);
  var inner = this.div.lastChild
  content.style.height = (inner.offsetHeight - SIDEBAR_BORDER_WIDTH) + "px";
};

/* public functions */
Sidebar.prototype.setSidebarCookie = function(val){
  var expires = new Date();
  expires.setTime(expires.getTime() + (3650*24*60*60*1000));
  setCookie(SidebarConstants.SIDEBAR_PINNED_COOKIE, val, expires);
};

Sidebar.prototype.getSidebarCookie = function(){
  return getCookie(SidebarConstants.SIDEBAR_PINNED_COOKIE);
};

Sidebar.prototype.init = function() {
  addEvent(document, 'keydown', this.handleDocumentKeyDown, false);
  addEvent(this.inOutBox, 'click', this.handleInOutClick, true);
  addEvent(this.handle, 'click', this.handleInOutClick, true);
  addEvent(this.handle2, 'click', this.handleInOutClick, true);

  this.sizeBodyToSidebar();
  this.div.display = "none";
  if (!this.pinned){
    this.pinned = true //Reverse it for the benefit of this.pin()
    this.pin(true);
  } else {
    document.getElementById(BodyLayout.BODY_CELL_ID).style.paddingLeft = SIDEBAR_DIV_WIDTH + "px";
  }
  this.setTitleAndClass();

  //Check for errors in the sidebar, and jump it out if need be

  if (getElementsByClassName(EditElement.ERROR_CLASS, this.div).length > 0){
    this.mover.jumpIn();
  }
};

Sidebar.prototype.pin = function(noCookie) {
  var content = document.getElementById(BodyLayout.BODY_CELL_ID);
  if (this.pinned){
    this.pinned = false;
    content.style.paddingLeft = (SIDEBAR_DIV_EDGE + SIDEBAR_DIV_SPACE) + "px";
    this.sizeToBody();
    this.mover.jumpOut();
    if (!noCookie) { this.setSidebarCookie("0"); }
  } else {
    this.pinned = true;
    content.style.paddingLeft = (SIDEBAR_DIV_WIDTH + SIDEBAR_DIV_SPACE) + "px";
    this.sizeToBody();
    this.mover.jumpIn();
    if (!noCookie) { this.setSidebarCookie("1"); }
  }
  this.setTitleAndClass();
};

Sidebar.prototype.setTitleAndClass = function() {
  if (this.pinned) {
    this.handle.title = LC.getLabel("Sidebar", "collapse");
    this.handle2.title = LC.getLabel("Sidebar", "collapse");
    this.inOutBox.title = LC.getLabel("Sidebar", "collapse");
    if (!this.handle.className.match(this.openHandleRE)) {
      this.handle.className += " open";
      this.handle2.className += " open";
    }
    if (!this.inOutBox.className.match(this.openHandleRE)) {
      this.inOutBox.className += " open";
    }
  } else {
    this.handle.title = LC.getLabel("Sidebar", "expand");
    this.handle2.title = LC.getLabel("Sidebar", "expand");
    this.inOutBox.title = LC.getLabel("Sidebar", "expand");
    this.handle.className = this.handle.className.replace(this.openHandleRE, "");
    this.handle2.className = this.handle.className.replace(this.openHandleRE, "");
    this.inOutBox.className = this.inOutBox.className.replace(this.openHandleRE, "");
  }
};

/**
 * Simple modal dialog with content editing functions
 * 
 * @author jtroup
 * @since 152
 */

function SimpleDialog(id, isMovable) {
    this.id = id;
    this.isModal = true;
    this.isMovable = isMovable;
    this.extraClass = "calendarDialog";
    this.width = 450;
    this.title = "";
    this.displayX = false;
    this.addEvents();
}

SimpleDialog.prototype = new OverlayDialog();

SimpleDialog.prototype.createContent = function() {
    var content = document.getElementById(this.id + "Content");
    var html = [];
    html.push("<h2 id='");
    html.push(this.id);
    html.push("Header'>");
    html.push(this.header);
    html.push("</h2>");
    html.push("<div id='");
    html.push(this.id);
    html.push("Inner'></div>");
    content.innerHTML = html.join("");
}

/**
 * convenience method to set the innerHTML of the scrollable content area
 */
SimpleDialog.prototype.setContentInnerHTML = function(html) {
    this.getContentElement().innerHTML = html;
}

/**
 * convenience method to import another node into the scrollable content area
 */
SimpleDialog.prototype.importContentNode = function(element) {
    this.setContentInnerHTML("");
    this.getContentElement().appendChild(element);
}

/**
 * returns the content element
 */
SimpleDialog.prototype.getContentElement = function() {
    return document.getElementById(this.id + "Inner");
}

function TwistyElement(twistyId, dependentId, showLabel, hideLabel, startHidden){
	this.twisty = document.getElementById(twistyId);
	this.dep = document.getElementById(dependentId);
	this.showLabel = showLabel;
	this.hideLabel = hideLabel;
	if (!this.twisty || !this.dep){
		return;
	}
	
	if (startHidden){
		this.dep.style.display = "none";
	}
	this.hidden = startHidden;


	
	var self = this;
	addEvent(this.twisty.parentNode, 'click', function(e){ self.twistElement(e); });
}

TwistyElement.prototype.twistElement = function(e){
	var twistSpan = getElementsByClassName("twistyText", this.twisty.parentNode)[0];
	var target = getEventTarget(getEvent(e));
	if (target === twistSpan || target === this.twisty){
		if (this.hidden){
			this.dep.style.display = "block";
			this.hidden = false;
			this.twisty.className = "hideListButton";
			twistSpan.innerHTML = this.hideLabel;
		} else {
			this.dep.style.display = "none";
			this.hidden = true;
			this.twisty.className = "showListButton";
			twistSpan.innerHTML = this.showLabel;
		}
	}
};
/**
 *  Hover.js, the main class for a hover in the app
 *
 *  @author eli
 *  @since 146 (rewrite of 144 code in functions.js)
 */

function Hover() {
    this.loaded = false;
    this.xCoord = 0;
    this.xObjLeft = 0;
    this.xObjRight = 0;
    this.yCoord = 0;
    this.yObjTop = 0;
    this.yObjBottom = 0;
    this.showing = false;
    this.showTimer = false;
    this.hideTimer = false;
}

Hover.hoverMap = new Object();
Hover.hoversEnabled = true;

Hover.disableHovers = function() {
    Hover.hoversEnabled = false;
}

Hover.clearHovers = function() {
	Hover.hoverMap = new Object();
}

Hover.getHover = function(elementId) {
    var hover = Hover.hoverMap[elementId];
    if (typeof hover == 'undefined') {
        return Hover.createHover(new Hover(), elementId);
    }
    return hover;
}

Hover.createHover = function(hover, elementId) {
    hover.eid = elementId;
    hover.ele = getElementByIdCS(hover.eid);
    hover.iFShim = new iframeShim(hover.ele);
    Hover.hoverMap[elementId] = hover;
    return hover;
}

Hover.prototype.showHover = function(ev, url, type) {
    if (!this.hoverType) this.hoverType=type;
    if (this.hideTimer) {
        window.clearTimeout(this.hideTimer);
        this.hideTimer=false;
    }
    if (!this.showTimer) {
        this.showTimer = window.setTimeout('Hover.getHover(\''+this.eid+'\').showHoverAfterDelay(\''+url+'\')', 500);
    }
    this.setPosition(ev);
}
        
Hover.prototype.hideHover = function() {
    if (this.showTimer) {
        window.clearTimeout(this.showTimer);
        this.showTimer=false;
    }
    if (!this.hideTimer) {
        this.hideTimer = window.setTimeout('Hover.getHover(\''+this.eid+'\').hideHoverAfterDelay()', 100);
    }
}

Hover.prototype.showHoverAfterDelay = function(url) {
    if (!this.hideTimer && !Modal.isBlocked()) {
        if (!this.loaded) {
            if (Hover.hoversEnabled) {
                // if url not set, assume the element was pre-loaded.
                if (url) {
                    this.loadAjaxHover(url);
                }
            } else {
                window.location.reload();
                return;
               }
        }
        this.revealHover();
    }
    this.showTimer=false;
}

Hover.prototype.revealHover = function() {
    this.iFShim.setStyle('visibility', 'visible');
    this.showing=true;
}

Hover.prototype.hideHoverAfterDelay = function() {
    if  (Modal.isBlocked()) {
        this.hideTimer = window.setTimeout('Hover.getHover(\''+this.eid+'\').hideHoverAfterDelay()', 100);
        return;
    } else if (!this.showTimer) {
        this.iFShim.setStyle('visibility', 'hidden');
        this.showing=false;
    }
    this.hideTimer=false;
}

Hover.prototype.setPosition = function(ev) {
    //prevents hover from moving with mouse when its visible
    if (!this.showing) {
        this.xObjLeft = getObjX(getSrcElement(ev));
        this.xObjRight = this.xObjLeft + Hover.getElementWidth(getSrcElement(ev));
        this.yObjTop = getObjY(getSrcElement(ev));
        this.yObjBottom = this.yObjTop + Hover.getElementHeight(getSrcElement(ev));
        this.setXPos(getMouseX(ev));
        this.setYPos(getMouseY(ev));
        this.reposition();
    }
}

Hover.prototype.reposition = function() {
    var x = this.xCoord;
    var y = this.yCoord - (document.getElementById(BodyLayout["PAGE_HEADER_ID"]) ? Hover.getElementHeight(document.getElementById(BodyLayout["PAGE_HEADER_ID"])) : 0);
    this.iFShim.setStyle('left', (x) + 'px');
    this.iFShim.setStyle('top', (y) + 'px');
}

Hover.prototype.setXPos = function(x) {
    var maxX = this.getMaxX();
    if (x > maxX) x = Math.max(this.getMinX(), maxX);
    this.xCoord = x;
}

Hover.prototype.getMinX = function() {
    // Calculate the leftmost pixel of the body cell, so that the hover will not go under the sidebar (Bug #104467)
    var bodyCellEle = document.getElementById(BodyLayout.BODY_CELL_ID);
    var bodyCellPadLeft = (bodyCellEle) ? getCurrentStyle(bodyCellEle, 'paddingLeft') : '0px';
    var bodyCellX = parseInt(bodyCellPadLeft.substring(0, bodyCellPadLeft.indexOf('px')));

    var screenMinX = assureInt(window.pageXOffset || (Hover.documentBody? Hover.documentBody.scrollLeft : 0) || 0);
    return Math.max(screenMinX, bodyCellX);
}

Hover.prototype.getMaxX = function() {
    return assureInt((Hover.documentBody && Hover.documentBody.clientWidth)? Hover.documentBody.clientWidth : window.innerWidth) +
              assureInt(window.pageXOffset || (Hover.documentBody? Hover.documentBody.scrollLeft : 0) || 0) - Hover.getElementWidth(this.ele);
}

/* Sets the y-coord of this hover. If the hover will be too far down on the screen,
    move it up so that it'll fit. */
Hover.prototype.setYPos = function(y) {
    var maxY = this.getMaxY();
    if (y > maxY) y = Math.max(this.getMinY(), maxY);
    this.yCoord = y;
}

Hover.prototype.getMinY = function() {
    return assureInt((Hover.documentBody? Hover.documentBody.scrollTop : 0) || window.pageYOffset || 0);
}

Hover.prototype.getMaxY = function() {
    return assureInt((Hover.documentBody? Hover.documentBody.clientHeight : 0) || window.innerHeight) +
        assureInt((Hover.documentBody? Hover.documentBody.scrollTop : 0) || window.pageYOffset || 0) - Hover.getElementHeight(this.ele);
}

Hover.prototype.loadAjaxHover = function(url) {
    var pageRequest = false;
    if (window.XMLHttpRequest) // if Mozilla, Safari etc
        pageRequest = new XMLHttpRequest();
    else if (window.ActiveXObject){ // if IE
        try {
            pageRequest = new ActiveXObject("Msxml2.XMLHTTP");
        }
        catch (e){
            try{
                pageRequest = new ActiveXObject("Microsoft.XMLHTTP");
            }
            catch (e){}
        }
    }
    else
        return false;
    var elementId = this.eid;
    pageRequest.onreadystatechange=function(){
    	if (window.Hover) {
	        window.Hover.getHover(elementId).loadPage(pageRequest);
    	}
    }
    pageRequest.open('GET', url, true);
    pageRequest.send(null);
    this.loaded=true;
}

Hover.prototype.loadPage = function(pageRequest) {

    if (pageRequest.readyState != 4) return;
	var pageRequestStatus;
	try {
	    pageRequestStatus=pageRequest.status;
	} catch (e) {
		// Firefox workaround
		// https://bugzilla.mozilla.org/show_bug.cgi?id=317600
		// The window.setTimeout workaround suggested in the bug report is in effect since this function 
		// is called as a result of a setTimeout however the NS_ERROR_NOT_AVAILABLE exception is still thrown. 
		// Alternate workaround implemented here is to catch and muffle the exception.
		// Check for result property. Check for message too in case non-Firefox browsers uses same result number.
		if (e.result == 0x80040111 && e.message.indexOf("NS_ERROR_NOT_AVAILABLE") != -1) {
			return;
		}
	}
	    
    if (pageRequestStatus==200 || window.location.href.indexOf("http")==-1){
        this.iFShim.setStyle('visibility', 'hidden');
        var content = getElementByIdCS(this.eid + "_content");
        content.innerHTML=pageRequest.responseText;

        this.loadHook_afterLoad();

        this.setXPos(this.xCoord);
        this.setYPos(this.yCoord);
        this.reposition();
        if (!this.hideTimer && this.showing)
            this.iFShim.setStyle('visibility', 'visible');
    }
}

Hover.prototype.loadHook_afterLoad = function() {
}

Hover.getElementWidth = function(obj) {
    return assureInt(obj.style.pixelWidth || obj.offsetWidth);
}
Hover.getElementHeight = function(obj) {
    return assureInt(obj.style.pixelHeight || obj.offsetHeight);
}

Hover.documentBody = (document.compatMode && document.compatMode != "BackCompat")? document.documentElement : document.body? document.body : null;

/**
 * HTPortal.js
 * Javascript for Help & Training portal
 */
function HTPortal() {}

HTPortal.HELP_LINKS_IDS = new Array("contents", "index", "faq", "glossary", "tips");
HTPortal.SUPPORT_LINKS_IDS = new Array("logACase", "myOpenCases", "myClosedCases", "allOpenCases", "allClosedCases");

HTPortal.getHelpDocsDir = function(contentUrl) {
    return contentUrl.substring(contentUrl.indexOf("/help/doc"), contentUrl.lastIndexOf("/") + 1);
}

HTPortal.getParameter = function(url, name) {
    var index = url.lastIndexOf(name + "=");
    if (index == -1) return null;

    var value = url.substr(index);
    if (value.indexOf("&") == -1) {
        value= value.substr(value.indexOf("=") + 1);
    } else {
        value = value.substring(value.indexOf("=") + 1, value.indexOf("&"));
    }

    return value;
}

HTPortal.getTopLevelPageUrl = function() {
    var host = location.host;
    var protocol = location.protocol;

    var url = protocol + "//" + host + "/help/doc/user_ed.jsp";
    var qs = "?";

    if (top && top.frames["nav"] && top.frames["body"]) {
        var navFrameUrl = top.frames["nav"].location.href;
        var tab = HTPortal.getParameter(navFrameUrl, HTPortal.pLOCATION);

        if (tab == "help") {
            if (top.frames["body"].frames["content"] && top.frames["body"].frames["toc"]) {
                var contentFrameUrl = top.frames["body"].frames["content"].location.href;

                var target = contentFrameUrl.substr(contentFrameUrl.lastIndexOf("/") + 1);

                var section;
                var tocFrameUrl = top.frames["body"].frames["toc"].location.href;
                if (tocFrameUrl.match("sfix.htm")) {
                    section = "index";
                } else {
                    section = HTPortal.getParameter(tocFrameUrl, HTPortal.pSECTION);
                }

                qs = qs + HTPortal.pSECTION + "=" + section + "&" + HTPortal.pLOCATION + "=" + tab + "&" + HTPortal.pTARGET + "=" + encodeURIComponent(target);
            }
        } else if(tab == "null") {
            var body = top.frames["body"].location.pathname;
            if (body == "/help/doc/user_ed_feature.jsp") {
                var bodyFrameUrl = top.frames["body"].location.href;
                var feature = HTPortal.getParameter(bodyFrameUrl, HTPortal.pFEATURE);
                qs = qs + HTPortal.pFEATURE + "=" + feature;
            } else if (body == "/_ui/training/help/CombinedSearchPage" || body == "/_ui/training/help/HelpSearchPage" || body == "/_ui/training/help/LocalSfdcSolutionSearchPage") {
                var bodyFrameUrl = top.frames["body"].location.href;
                var q = HTPortal.getParameter(bodyFrameUrl, "str");
                qs = qs + HTPortal.pBODY + "=" + encodeURIComponent(body) + "&str=" + q;
            } else if (body == "/_ui/training/help/pub/UserEdSolution") {
                var bodyFrameUrl = top.frames["body"].location.href;
                var orgId = HTPortal.getParameter(bodyFrameUrl, HTPortal.pORG_ID);
                var solnId = HTPortal.getParameter(bodyFrameUrl, HTPortal.pID);
                qs = qs + HTPortal.pBODY + "=" + encodeURIComponent(body) + "&" + HTPortal.pORG_ID + "=" + orgId + "&" + HTPortal.pID + "=" + solnId;
            }
        } else if(tab == "support") {

            qs = qs + HTPortal.pLOCATION + "=" + tab;

        } else if(tab == "training") {
            var qs_training = "";

            var body = top.frames["body"].location.pathname;
            if (body == "/train/register.jsp") {
                var bodyFrameUrl = top.frames["body"].location.href;
                var classId = HTPortal.getParameter(bodyFrameUrl, HTPortal.pID);

                var classDay = HTPortal.getParameter(bodyFrameUrl, HTPortal.pCLASS_DAY);

                qs_training = qs_training + "&" + HTPortal.pID + "=" + classId + "&" + HTPortal.pCLASS_DAY + "=" + classDay;
            } else if (body == "/train/training_frame.jsp") {
                var leftFrameUrl = top.frames["body"].frames["nav"].location.href;
                var track = HTPortal.getParameter(leftFrameUrl, HTPortal.pTRACK);
                var region = HTPortal.getParameter(leftFrameUrl, HTPortal.pSELECT_LOCATION);

                qs_training = qs_training + "&" + HTPortal.pTRACK + "=" + track + "&" + HTPortal.pSELECT_LOCATION + "=" + region;

                var rightFrameUrl = top.frames["body"].frames["detail"].location.href;
                var className = HTPortal.getParameter(rightFrameUrl, "class");
                if (className != null) {
                    qs_training = qs_training + "&" + HTPortal.pCLASS_NAME + "=" + className;
                }
            }

            qs = qs + HTPortal.pLOCATION + "=" + tab + "&" + HTPortal.pBODY + "=" + encodeURIComponent(body) + qs_training;
        }
    }

    return url + qs;
}

HTPortal.updatePageUrl = function() {
    try {
        var url = HTPortal.getTopLevelPageUrl();

        var email = top.frames["nav"].document.getElementById("email");

        if (email && url) {
            email.href = "mailto:?body=" + encodeURIComponent(url);
        }
    } catch (err) {
        // no-op over error. most likely another frame has not finished loading and this function will be handled by the that frame.
    }
}

HTPortal.highlightToc = function() {
    var topic = top.frames["body"].frames["content"].location.href;
    topic = topic.substring(topic.lastIndexOf('/')+1,topic.indexOf('.htm'));

    top.frames["body"].frames["toc"].HTMLTreeNode.prototype.openHTMLTree("none",topic);
}

HTPortal.checkHighlighting = function() {
    var navFrameUrl = top.frames["nav"].location.href;
    var tab = HTPortal.getParameter(navFrameUrl, HTPortal.pLOCATION);

    if (navFrameUrl) {
        if (tab == "help") {
            var contentUrl = top.frames["body"].frames["content"].location.pathname;
            var tocUrl = top.frames["body"].frames["toc"].location.pathname;

            if (contentUrl && tocUrl) {
                if (tocUrl.match("sfix.htm")) {
                    HTPortal.clearHighlightingExceptLinkIndex(tab, 1);
                    HTPortal.highlightId("index");
                } else if (contentUrl.match("faq.htm")) {
                    HTPortal.clearHighlightingExceptLinkIndex(tab, 2);
                    HTPortal.highlightId("faq");
                } else if (contentUrl.match("glossary.htm")) {
                    HTPortal.clearHighlightingExceptLinkIndex(tab, 3);
                    HTPortal.highlightId("glossary");
                } else if (contentUrl.match("quicktour_tips.htm")) {
                    HTPortal.clearHighlightingExceptLinkIndex(tab, 4);
                    HTPortal.highlightId("tips");
                } else if (tocUrl.match("helptoc.jsp")) {
                    HTPortal.clearHighlightingExceptLinkIndex(tab, 0);
                    HTPortal.highlightId("contents");
                }
            }
        }
    }
}

HTPortal.clearHighlightingExceptLinkIndex = function(tab, linkIndex) {
    var id;
    if (tab == "help") {
        for (id in HTPortal.HELP_LINKS_IDS) {
            if (id != linkIndex) {
                HTPortal.clearHighlightId(HTPortal.HELP_LINKS_IDS[id]);
            }
        }
    } else if (tab == "support") {
        for (id in HTPortal.SUPPORT_LINKS_IDS) {
            if (id != linkIndex) {
                HTPortal.clearHighlightId(HTPortal.SUPPORT_LINKS_IDS[id]);
            }
        }
    }
}

HTPortal.highlightId = function(linkId) {
    var linkObj = top.frames["nav"].document.getElementById(linkId);
    if (linkObj) {
        HTPortal.highlight(linkObj);
    }
}

HTPortal.clearHighlightId = function(linkId) {
    var linkObj = top.frames["nav"].document.getElementById(linkId);
    if (linkObj) {
        HTPortal.clearHighlight(linkObj);
    }
}

HTPortal.highlight = function(linkObj) {
    if (linkObj.className != "selected") {
        linkObj.className="selected";
    }
}

HTPortal.clearHighlight = function(linkObj) {
    if (linkObj.className != "") {
        linkObj.className = "";
    }
}
function ListElement(formName) {
	this.formName = formName;
}

ListElement.prototype.cbWarn = function() {
	var form = document.getElementById(this.formName);
	for (i = 0; i < form.elements.length; i++) {
		if ((form.elements[i].name == ListView.CHECKBOX_ID) && form.elements[i].checked) {
			if (window.confirm(LC.getLabel("List", "checkboxWarning"))) {
				// start from i, because all the previous ones were false.
				for (j = i; j < form.elements.length; j++) {
					if (form.elements[j].name == ListView.CHECKBOX_ID) { 
						form.elements[j].checked = false; 
					}
				}
				return true;
			} else {
				return false;
			}
		}
	}
	return true;
}
                
ListElement.getList = function(formName) {
	return instances[formName];
}

ListElement.instances = {};

ListElement.createListElement = function(formName) {
	ListElement.instances[formName] = new ListElement(formName);
}
/**
 * Represents a column in a list back by an udd column. Renders and edits the column through
 * the inline edit field corresponding to this column.
 * 
 * @author jmooney
 * @since 154
 */
function ListFilterColumn(columnData) {
    this.columnName = columnData[InlineEditConstants.COLUMN_NAME];
    this.label = columnData[InlineEditConstants.COLUMN_LABEL];
    this.state = InlineEditState[columnData[InlineEditConstants.FIELD_STATE]];
    if (this.state == InlineEditState.EDIT) {
        this.columnType = InlineEditField.resolveSwitchableField(columnData);
        // can't edit person names yet
        if (this.columnType == ColumnType.PERSONNAME || this.columnType == ColumnType.SWITCHABLE_PERSONNAME) {
            this.state = InlineEditState.NONE;
        } else {
            this.fieldId = columnData[InlineEditConstants.FIELD_ID];
            this.columnId = columnData[InlineEditConstants.COLUMN_ID];
            this.required = columnData[InlineEditConstants.FIELD_REQUIRED];
            // special case for person names
            if (this.columnId == "FirstName" || this.columnId == "Salutation") {
                this.required = false;
            }
            var extra = this.columnType.inlineEditExtraData;
            if (extra) {
                this.extraData = {};
                for (var i = 0; i <  extra.length; i++) {
                    this.extraData[extra[i]] = columnData[extra[i]];
                }
            }
            this.fieldObject = null;
        }
    }
}

ListFilterColumn.prototype.getFieldId = function() {
    if (this.fieldId) {
        var id = this.fieldId;
        if (this.columnId) {
            id += this.columnId;
        }
        return id;
    } else {
        return this.columnName;
    }
}

ListFilterColumn.prototype.createEditElements = function(editDiv, initialValue) {
    var id = this.getFieldId();
    if (initialValue === null) {
        // use a blank initial value
        var initialValue = "";
        if (this.columnType == ColumnType.BOOLEAN) {
            initialValue = false;
        } else if (this.columnType == ColumnType.DYNAMICENUM) {
            initialValue = ["", "", null];
        } else if (this.columnType == ColumnType.MULTIENUM) {
            initialValue = null;
        } else if (this.columnType == ColumnType.ENTITYID) {
            initialValue = ["", Udd.EMPTY_KEY];
        }
    }
    var ctor = this.columnType.inlineEditFieldConstructor();
    this.fieldObject = new ctor(id, this.state, this.required, true, initialValue, this.extraData);
    this.fieldObject.label = this.label;
    this.fieldObject.tableCell = editDiv.parentNode;
    this.fieldObject.editDiv = editDiv;
    this.fieldObject.createEditElements();
    this.fieldObject.created = true;
}

ListFilterColumn.prototype.setError = function(errorMsg) {
    if (this.fieldObject) {
        this.fieldObject.setError(errorMsg);
    }
}

ListFilterColumn.prototype.getDisplayValue = function() {
    if (this.fieldObject) {
        return this.fieldObject.formatValue();
    }
}

ListFilterColumn.prototype.addSaveData = function(saveData) {
    this.fieldObject.currentValue = this.fieldObject.getValueFromEdit();
    saveData["fieldId"] = this.fieldId;
    saveData["columnId"] = this.columnId;
    saveData["nullable"] = !this.required;
    this.fieldObject.addSaveData(saveData);
}

ListFilterColumn.prototype.onDisplay = function() {
    var editElement = this.fieldObject.editElement;
    if (editElement) {
        editElement.focus();
        if (this.fieldObject.saveOnEnter) {
            editElement.onkeypress = function(e) {
                e = getEvent(e);
                if (e.keyCode == KEY_ENTER) {
                    eventCancelBubble(e);
                    document.getElementById('saveButton').click();
                }
            };
        }
        if (editElement.type == "text") {
            editElement.select();
        }
    }
}

/**
 * JS code to handle filtering in a ShareRuleSelectFilterElement.
 */
var ShareRuleSelectFilterElement = function(){
}

// filtering the drop-down based on the controller is really just showing
// the right corresponding drop-down and hiding the others.
ShareRuleSelectFilterElement.prototype.filterDropdown = function(name, map, currTypeSelect) {
    var selected = currTypeSelect.selectedIndex;
    var selectedMappedOption = this.getMappedOption(selected, map, currTypeSelect);
    for (var i = 0; i < currTypeSelect.options.length; i++){
        var mappedOption = this.getMappedOption(i, map, currTypeSelect);
        var optionList = name + '_' + mappedOption;
        var currSelect = document.getElementById(optionList);
        if (currSelect) {
        	if (mappedOption == selectedMappedOption) {
		        if (i == selected){
		            currSelect.style.display = 'inline';
		        }
		    } else {
	            currSelect.style.display = 'none';
	        }
        }
    }
}

ShareRuleSelectFilterElement.prototype.getMappedOption = function(index, map, currTypeSelect) {
	var option = currTypeSelect.options[index].value;
    var mappedOption = map[option];
    if (!mappedOption) {
       	mappedOption = option;
    }
    return mappedOption;
}
function ButtonInputElement() {}

ButtonInputElement.prototype.enableButton = function(name, enable) {
    var buttons = document.getElementsByName(name);
    if (buttons) {
        for (var i = 0; i < buttons.length; i++) {
            var button = buttons[i];

            button.disabled = !enable;
            button.className =enable ?  'btn' : 'btnDisabled';
        }
    }
}

var CalDnD = {
    view : "",
    dragIndicatorId : "",
    draggerEventBlockId : "",
    alldayDropId : "",
    statusImgId : "",
    valid : false,
    editionInfo : "",
    lastDropZoneId : "",
    timer : null,
    highlightColor : "#FEFA01",

    init : function(view, dragIndicatorId, draggerEventBlockId, alldayDropId, statusImgId) {
        CalDnD.view = view;
        CalDnD.dragIndicatorId = dragIndicatorId;
        CalDnD.draggerEventBlockId = draggerEventBlockId;
        CalDnD.alldayDropId = alldayDropId;
        CalDnD.statusImgId = statusImgId;

        window.sfdcPage.appendToOnloadQueue(function() {CalDnD.alignDropZones(CalDnD.view)});
        window.sfdcPage.appendToOnloadQueue(function() {CalDnD.redefineSidebarPin(CalDnD.view)});

        addEvent(window, "resize", function() {CalDnD.alignDropZones(CalDnD.view)});
    },

    hideNoDrop : function() {
        var drag = document.getElementById(CalDnD.dragIndicatorId);
        if (drag.className.indexOf(" accept") < 0)
            drag.className += " accept";
    },

    showNoDrop : function() {
        var drag = document.getElementById(CalDnD.dragIndicatorId);
        drag.className = drag.className.replace(" accept", "");
    },

    // these keep the no-drop indicator from flickering in IE as you drag from row to row
    mouseOutNoDrop : function() {
        if (CalDnD.timer) {
            clearTimeout(CalDnD.timer);
        }
        CalDnD.timer = setTimeout('CalDnD.showNoDrop()', 10);
    },

    mouseOverNoDrop : function() {
        if (CalDnD.timer) {
            clearTimeout(CalDnD.timer);
            CalDnD.timer = null;
        }
        CalDnD.hideNoDrop();
    },

    dragEnter : function(fid) {
        CalDnD.lastDropZoneId = fid;

        CalDnD.valid = true;

        var dropzone = document.getElementById(fid);
        dropzone.style.backgroundColor = CalDnD.highlightColor;
        CalDnD.moveStatus(dropzone);
    },

    dragExit : function(fid) {
        var dropzone = document.getElementById(fid);
        dropzone.style.backgroundColor = "";

        CalDnD.valid = false;
    },

    dragStart : function(fid) {
        var eventDiv = document.getElementById(fid);
        CalDnD.matchWidths(eventDiv);
        CalDnD.showDropZones();
        CalDnD.ghost(eventDiv)
    },

    dragEnd : function(fid) {
        var eventDiv = document.getElementById(fid);

        if (!CalDnD.valid) {
            CalDnD.unghost(eventDiv);
            CalDnD.hideDropZones();
        }

        if (CalDnD.valid) {
            // ensures new hovers on rerendered page
            Hover.clearHovers();
        }
    },

    ghost : function(eventDiv) {
        eventDiv.style.opacity = "0.5";
        eventDiv.style.filter = "alpha(opacity=50)";
    },

    unghost : function(eventDiv) {
        eventDiv.style.opacity = "";
        eventDiv.style.filter = "";
    },

    alignDropZones : function(which) {
        var swhich = which?which:CalDnD.view;

        switch (swhich) {
        case "daily":
            var dropAllDay = document.getElementById(CalDnD.alldayDropId);
            var allDayRow = document.getElementById("alldayrow");

            dropAllDay.style.height = allDayRow.offsetHeight + "px";

            var dropZones = document.getElementById("dropZones");
            var calTableBody = document.getElementById("calTableBody");

            var x = 0;
            var y = 0;
            var element = calTableBody;
            while (element != null && element != dropZones.offsetParent) {
                x += element.offsetLeft;
                y += element.offsetTop;
                element = element.offsetParent;
            }

            dropZones.style.left = x + "px";
            dropZones.style.top = y + "px";
            dropZones.style.width = calTableBody.offsetWidth + "px";

               break;
        case "weekly":
            // allday zones
            var dayNameRow = document.getElementById("daynamerow");
            var dropAllDay = document.getElementById("dropalldayrow");
            var allDayRowHeight = document.getElementById("alldayrowlabel").offsetHeight;
    
            // fix the height of each all-day drop zone to the size of all-day label cell
            for(var i=0; i < dropAllDay.cells.length; i++) {
                var children = dropAllDay.cells[i].childNodes;
                
                
                for(var j=0; j < children.length; j++) {
                    if(children[j].nodeName.toUpperCase() == "DIV") {
                        if (allDayRowHeight > 26) {
                            children[j].style.height = allDayRowHeight + "px";
                        } else {
                            children[j].style.height = "26px";
                        }
                        break;
                    }
                }
            }
            for(var i=0; i < dropAllDay.cells.length; i++) {
                dropAllDay.cells[i].style.width = dayNameRow.cells[i+1].offsetWidth + "px";
            }
            
            var dropZones = document.getElementById("dropZones");
            var calTableBody = document.getElementById("calTableBody");

            var x = 0;
            var y = 0;
            var element = calTableBody;
            while (element != null && element != dropZones.offsetParent) {
                x += element.offsetLeft;
                y += element.offsetTop;
                element = element.offsetParent;
            }
            
            // timed zones
            var timecell = document.getElementById("timecellref");
            // width of timeCell column
            var xOffset = timecell.offsetWidth;

            var namerow = document.getElementById("daynamerow");
            var numrow = document.getElementById("daynumberrow");
            // height of day name and day number rows
            var yOffset = namerow.offsetHeight + numrow.offsetHeight;

            dropZones.style.left = (x + xOffset) + "px";
            dropZones.style.top = (y + yOffset) +  "px";
            dropZones.style.width = (calTableBody.offsetWidth - xOffset) + "px";
            
            break;
        }
    },

    showDropZones : function() {
        document.getElementById("dropZones").style.visibility = "";
    },

    hideDropZones : function() {
        document.getElementById("dropZones").style.visibility = "hidden";
    },

    matchWidths : function(eventDiv) {
        var drag = document.getElementById(this.draggerEventBlockId);
        drag.style.width = eventDiv.offsetWidth + "px";
    },

    moveStatus : function(dropzone) {
        var status = document.getElementById("theStatus");
        var statusImg = document.getElementById(CalDnD.statusImgId)

        var x = 0;
        var y = 0;
        var element = dropzone;
        while (element != null && element != status.offsetParent) {
            x += element.offsetLeft;
            y += element.offsetTop;
            element = element.offsetParent;
        }

        // centers status indicator inside the dropzone
        // TODO: jtroup - need to find a way to get the width/height of statusImg in IE and get rid of this magic number business
        var centerXOffset = (dropzone.offsetWidth / 2) - 8;
        var centerYOffset = (dropzone.offsetHeight / 2) - 8;

        status.style.position = "absolute";
        status.style.left = (x + centerXOffset) + "px";
        status.style.top = (y + centerYOffset) + "px";
    },

    // causes recalculation of drop zones when sidebar is collapsed/uncollapsed
    redefineSidebarPin : function(theView) {
      Sidebar.prototype.theSidebar.pin = function() {
          Sidebar.prototype.pin.apply(Sidebar.prototype.theSidebar);
          CalDnD.alignDropZones(theView);
      };
    }


};
function CalendarTaskList() {}

CalendarTaskList.verifySelected = function(form, element_name, errorMessage) {
	var initialCheck = verifyChecked(form, element_name, errorMessage);
	if (initialCheck) {
		var selected = 0;
		for (i = 0; i < form.elements.length; i++) {
	        if ((form.elements[i].name == element_name) && form.elements[i].checked) {
	            selected++;
	        }
		}
		if (selected > TaskMassAction.ROW_LIMIT) {
			alert(LC.getLabel('List', 'checkboxLimit', TaskMassAction.ROW_LIMIT));
			return false;
		}
		return true;
	}
	return initialCheck;
}

var BusinessHoursPage = {};

// Set one time to reflect all-day support
BusinessHoursPage.set24x7Hours = function (checked, startInputId, endInputId, twelveOClock) {
    var startInputElement = document.getElementById(startInputId);
    var endInputElement = document.getElementById(endInputId);

    if (checked) {
        startInputElement.className = "timeInputActive";
        startInputElement.value = twelveOClock;
        startInputElement.disabled = true;

        endInputElement.className = "timeInputActive";
        endInputElement.value = twelveOClock;
        endInputElement.disabled = true;
    } else {
        startInputElement.disabled = false;
        endInputElement.disabled = false;
    }
}

/**
  JS code for attaching events for CompactLayoutUi.

  @author polcari
  @since 144
*/
function CompactLayoutUi(_unusedItems, _leftColItems, _rightColItems) {
  var clUi = this;
  this.appendToOnloadQueue(function() {clUi.attachEvents();});
}

CompactLayoutUi.prototype = new GenericSfdcPage();

CompactLayoutUi.prototype.initialize = function(_unusedItems, _leftColItems, _rightColItems) {
  this.unusedItems = _unusedItems;
  this.leftColItems = _leftColItems;
  this.rightColItems = _rightColItems;
}

CompactLayoutUi.prototype.attachEvents = function() {
  var unusedSelectBox = document.getElementById(this.unusedItems);
  var leftColBox = document.getElementById(this.leftColItems);
  var rightColBox = document.getElementById(this.rightColItems);

  var clUi = this;

  //attach the events to the images on the page
  //TODO: polcari - 146: this should be done declaratively in GenericSfdcPage....  Each subclass returns a list of ids, handlers, functions & 'captures'
  //						"elements" should also implement this declarative event-attaching method - rather than id's, they are attached via classname (since there can be multiple elements per page).
  //                        These elements must have an id, because we can't hunt through the DOM for looking for classnames
  CompactLayoutUi.addClick(document.getElementById(CompactLayoutUiConst.switchColumnToRight), function() {moveOption(leftColBox, rightColBox, LC.getLabel("SelectElement", "Required"), [], null, LC.getLabel("SelectElement", "Required"));});
  CompactLayoutUi.addClick(document.getElementById(CompactLayoutUiConst.switchColumnToLeft), function() {moveOption(rightColBox, leftColBox, LC.getLabel("SelectElement", "Required"), [], null, LC.getLabel("SelectElement", "Required"));});

  CompactLayoutUi.addClick(document.getElementById(CompactLayoutUiConst.hideItemsLeft), function() {moveOption(leftColBox, unusedSelectBox, LC.getLabel("SelectElement", "Required"), [], null, LC.getLabel("SelectElement", "Required"));});
  CompactLayoutUi.addClick(document.getElementById(CompactLayoutUiConst.showItemsLeft), function() {moveOption(unusedSelectBox, leftColBox, LC.getLabel("SelectElement", "Required"), [], null, LC.getLabel("SelectElement", "Required"));});

  CompactLayoutUi.addClick(document.getElementById(CompactLayoutUiConst.hideItemsRight), function() {moveOption(rightColBox, unusedSelectBox, LC.getLabel("SelectElement", "Required"), [], null, LC.getLabel("SelectElement", "Required"));});
  CompactLayoutUi.addClick(document.getElementById(CompactLayoutUiConst.showItemsRight), function() {moveOption(unusedSelectBox, rightColBox, LC.getLabel("SelectElement", "Required"), [], null, LC.getLabel("SelectElement", "Required"));});

  CompactLayoutUi.addClick(document.getElementById(CompactLayoutUiConst.saveButtonId), function() {clUi.selectAll(); return true;});
}

CompactLayoutUi.prototype.selectAll = function () {
  var leftColBox = document.getElementById(this.leftColItems);
  var rightColBox = document.getElementById(this.rightColItems);

  for(var i = 0;i < leftColBox.length;i++) { leftColBox.options[i].selected=true; }
  for(var i = 0;i < rightColBox.length;i++) { rightColBox.options[i].selected=true; }
}

//Convenience function to save typing
CompactLayoutUi.addClick = function(elem, fn) {
  addEvent(elem, 'click', fn, false);
}

/**
 * OverlayDialog creates a modal or non-modal dialog in a div overlay.
 *
 * @author jmooney
 * @since 150
 */

function OverlayDialog() {
    this.id = null;
    this.dialog = null; // to hold the div element once it has been created
    this.isModal = true;
    this.extraClass = "";
    this.background = null; // create the background lazily
    this.width = OverlayDialog.MAX_WIDTH;
    this.minHeight = OverlayDialog.MIN_HEIGHT;
    this.minWidth = OverlayDialog.MIN_WIDTH;
    this.buttons = [];
    // setup default buttons
    this.title = null;
    this.header = null;
    this.info = null;
    this.isOpen = false;
    this.created = false;
    this.displayX = true;
    this.isResizable = false;
    this.isMovable = false;
    this.positioned = false;
    this.moving = false;
    this.resizing = false;
    this.fixedX = 0;
    this.fixedY = 0;
    this.relativeX = 0;
    this.relativeY = 0;
    this.changeX = 0;
    this.changeY = 0;
}

OverlayDialog.prototype.addEvents = function() {
    var self = this;
    addEvent(document, "keydown", function(e) { self.handleKeyPress(e); }, false);
    addEvent(window, "resize", function() { self.resizeEvent(); }, false);
    if (XBrowser.userAgent.isIE6) {
        addEvent(window, "scroll", function() { self.scrollEvent(); }, false);
    }
}

OverlayDialog.prototype.setTitle = function(title) {
    this.title = title;
    if (this.created) {
        document.getElementById(this.id + "Title").innerHTML = this.title;
    }
}

OverlayDialog.prototype.setHeader = function(header) {
    this.header = header;
    if (this.created) {
        document.getElementById(this.id + "Header").innerHTML = this.header;
    }
}

OverlayDialog.prototype.setInfo = function(info) {
    this.info = info;
    if (this.created) {
        document.getElementById(this.id + "Info").innerHTML = this.info;
    }
}

OverlayDialog.prototype.setWidth = function(width) {
    this.width = width;
    if (this.created) {
        if (typeof width == "string") {
            this.dialog.style.width = width;
        } else {
            this.dialog.style.width = width + "px";
        }
        if (this.isOpen) {
            this.position();
        }
    }
}

// the minimum height allowed when resizing
OverlayDialog.prototype.setMinHeight = function(minHeight) {
    this.minHeight = minHeight;
}

// the minimum width allowed when resizing
OverlayDialog.prototype.setMinWidth = function(minWidth) {
    this.minWidth = minWidth;
}

/**
 * by default, button 0 is Ok, 1 is cancel, 2 is null.
 * Override a button with a different label and a function that should be called when the button is pressed.
 * The function passed in can either be a function reference or just a string. The function should return
 * true if the dialog should hide itself, false if it should stay open.
 * Example:
 *
 * function verifySave() {...}
 * dialog.overrideButton(0, "Save", checkSave);
 * -OR-
 * dialog.overrideButton(0, "Save", "checkSave()");
 *
 * using a string you can actually pass in jsut an expression:
 * dialog.overrideButton(2, "Special", "checkSave() && something > 15");
 *
 */
OverlayDialog.prototype.overrideButton = function(index, disp, fn) {
    if (index >= OverlayDialog.MAX_BUTTONS) {
        throw "Cannot have more than " + OverlayDialog.MAX_BUTTONS + " buttons.";
    }
    this.buttons[index] = { display: disp, action: fn };
}

OverlayDialog.prototype.setupDefaultButtons = function() {
    this.buttons = [];
    this.buttons[0] = { display: LC.getLabel("Buttons", "ok"), action: null };
    this.buttons[1] = { display: LC.getLabel("Buttons", "cancel"), action: null };
}

/**
 * Remove all action buttons from the dialog (the ones at the bottom).
 */
OverlayDialog.prototype.clearButtons = function() {
    this.buttons = [];
}

// constants
OverlayDialog.MAX_BUTTONS = 4;
OverlayDialog.MAX_WIDTH = 800;
OverlayDialog.MIN_WIDTH = 300;
OverlayDialog.MIN_HEIGHT = 200;
OverlayDialog.EDGE_BUFFER = 40;

OverlayDialog.prototype.show = function() {
    this.dialog.style.display = "block";
    this.position();
    if (this.isModal) {
        if (!this.background) {
            this.createBackground();
        }
        this.background.style.display = "block";
        // have to hide all selects, even an iframeshim causes flickering
        if (XBrowser.userAgent.isIE6) {
            var allSelects = document.getElementsByTagName("select");
            var dialogSelects = this.dialog.getElementsByTagName("select");
            var allLength = allSelects.length;
            var dialogLength = dialogSelects.length;
            for (var i = 0; i < allLength; i++) {
                // could save the old values but nobody ever uses visibility on selects
                allSelects[i].style.visibility = "hidden";
            }
            for (var i = 0; i < dialogLength; i++) {
                // could save the old values but nobody ever uses visibility on selects
                dialogSelects[i].style.visibility = "visible";
            }
        }
    }
    this.dialog.style.visibility = "visible";
    this.isOpen = true;
}

OverlayDialog.prototype.hide = function() {
    if (this.isMovable) {
        this.stopDrag();
    }
    if (this.isModal) {
        this.background.style.display = "none";
        if (XBrowser.userAgent.isIE6) {
            var allSelects = document.getElementsByTagName("select");
            var allLength = allSelects.length;
            for (var i = 0; i < allLength; i++) {
                // could save the old values but nobody ever uses visibility on selects
                allSelects[i].style.visibility = "visible";
            }
        }
    }
    this.dialog.style.visibility = "hidden";
    this.dialog.style.display = "none";
    this.isOpen = false;
}

/**
 * called when clicking on the X or pressing esc to get out of the dialog
 */
OverlayDialog.prototype.cancel = function() {
    this.hide();
}

OverlayDialog.prototype.handleKeyPress = function(e) {
    if (this.isOpen) {
        e = getEvent(e);
        var key = e.keyCode;
        if (key == KEY_ESC) {
            this.cancel();
        } else if (key == KEY_ENTER && this.captureEnter(getEventTarget(e))) {
            this.enter();
        }
    }
}

// don't capture enter event from links, buttons, or textareas
OverlayDialog.prototype.captureEnter = function(target) {
    return target.nodeName != "A" && target.nodeName != "TEXTAREA" && target.type != "button";
}

OverlayDialog.prototype.enter = function() {
    // does nothing by default
}

OverlayDialog.prototype.position = function() {
    if (this.resizing) {
        var width = this.startWidth + this.changeX;
        var height = this.startHeight + this.changeY;
        if (width < this.minWidth) {
            width = this.minWidth;
        }
        if (height < this.minHeight) {
            height = this.minHeight;
        }
        this.dialog.style.width = width + "px";
        this.dialog.style.height = height + "px";
        var inner = document.getElementById(this.getContentId());
        // subtract size of top/bottom bars
        inner.style.height = (height - 46) + "px";
    } else {
        // all dialogs still get centered the first time
        if (!this.positioned) {
            this.setInnerHeight();
            var left = getWindowWidth() - this.dialog.offsetWidth;
            left = left < 6 ? 6 : left / 2;
            var top = getWindowHeight() - this.dialog.offsetHeight;
            top = top < 6 ? 6 : top / 2;
            this.fixedX = left;
            this.fixedY = top;
        } else {
            // check for viewport overflow, from dragging off the screen or resize
            var maxX = getWindowWidth() - OverlayDialog.EDGE_BUFFER;
            var maxY = getWindowHeight() - OverlayDialog.EDGE_BUFFER;
            var minX = OverlayDialog.EDGE_BUFFER - this.dialog.offsetWidth;
            var minY = OverlayDialog.EDGE_BUFFER / 2;
            if (this.fixedX < minX) {
                this.fixedX = minX;
            } else if (this.fixedX > maxX) {
                this.fixedX = maxX;
            }
            if (this.fixedY < minY) {
                this.fixedY = OverlayDialog.EDGE_BUFFER;
            } else if (this.fixedY > maxY) {
                this.fixedY = maxY;
            }
        }
        if (XBrowser.userAgent.isIE6) {
            this.dialog.style.left = (this.fixedX + getScrollX()) + "px";
            this.dialog.style.top = (this.fixedY + getScrollY()) + "px";
        } else {
            this.dialog.style.left = this.fixedX + "px";
            this.dialog.style.top = this.fixedY + "px";
        }
    }
}

OverlayDialog.prototype.setInnerHeight = function() { }

OverlayDialog.prototype.createBackground = function() {
    this.background = document.createElement("div");
    this.background.className = "overlayBackground";
    if (this.dialog.currentStyle && XBrowser.userAgent.isIE6) {
        this.background.style.width = document.body.offsetWidth + "px";
        this.background.style.height = document.body.offsetHeight + "px";
    } else {
        this.background.style.width = document.documentElement.scrollWidth + "px";
        this.background.style.height = document.documentElement.scrollHeight + "px";
    }
    document.body.appendChild(this.background);
    var self = this;
    addEvent(this.background, "mousedown", function(e) { self.smash(e); }, false);
    addEvent(this.background, "click", function(e) { self.smash(e); }, false);
}

OverlayDialog.prototype.scrollEvent = function() {
    // this is only called for IE6
    if (this.created) {
        this.position();
    }
}

OverlayDialog.prototype.resizeEvent = function() {
    if (this.created) {
        if (this.background) {
            if (this.background.currentStyle && XBrowser.userAgent.isIE6) {
                this.background.style.width = document.body.offsetWidth + "px";
                this.background.style.height = document.body.offsetHeight + "px";
            } else {
                this.background.style.width = document.documentElement.scrollWidth + "px";
                this.background.style.height = document.documentElement.scrollHeight + "px";
            }
        }
        this.position();
    }
}

OverlayDialog.prototype.createDialog = function() {
    var div = document.createElement("div");
    div.id = this.id;
    div.className = "overlayDialog " + this.extraClass;
    if (typeof this.width == "string") {
        div.style.width = this.width;
    } else if (typeof this.width == "number") {
        div.style.width = this.width + "px";
    }
    var html = [];
    html.push("<div class='topRight");
    if (this.isMovable) {
        html.push(" movable");
    }
    html.push("'><div class='topLeft'>");
    if (this.displayX) {
        html.push("<img onmouseover=\"this.className = 'dialogCloseOn'\" onmouseout=\"this.className = 'dialogClose'\" onclick=\"sfdcPage.getDialogById('");
        html.push(this.id);
        html.push("').cancel()\" class='dialogClose' src='/s.gif'>");
    }
    html.push("<h2 id='");
    html.push(this.id);
    html.push("Title'>");
    html.push(this.title);
    html.push("</h2></div></div><div class='middle'><div class='innerContent' id='");
    html.push(this.getContentId());
    html.push("'></div></div>");
    if (this.isResizable) {
        html.push("<div id='");
        html.push(this.id);
        html.push("Resize' class='dialogResize'></div>");
    }
    html.push("<div class='bottomRight'><div class='bottomLeft'></div></div>");
    div.innerHTML = html.join("");
    document.body.appendChild(div);
    this.dialog = div;
    var self = this;
    if (this.isMovable || this.isResizable) {
        addEvent(document, "mouseup", function() { self.stopDrag(); }, false);
        if (this.isMovable) {
            var dragger = this.dialog.firstChild;
            addEvent(dragger, "mousedown", function(e) { self.startMove(e); }, false);
            addEvent(document, "mousemove", function(e) { self.move(e); }, false);
        }
        if (this.isResizable) {
            var resizer = document.getElementById(this.id + "Resize");
            addEvent(resizer, "mousedown", function(e) { self.startResize(e); }, false);
            addEvent(document, "mousemove", function(e) { self.resize(e); }, false);
        }
    }
    this.createContent();
    this.created = true;
}

OverlayDialog.prototype.createContent = function() { }

OverlayDialog.prototype.startMove = function(e) {
    e = getEvent(e);
    var target = getEventTarget(e);
    // don't drag from the X
    if (target.nodeName != "IMG") {
        this.positioned = true;
        this.moving = true;
        this.relativeX = e.clientX - this.dialog.offsetLeft;
        this.relativeY = e.clientY - this.dialog.offsetTop;
        if (XBrowser.userAgent.isIE6) {
            this.relativeX += getScrollX();
            this.relativeY += getScrollY();
        }
        this.fixedX = e.clientX - this.relativeX;
        this.fixedY = e.clientY - this.relativeY;
        this.smash(e);
    }
}

OverlayDialog.prototype.startResize = function(e) {
    e = getEvent(e);
    this.positioned = true;
    this.resizing = true;
    this.relativeX = e.clientX;
    this.relativeY = e.clientY;
    this.startWidth = this.dialog.offsetWidth;
    this.startHeight = this.dialog.offsetHeight;
    this.smash(e);
}

OverlayDialog.prototype.stopDrag = function() {
    this.moving = false;
    this.resizing = false;
}

OverlayDialog.prototype.move = function(e) {
    if (this.moving) {
        e = getEvent(e);
        this.smash(e);
        this.fixedX = e.clientX - this.relativeX;
        this.fixedY = e.clientY - this.relativeY;
        this.position();
    }
}

OverlayDialog.prototype.resize = function(e) {
    if (this.resizing) {
        e = getEvent(e);
        this.smash(e);
        this.changeX = e.clientX - this.relativeX;
        this.changeY = e.clientY - this.relativeY;
        this.position();
    }
}

OverlayDialog.prototype.smash = function(e) {
    if (e.stopPropagation) {
        e.stopPropagation();
    } else {
        e.cancelBubble = true;
    }
    if (e.preventDefault) {
        e.preventDefault();
    } else {
        e.returnValue = false;
    }
}

OverlayDialog.prototype.getContentId = function() {
    return this.id + "Content";
}

OverlayDialog.prototype.createButtons = function(html) {
    html.push("<div class='buttons'>");
    for (var i = 0; i < this.buttons.length; i++) {
        var display = this.buttons[i].display;
        var action = this.buttons[i].action;
        html.push("<input class='btn' type='button' value='");
        html.push(display);
        html.push("' onclick=\"");
        if (typeof action == "string") {
            html.push("if(");
            html.push(action.replace(/"/, "\\\""));
            html.push(")");
        } else if (typeof action == "function") {
            html.push("if(");
            html.push(action.name);
            html.push("())");
        }
        html.push("sfdcPage.getDialogById('");
        html.push(this.id);
        html.push("').hide();\">");
    }
    html.push("</div>");
}

OverlayDialog.prototype.register = function() {
    sfdcPage.registerDialog(this);
}


/*
 * @author ldelascurain
 * @since 154
 *
 */

function DefaultTabWarning( selectedTabsId ) {
	this.selectedTabsId = selectedTabsId;
};

/* Returns true if the default option is in the selection to be removed from selectedTabsId.
 * Used by ConfigureMyTabs to decide whether to warn that the default tab is going to be removed. */
DefaultTabWarning.prototype.defaultIsSelectedToMove = function() {
	var selectedTabs = document.getElementById(this.selectedTabsId);
	var options = selectedTabs.options;
	for (var i=0;i<options.length;i++){
		if (options[i].selected && this.isDefault(options[i].text)){
			return true;
		}
	}
	return false;
};

DefaultTabWarning.prototype.isDefault = function( value ) {
	var defaultString = LC.getLabel("Page_My_Tabs", "DefaultTabMarkerOnly");
	if (value.indexOf(defaultString) >= 0){
		return true;
	}
	return false;
};

var UrlMap = new function(){
    this.urlMap = [];
    this.urlMap["EventTeamView"] = "/appex/calendar/cal.jsp";
    this.urlMap["Login"] = "/secur/login_page.jsp";
    this.urlMap["Home"] = "/home/home.jsp";
    this.urlMap["Inviter"] = "/email/inviter.jsp";
    this.urlMap["ComboBox"] = "/widg/combobox.jsp";
    this.urlMap["EmailAuthorPopupCloser"] = "/email/author/popupcloser.jsp";
    this.urlMap["BlankPage"] = "/blank.html";

    this.getURL = function(key) {
        return this.urlMap[key];
    };

    // simple format of JSPDispatcher.getURL
    this.convertClassNameToUrl = function(className, qs) {
        var result = new String("/");
        var classString = new String(className);

        // if this isn't in the standard package, the url needs to start with ui/general to signal that
        if (classString.indexOf(JSPDispatcher.STANDARD_PACKAGE + ".") != 0) {
            result = result.concat(JSPDispatcher.NONSTANDARD_PACKAGE_PREFIX);
        }
        // replace . with /
        result = result.concat(classString.replace(/\./g, '/'));
        if (qs != null) {
            result = result.concat(qs.toString());
        }
        return result.valueOf();
    }
}
// ===================================================================
// Author: Matt Kruse <matt@mattkruse.com>
// WWW: http://www.mattkruse.com/
// ===================================================================

// HISTORY
// ------------------------------------------------------------------
// May 17, 2003: Fixed bug in parseDate() for dates <1970
// March 11, 2003: Added parseDate() function
// March 11, 2003: Added "NNN" formatting option. Doesn't match up
//                 perfectly with SimpleDateFormat formats, but 
//                 backwards-compatability was required.

// ------------------------------------------------------------------
// These functions use the same 'format' strings as the 
// java.text.SimpleDateFormat class, with minor exceptions.
// The format string consists of the following abbreviations:
// 
// Field        | Full Form          | Short Form
// -------------+--------------------+-----------------------
// Year         | yyyy (4 digits)    | yy (2 digits), y (2 or 4 digits)
// Month        | MMM (name or abbr.)| MM (2 digits), M (1 or 2 digits)
//              | NNN (abbr.)        |
// Day of Month | dd (2 digits)      | d (1 or 2 digits)
// Day of Week  | EE (name)          | E (abbr)
// Hour (1-12)  | hh (2 digits)      | h (1 or 2 digits)
// Hour (0-23)  | HH (2 digits)      | H (1 or 2 digits)
// Hour (0-11)  | KK (2 digits)      | K (1 or 2 digits)
// Hour (1-24)  | kk (2 digits)      | k (1 or 2 digits)
// Minute       | mm (2 digits)      | m (1 or 2 digits)
// Second       | ss (2 digits)      | s (1 or 2 digits)
// AM/PM        | a                  |
//
// NOTE THE DIFFERENCE BETWEEN MM and mm! Month=MM, not mm!
// Examples:
//  "MMM d, y" matches: January 01, 2000
//                      Dec 1, 1900
//                      Nov 20, 00
//  "M/d/yy"   matches: 01/20/00
//                      9/2/00
//  "MMM dd, yyyy hh:mm:ssa" matches: "January 01, 2000 12:30:45AM"
// ------------------------------------------------------------------

function DateUtil() {}

DateUtil.MONTH_NAMES = new Array('January','February','March','April','May','June','July','August','September','October','November','December','Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec');
DateUtil.DAY_NAMES = new Array('Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday','Sun','Mon','Tue','Wed','Thu','Fri','Sat');

DateUtil.LZ = function(x) {return(x<0||x>9?"":"0")+x}

// ------------------------------------------------------------------
// isDate ( date_string, format_string )
// Returns true if date string matches format of format string and
// is a valid date. Else returns false.
// It is recommended that you trim whitespace around the value before
// passing it to this function, as whitespace is NOT ignored!
// ------------------------------------------------------------------
DateUtil.isDate = function(val,format) {
    var date=DateUtil.getDateFromFormat(val,format);
    if (date==0) { return false; }
    return true;
    }

// -------------------------------------------------------------------
// compareDates(date1,date1format,date2,date2format)
//   Compare two date strings to see which is greater.
//   Returns:
//   1 if date1 is greater than date2
//   0 if date2 is greater than date1 of if they are the same
//  -1 if either of the dates is in an invalid format
// -------------------------------------------------------------------
DateUtil.compareDates = function(date1,dateformat1,date2,dateformat2) {
    var d1=DateUtil.getDateFromFormat(date1,dateformat1);
    var d2=DateUtil.getDateFromFormat(date2,dateformat2);
    if (d1==0 || d2==0) {
        return -1;
        }
    else if (d1 > d2) {
        return 1;
        }
    return 0;
    }

// ------------------------------------------------------------------
// formatDate (date_object, format)
// Returns a date in the output format specified.
// The format string uses the same abbreviations as in getDateFromFormat()
// ------------------------------------------------------------------
DateUtil.formatDate = function(date,format) {
    format=format+"";
    var result="";
    var i_format=0;
    var c="";
    var token="";
    var y=date.getYear()+"";
    var M=date.getMonth()+1;
    var d=date.getDate();
    var E=date.getDay();
    var H=date.getHours();
    var m=date.getMinutes();
    var s=date.getSeconds();
    var yyyy,yy,MMM,MM,dd,hh,h,mm,ss,ampm,HH,H,KK,K,kk,k;
    // Convert real date parts into formatted versions
    var value=new Object();
    if (y.length < 4) {y=""+(y-0+1900);}
    value["y"]=""+y;
    value["yyyy"]=y;
    value["yy"]=y.substring(2,4);
    value["M"]=M;
    value["MM"]=DateUtil.LZ(M);
    value["MMM"]=DateUtil.MONTH_NAMES[M-1];
    value["NNN"]=DateUtil.MONTH_NAMES[M+11];
    value["d"]=d;
    value["dd"]=DateUtil.LZ(d);
    value["E"]=DateUtil.DAY_NAMES[E+7];
    value["EE"]=DateUtil.DAY_NAMES[E];
    value["H"]=H;
    value["HH"]=DateUtil.LZ(H);
    if (H==0){value["h"]=12;}
    else if (H>12){value["h"]=H-12;}
    else {value["h"]=H;}
    value["hh"]=DateUtil.LZ(value["h"]);
    if (H>11){value["K"]=H-12;} else {value["K"]=H;}
    value["k"]=H+1;
    value["KK"]=DateUtil.LZ(value["K"]);
    value["kk"]=DateUtil.LZ(value["k"]);
    if (H > 11) { 
        value["a"] = DateUtil.getPMSymbol();
    } else {
        value["a"] = DateUtil.getAMSymbol();
    }
    value["m"]=m;
    value["mm"]=DateUtil.LZ(m);
    value["s"]=s;
    value["ss"]=DateUtil.LZ(s);
    while (i_format < format.length) {
        c=format.charAt(i_format);
        token="";
        while ((format.charAt(i_format)==c) && (i_format < format.length)) {
            token += format.charAt(i_format++);
            }
        if (value[token] != null) { result=result + value[token]; }
        else { result=result + token; }
        }
    return result;
    }
    
// ------------------------------------------------------------------
// Utility functions for parsing in getDateFromFormat()
// ------------------------------------------------------------------
DateUtil._isInteger = function(val) {
    var digits="1234567890";
    for (var i=0; i < val.length; i++) {
        if (digits.indexOf(val.charAt(i))==-1) { return false; }
        }
    return true;
    }
DateUtil._getInt = function(str,i,minlength,maxlength) {
    for (var x=maxlength; x>=minlength; x--) {
        var token=str.substring(i,i+x);
        if (token.length < minlength) { return null; }
        if (DateUtil._isInteger(token)) { return token; }
        }
    return null;
    }
    
// ------------------------------------------------------------------
// getDateFromFormat( date_string , format_string )
//
// This function takes a date string and a format string. It matches
// If the date string matches the format string, it returns the 
// getTime() of the date. If it does not match, it returns 0.
// ------------------------------------------------------------------
DateUtil.getDateFromFormat = function(val,format) {
    val=val+"";
    format=format+"";
    var i_val=0;
    var i_format=0;
    var c="";
    var token="";
    var token2="";
    var x,y;
    var now=new Date();
    var year=now.getYear();
    var month=now.getMonth()+1;
    var date=1;
    var hh=now.getHours();
    var mm=now.getMinutes();
    var ss=now.getSeconds();
    var ampm="";
    
    while (i_format < format.length) {
        // Get next token from format string
        c=format.charAt(i_format);
        token="";
        while ((format.charAt(i_format)==c) && (i_format < format.length)) {
            token += format.charAt(i_format++);
            }
        // Extract contents of value based on format token
        if (token=="yyyy" || token=="yy" || token=="y") {
            if (token=="yyyy") { x=2;y=4; } // x=2,y=4 to be consistent with java.
            if (token=="yy")   { x=2;y=2; }
            if (token=="y")    { x=2;y=4; }
            year=DateUtil._getInt(val,i_val,x,y);
            if (year==null) { return 0; }
            i_val += year.length;
            if (year.length==2) {
                if (year > 70) { year=1900+(year-0); }
                else { year=2000+(year-0); }
                }
            }
        else if (token=="MMM"||token=="NNN"){
            month=0;
            for (var i=0; i<DateUtil.MONTH_NAMES.length; i++) {
                var month_name=DateUtil.MONTH_NAMES[i];
                if (val.substring(i_val,i_val+month_name.length).toLowerCase()==month_name.toLowerCase()) {
                    if (token=="MMM"||(token=="NNN"&&i>11)) {
                        month=i+1;
                        if (month>12) { month -= 12; }
                        i_val += month_name.length;
                        break;
                        }
                    }
                }
            if ((month < 1)||(month>12)){return 0;}
            }
        else if (token=="EE"||token=="E"){
            for (var i=0; i<DateUtil.DAY_NAMES.length; i++) {
                var day_name=DateUtil.DAY_NAMES[i];
                if (val.substring(i_val,i_val+day_name.length).toLowerCase()==day_name.toLowerCase()) {
                    i_val += day_name.length;
                    break;
                    }
                }
            }
        else if (token=="MM"||token=="M") {
            month=DateUtil._getInt(val,i_val,1,2); // Always use min len 1 to be lenient.
            if(month==null||(month<1)||(month>12)){return 0;}
            i_val+=month.length;}
        else if (token=="dd"||token=="d") {
            date=DateUtil._getInt(val,i_val,1,2); // Always use min len 1 to be lenient.
            if(date==null||(date<1)||(date>31)){return 0;}
            i_val+=date.length;}
        else if (token=="hh"||token=="h") {
            hh=DateUtil._getInt(val,i_val,token.length,2);
            if(hh==null||(hh<1)||(hh>12)){return 0;}
            i_val+=hh.length;}
        else if (token=="HH"||token=="H") {
            hh=DateUtil._getInt(val,i_val,token.length,2);
            if(hh==null||(hh<0)||(hh>23)){return 0;}
            i_val+=hh.length;}
        else if (token=="KK"||token=="K") {
            hh=DateUtil._getInt(val,i_val,token.length,2);
            if(hh==null||(hh<0)||(hh>11)){return 0;}
            i_val+=hh.length;}
        else if (token=="kk"||token=="k") {
            hh=DateUtil._getInt(val,i_val,token.length,2);
            if(hh==null||(hh<1)||(hh>24)){return 0;}
            i_val+=hh.length;hh--;}
        else if (token=="mm"||token=="m") {
            mm=DateUtil._getInt(val,i_val,token.length,2);
            if(mm==null||(mm<0)||(mm>59)){return 0;}
            i_val+=mm.length;}
        else if (token=="ss"||token=="s") {
            ss=DateUtil._getInt(val,i_val,token.length,2);
            if(ss==null||(ss<0)||(ss>59)){return 0;}
            i_val+=ss.length;}
        else if (token=="a") {
            var am = DateUtil.getAMSymbol();
            var pm = DateUtil.getPMSymbol();
            var stra = val.substring(i_val, i_val + am.length);
            var strp = val.substring(i_val, i_val + pm.length);
            if (stra == am || stra.toUpperCase() == am) {
                ampm = am;
            } else if (strp == pm || strp.toUpperCase() == pm) {
                ampm = pm;
            } else {
                return 0;
            }
                i_val += ampm.length;
        }
        else {
            if (val.substring(i_val,i_val+token.length)!=token) {return 0;}
            else {i_val+=token.length;}
            }
        }
    // If there are any trailing characters left in the value, it doesn't match
    if (i_val != val.length) { return 0; }
    // Is date valid for month?
    if (month==2) {
        // Check for leap year
        if ( ( (year%4==0)&&(year%100 != 0) ) || (year%400==0) ) { // leap year
            if (date > 29){ return 0; }
            }
        else { if (date > 28) { return 0; } }
        }
    if ((month==4)||(month==6)||(month==9)||(month==11)) {
        if (date > 30) { return 0; }
        }
    // Correct hours value
    if (hh<12 && ampm == DateUtil.getPMSymbol()) { hh=hh-0+12; }
    else if (hh>11 && ampm == DateUtil.getAMSymbol()) { hh-=12; }
    var newdate=new Date(year,month-1,date,hh,mm,ss);
    return newdate.getTime();
    }

// ------------------------------------------------------------------
// parseDate( date_string [, prefer_euro_format] )
//
// This function takes a date string and tries to match it to a
// number of possible date formats to get the value. It will try to
// match against the following international formats, in this order:
// y-M-d   MMM d, y   MMM d,y   y-MMM-d   d-MMM-y  MMM d
// M/d/y   M-d-y      M.d.y     MMM-d     M/d      M-d
// d/M/y   d-M-y      d.M.y     d-MMM     d/M      d-M
// A second argument may be passed to instruct the method to search
// for formats like d/M/y (european format) before M/d/y (American).
// Returns a Date object or null if no patterns match.
// ------------------------------------------------------------------
DateUtil.parseDate = function(val) {
    var preferEuro=(arguments.length==2)?arguments[1]:false;
    generalFormats=new Array('y-M-d','MMM d, y','MMM d,y','y-MMM-d','d-MMM-y','MMM d');
    monthFirst=new Array('M/d/y','M-d-y','M.d.y','MMM-d','M/d','M-d','M.d');
    dateFirst =new Array('d/M/y','d-M-y','d.M.y','d-MMM','d/M','d-M','d.M');
    var checkList=new Array('generalFormats',preferEuro?'dateFirst':'monthFirst',preferEuro?'monthFirst':'dateFirst');
    var d=null;
    for (var i=0; i<checkList.length; i++) {
        var l=window[checkList[i]];
        for (var j=0; j<l.length; j++) {
            d=DateUtil.getDateFromFormat(val,l[j]);
            if (d!=0) { return new Date(d); }
            }
        }
    return null;
}

DateUtil.TIMEZONES;

DateUtil.getTimezoneOffset = function(){

    var browserDate = new Date();
    var browserOffsetFromGMT = browserDate.getTimezoneOffset() * (60 * 1000);

    var index = DateUtil.getTimezoneIndex(browserDate);
    if (DateUtil.TIMEZONES == undefined){
        DateUtil.TIMEZONES = DateUtil.getTimezones(browserDate);
    }
    var sfdcOffsetFromGMT = DateUtil.TIMEZONES[index];

    // alert(browserOffsetFromGMT + " " + sfdcOffsetFromGMT + " " + index + " " + browserDate + "\n\n");
    // listProperties(timezones);
    
    var offset = sfdcOffsetFromGMT + browserOffsetFromGMT;
    
    return offset;

}

// Returns true if browser timezone matches system timezone
DateUtil.isBrowserAndSystemTimezoneSame = function(){
    var offset = DateUtil.getTimezoneOffset();
    return offset == 0;
}

DateUtil.getTimezoneIndex = function(date){
    return DateUtil.formatDate(date, "yyyyMMdd");
}

DateUtil.getTimezones = function(date){

    var qs = new QueryString("");
    qs.add("ts", date.getTime());
    var url = "/home/timezones.jsp" + qs.toString();
    
    var tz = null;
    
    var text = DesktopAjax.prototype.doGet(url);
    if (text){
        text = trim(text);
        var local = eval('(' + text + ')');
        return local;
        if (local){
            tz = local;
        }
    } 
    
    return tz;
}

DateUtil.rollDate = function(day, numDays){
    var newDate = new Date(day.getTime());
    newDate.setDate(newDate.getDate() + numDays);
    return newDate;
}

DateUtil.roundDate = function(date){
    var newDate = new Date(date.getTime());
    newDate.setHours(0);
    newDate.setMinutes(0);
    newDate.setSeconds(0);
    return newDate;
}

/*
 * Rest of file added by SFDC.
 */

/**
 * parse a date into a string using the user locale date format
 */
DateUtil.getDateStringFromUserLocale = function(date) {
    return DateUtil.formatDate(date, UserContext.dateFormat);
}

/**
 * parse a string using the user locale date format into a javascript Date object
 */
DateUtil.getDateFromUserLocale = function(str) {
    return new Date(DateUtil.getDateFromFormat(str, UserContext.dateFormat));
}

/**
 * parse a date into a string that includes time using the user locale date time format
 */
DateUtil.getDateTimeStringFromUserLocale = function(date) {
    return DateUtil.formatDate(date, UserContext.dateTimeFormat);
}

/**
 * parse a string with time using the user locale date time format into a javascript Date object
 */
DateUtil.getDateTimeFromUserLocale = function(str) {
    return new Date(DateUtil.getDateFromFormat(str, UserContext.dateTimeFormat));
}

DateUtil.getAMSymbol = function() {
    if (UserContext.initialized) {
        return UserContext.ampm[0];
    } else {
        return "AM";
    }
}

DateUtil.getPMSymbol = function() {
    if (UserContext.initialized) {
        return UserContext.ampm[1];
    } else {
        return "PM";
    }
}

/**
 * Java style date comparisons. Compares by day, month, and year only.
 */
DateUtil.equals = function(date1, date2) {
    return date1 && date2 && DateUtil.compare(date1, date2) == 0;
}

DateUtil.lessThan = function(date1, date2) {
    return DateUtil.compare(date1, date2) < 0;
}

DateUtil.greaterThan = function(date1, date2) {
    return DateUtil.compare(date1, date2) > 0;
}

DateUtil.compare = function(date1, date2) {
    if (date1.getFullYear() != date2.getFullYear()) {
        return date1.getFullYear() - date2.getFullYear();
    } else {
        if (date1.getMonth() != date2.getMonth()) {
            return date1.getMonth() - date2.getMonth();
        } else {
            return date1.getDate() - date2.getDate();
        }
    }
}

// possible date separators, should just match the user's format separator
DateUtil.separators = ['/', '-', '.'];
/**
 * Checks if a year was input (if not, inserts current year) and allows for
 * 2-digit year inputs. Then calls evaluateShortcut() to evaluate date picker
 * shortcuts like "today". Currently only for en_US users.
 */
DateUtil.checkYear = function(field, callOnChange) {
    var val = field.value.toLowerCase();
    if (val && val.length > 0) {
        var date = DateUtil.getDateTimeFromUserLocale(UserContext.today);
    }
    // figure out what separator they're using
    var separator = null;
    for (var i = 0; i < DateUtil.separators.length; i++) {
        if (val.indexOf(DateUtil.separators[i]) != -1) {
            separator = DateUtil.separators[i];
            break;
        }
    }
    var setField = false;
    
    if (separator) {
        // set the date to the 1st to avoid month wrapping
        date.setDate(1);
        var nums = val.split(separator);
        // see if they left off the year (only in locales where year is last)
        if (nums.length == 2) {
            // set month and date (year was already set to today's year)
            if (!isNaN(nums[0]) && !isNaN(parseInt(nums[1], 10))) {
                date.setMonth(parseInt(nums[0], 10) - 1);
                date.setDate(parseInt(nums[1], 10));
                setField = true;
            }
        } else if (nums.length == 3) {
            // fix the year if necessary
            if (!isNaN(parseInt(nums[2], 10)) && !isNaN(nums[0]) && !isNaN(nums[1])) {
                var year = parseInt(nums[2], 10);
                //allow 2 digit year, but still check the separator
                if (year / 1000 < 1) {
                    date.setMonth(parseInt(nums[0], 10) - 1);
                    date.setDate(parseInt(nums[1], 10));
                    // anything under 60 is in 2000, [60-99] is 1900
                    if (year >= 60 && year < 100) {
                        date.setFullYear(year + 1900);
                    } else {
                        date.setFullYear(year + 2000);
                    }
                    setField = true;
                } else if (separator != '/') {
                    field.value = nums[0] + "/" + nums[1] + "/" + nums[2];
                    if (callOnChange && field.onchange) {
                        field.onchange();
                    }
                    return;
                }
            }
        }
    } else {
        DateUtil.evaluateShortcut(field, callOnChange);
    }

    if (setField) {
          field.value = DateUtil.getDateStringFromUserLocale(date);
        if (callOnChange && field.onchange) {
            field.onchange();
        }
    }
}

// need to localize later
DateUtil.DAY_SHORTCUTS = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'];

/**
 * Attempts to take a shortcut and turn it into a valid date, i.e. if the user
 * enters "today", this will replace it with today's date. Currently only for
 * English language users (because the shortcuts are in English).
 */
DateUtil.evaluateShortcut = function(field, callOnChange) {
     var setField = false;
    var val = field.value.toLowerCase();
    if (val && val.length > 0) {
        var date = DateUtil.getDateTimeFromUserLocale(UserContext.today);
    }

    if (val.indexOf("tod") == 0) {
        setField = true;
    } else if (val.indexOf("yes") == 0) {
        date.setDate(date.getDate() - 1);
        setField = true;
    } else if (val.indexOf("tom") == 0) {
        date.setDate(date.getDate() + 1);
        setField = true;
    } else if (val.length >= 3) {
        for (var i = 0; i < DateUtil.DAY_SHORTCUTS.length; i++) {
            if (val.indexOf(DateUtil.DAY_SHORTCUTS[i].toLowerCase()) == 0) {
                var dif = i - date.getDay();
                if (dif < 0) {
                    dif += 7;
                }
                date.setDate(date.getDate() + dif);
                setField = true;
                break;
            }
        }
    }
    if (setField) {
        field.value = DateUtil.getDateStringFromUserLocale(date);
        if (callOnChange && field.onchange) {
            field.onchange();
        }
    }
}

DateUtil.differenceInMinutes = function (date1, date2) {
    var diffInMillis = date2.getTime() - date1.getTime();
    return Math.round(diffInMillis / (60 * 1000))
}

DateUtil.getDateFromValue = function (fieldValue, hasTime) {
    var time = hasTime ? DateUtil.getDateFromFormat(fieldValue, UserContext.dateTimeFormat) :
                         DateUtil.getDateFromFormat(fieldValue, UserContext.dateFormat);
    if (time != 0) {
        return new Date(time);
    }
    return null;
}
/**
 * set of static methods to manipulate cookies
 */
var Cookies = function(){}

Cookies.prototype.getCookieVal = function(offset) {
    var endstr = document.cookie.indexOf (";", offset);
    if (endstr == -1)
        endstr = document.cookie.length;
    return unescape(document.cookie.substring(offset, endstr));
}

Cookies.prototype.GetCookie = function(name) {  

    var arg = name + "=";  
    var alen = arg.length;  
    var clen = document.cookie.length;  
    var i = 0;  

    while (i < clen) {    
        var j = i + alen;    
        if (document.cookie.substring(i, j) == arg)      
            return Cookies.prototype.getCookieVal (j);    
        i = document.cookie.indexOf(" ", i) + 1;    
        if (i == 0) break;   
    }  
    return null;
}

Cookies.prototype.SetCookie = function(name, value, expires, path, domain, secure) {  
    document.cookie = name + "=" + value + 
        ((expires == null) ? "" : ("; expires=" + expires.toGMTString())) + 
        ((path == null) ? "" : ("; path=" + path)) +  
        ((domain == null) ? "" : ("; domain=" + domain)) +    
        ((secure == true) ? "; secure" : "");
}

Cookies.prototype.DeleteCookie = function(name) {  

    var cval = Cookies.prototype.GetCookie(name);
    if (cval == null) {
        return;
    }

    var exp = new Date(); 
    exp.setTime(exp.getTime() - 1);

    Cookies.prototype.SetCookie(name, "", exp, "/");
}

/**
* One per related list
* @author mpolcari
* @since 142.ml
*/

function RelatedList(id, visibleRowCount, title, hasMore, refURL, refQS, onlySkipLink) {
  this.listId = id;
  if (visibleRowCount) {
    this.visibleRowCount = visibleRowCount;
  }
  if (title) {
    this.title = title;
  }
  if (typeof hasMore != "undefined") {
    this.listHasMore = hasMore;
  }

  if (refURL) {
    this.refreshURL = refURL;
  }

  if (refQS) {
    this.refreshQS = refQS;
  }
  
  if(onlySkipLink){
  	this.isOnlySkipLink =onlySkipLink;
  }
}

RelatedList.prototype.getRelatedListNode = function() {
  return document.getElementById(this.listId);
}

RelatedList.prototype.getLinkTarget = function () {
  return this.listId + '_target';
}

RelatedList.prototype.getTitle = function () {
  if (!this.title) {
    var titleNode = DomUtil.findDescendantWithTag(this.getRelatedListNode(), "H3");
    if ((titleNode) && (titleNode.innerHTML)) {
      this.title =  titleNode.innerHTML;
    } else {
      this.title =  "";
    }
  }
  return this.title;
}

RelatedList.prototype.hasMore = function() {
  if (this.listHasMore == null) {
      this.listHasMore = DomUtil.findDescendantWithClassName(this.getRelatedListNode(), 'pShowMore');
      if (!this.listHasMore) this.listHasMore = false;
  }
  return this.listHasMore;
}

RelatedList.prototype.getNumberVisibleRows = function() {
  if (!this.visibleRowCount) {
    var rowCount = 0;
    DomUtil.walkDomTreeApplyingFunction(this.getRelatedListNode(),
      function(node) {
        if (node.className && node.className.indexOf && (node.className.indexOf("dataRow") >= 0) ) {
          rowCount ++;
        }
        return null;
      });
    this.visibleRowCount = rowCount;
  }
  return this.visibleRowCount;
}

RelatedList.prototype.refresh = function(extraParamNames, extraParamValues) {
  if (this.refreshURL && this.refreshQS) {
    qs = this.refreshQS;
    for (var i=0; extraParamNames && i<extraParamNames.length; i++) {
      if (qs.length != 0) {
         qs = qs + '&';
      }
      qs = qs + extraParamNames[i] + '=' + extraParamValues[i];
    }
    this.callRelatedListAction(null, this.refreshURL, qs);
  }
}

//TODO: 144
RelatedList.prototype.getSelectedRecordIds = function() {
  var selectedRecordIds = [];
  return selectedRecordIds;
}

//TODO: 144
RelatedList.prototype.getVisibleRecordIds = function() {
  var visibleRecordsIds = [];
  return visibleRecordsIds;
}


/** async + dhtml controls for related lists **/
RelatedList.prototype.showMoreList = function(listUrl, listQS) {
    this.callRelatedListAction(null, listUrl, listQS);
}

/*
 * oldDomId: DOM ID of the related list on the current document 
 * newDomId: DOM ID of the related list on the newly requested document 
 */
RelatedList.prototype.callRelatedListAction = function(actionUrl, listUrl, listQS, oldDomId, newDomId, resizeSidebar, onSuccessCallback) {
    var relatedList = this;
    function processNewList(newDoc) {
        if (!newDoc) {
            return;
        }
        
        // if returned page is error page - load that page directly that allows to redirect to login page
        if(window.sfdcPage && window.sfdcPage.hasNoRelatedList && window.sfdcPage.hasNoRelatedList(newDoc, relatedList.listId)){
        	// remove empty page header param
        	listUrl = removeParam(listUrl, DynamicContent.pCOOKIE_PARAM);
        	window.location = listUrl;
        }
        
        // ignore request that was canceled by user
        if(window.sfdcPage && window.sfdcPage.checkActionCanceled && window.sfdcPage.checkActionCanceled(newDoc,relatedList.listId)){
        	return;
        }
                
        var oldListId = oldDomId;
        var newListId = newDomId;
        if (!oldListId) oldListId = relatedList.listId;
        if (!newListId) newListId = relatedList.listId;

        var oldList = getElementByIdCSWithDoc(document, oldListId);
        var newList = getElementByIdCSWithDoc(newDoc, newListId);
        var panel = sfdcPage.relatedListPanel;

        if (!oldList || !newList) {
            return;
        }
        
        // this is more efficient but can cause js related ui to appear before evalScripts proccesses it
        if(XBrowser.userAgent.isIE || XBrowser.userAgent.isSafari || XBrowser.userAgent.isOpera){
       		// swap in new related list
        	oldList.innerHTML = newList.innerHTML;
        	// need to evaluate scripts on the page
	        if(window.sfdcPage && window.sfdcPage.evalScripts){
	        	window.sfdcPage.evalScripts(oldList);
	        }
	        
        } else {
        		var tempRL = document.createElement(oldList.tagName);
        		tempRL.style.display = 'none';
        		var b = document.getElementsByTagName('body')[0];
        		b.appendChild(tempRL);
	        	// remove old list	
				oldList.innerHTML = '';
				// insert new list after existing list has been removed to avoid duplicate ids
				tempRL.innerHTML = newList.innerHTML;
				if(window.sfdcPage && window.sfdcPage.evalScripts){
	        		window.sfdcPage.evalScripts(tempRL);
	        	}
	        	// add new list children to old list
        		while (tempRL.firstChild) {
					oldList.appendChild(tempRL.removeChild(tempRL.firstChild));
				}
				// remove temp rl
				b.removeChild(tempRL);
        }
        
        if(window.sfdcPage && window.sfdcPage.hook_postRelatedListActionUpdate){
        	window.sfdcPage.hook_postRelatedListActionUpdate(listUrl);
        }
        
        
        // if the DOM ID of the related list from the new document is different 
        // than the DOM ID on the current document, swap in the new ID
        if (oldList.id != newListId){
            oldList.id = newListId;   
        }

        //invalidate the js object - this means that .getRows will count the rows
        relatedList.visibleRowCount = null;
        relatedList.listHasMore = null;

        // update link
        if (panel) {
          var buf = [];
          var panelList = panel.getIFrameNode().contentWindow.document.getElementById(relatedList.listId);
          var linkletNode = document.getElementById(panel.getLinkId(relatedList.listId));
          if (panelList && panelList.innerHTML) {
            panelList.innerHTML = newList.innerHTML;
            panel.fixContent(panelList);
            if (linkletNode && linkletNode.className && (linkletNode.className.indexOf('linkletOn') > -1)) {
             panel.showRL(relatedList.listId, true);
            }
          }
          if(linkletNode){
	          buf.push('<span class="listTitle">');
	          buf.push(relatedList.getTitle());
	          buf.push(panel.getCountIndicator(relatedList));
	          buf.push('</span>');
	          linkletNode.innerHTML = buf.join('');
          }
        }
        if(resizeSidebar){
        	if(Sidebar.prototype.theSidebar) {
        		Sidebar.prototype.theSidebar.sizeToBody();
        		Sidebar.prototype.theSidebar.sizeBodyToSidebarNoCheck();
        	}
        }
        
        if(onSuccessCallback){
        	onSuccessCallback();
        }
        
    }
    makeActionRequest(actionUrl, listUrl, listQS, processNewList);
}


/*
 * Copyright, 1999-2006, SALESFORCE.com
 * All Rights Reserved
 * Company Confidential
 *
 * MobileConfig Object Javascript.
 * REQUIRES: DOJO-0.4.1.
 * @author dkothule
 * @since 148
 */

/*
    MobileConfig{
        id: null,
        querySets:[
            {	id: null,
                tableOrEnumId: null,
                parentId: null,
                recordLimit: 0,
                itemCount: 0,
				testResult: null,
				isTestResultCurrent: true,
				scope: null,
                items:[
                    {
                        id: null,
                        columnName: null,
                        operation: null,
                        value: null
                    }
                ],
                querySets:[
                ]
            }
        ]
    }

    ##ObjectDefinition is basic information about the object type that can be added in tree
    ObjectDefinition{
        "isTopLevel": true,
        "isCustom" : true,
        "type": "Product2",
        "label": "Product",
        "plural": "Products",
        "children": [
            "Task",
            "Event",
            "Activity"
        ]
    }
    ##MCXHRPost is information about xhr request - passed as a reference.
    MCXHRPost{
        isSync:false, //indicates request should be asynchronous or not
        isSuccess:true, //boolean flag indicating success or failure
        xhrInfo:[], //array of xhr params
        savingNode, //TreeNode object
        loadingNode, //TreeNode object
        callback //callback function that takes XHRPostRef object argument.
    }
*/

var MobileConfig = {
        baseObjectList: null, /*ObjectDefinition List*/
        id: null,

        dlgAdd: null,
        dlgWait: null,
        syncTree: null,
        syncTreeRoot: null,
        syncTreeController: null,
        syncTreeSelector: null,
        currentNode: null,
        formActionURL: null, /*original Form URL.*/
        filterPaneBody: null,
        lastFormAction: null, /*last action e.g. button click*/
        collisionParam: null,
        testResultsDisplayed: false,
        /**
         * Initializes MobileConfig object
         * @return void
         */
        init: function(){
            this.formActionURL = document.getElementById(EditPageConstants.pEDIT_PAGE).action;
            this.syncTree = dojo.widget.byId("syncTree");
            if(this.syncTree != null && this.syncTree.children != null && this.syncTree.children.length > 0){
                this.syncTreeRoot = this.syncTree.children[0];
                if(this.syncTreeRoot != null){
                    this.syncTreeRoot.object = {isRoot: true};
                    this.syncTreeRoot.isExpanded = true;
                }
                dojo.event.topic.subscribe("nodeSelected", MobileConfig.onSelectNode);
            }
            this.syncTreeController = dojo.widget.byId('syncTreeController');
            this.syncTreeSelector = dojo.widget.byId('syncTreeSelector');

            this.baseObjectList = MACInfo.BaseObjectList;
            
            this.collisionParam = MACInfo.CollisionParameter;

            this.filterPaneBody = dojo.widget.byId('filterPaneBody');

            this.onLoad();
            this.onSelectNode();

        }, /*::init::*/

        /**
         * Creates and initializes Add Dialog Box.
         * @return void
         */
        createAddDialog: function(){
            if(this.dlgAdd == null){
                this.dlgAdd = new AddSyncSetDialog()        
                sfdcPage.registerDialog(this.dlgAdd);        
            }
        },

		/**
		* Displays "Wait" dialog
		*/
		showWaitDialog: function(){
           if(this.dlgWait == null){
                this.dlgWait = new SimpleDialog("dlgWait", false);
                this.dlgWait.width = 200;                
                sfdcPage.registerDialog(this.dlgWait);
                this.dlgWait.setContentInnerHTML(LC.getLabel("MobileConfig_Section_SyncSet", "WaitDlg_Text"));
            }		
            if (this.dlgWait != null){
	            this.dlgWait.show();
            }            
		},
		
		hideWaitDialog: function(){
			if (this.dlgWait != null){
				this.dlgWait.hide();
			}
		},
		
		createTestErrorTooltip: function (id, msg){
			dojo.widget.createWidget( "tooltip", {connectId: id, caption: msg} );
		},
		
        /**
         * Returns the ObjectDefinition from base object list.
         * @return ObjectDefinition
         */
        getObjectDefinitionByType: function(/*string*/objType){
            if(this.baseObjectList && this.baseObjectList.length > 0){
                for(var i=0; i < this.baseObjectList.length; i++){
                    if(this.baseObjectList[i].type == objType){
                        return this.baseObjectList[i];
                    }
                }
            }
            return null;
        },

        /**
         * Returns the ObjectDefinition for Top-Level objects.
         * @param parent - by default it should be tree root.
         * @return ObjectDefinition[]
         */
        getTopLevelObjects: function(/*TreeNode*/ parent){
            var list = new Array();
            if(this.baseObjectList && this.baseObjectList.length > 0){
                var obj;
                for(var i=0; i < this.baseObjectList.length; i++){
                    obj = this.baseObjectList[i];
                    if(obj.isTopLevel == true){
                    	if(MACInfo.AllowMultipleEntities && (!MACInfo.MaxMultipleEntities || !this.findObjectInSiblings(parent, this.baseObjectList[i].type, MACInfo.MaxMultipleEntities))){
                    		list[list.length] = this.baseObjectList[i];
                    	}else if(parent && !this.findObjectInSiblings(parent, this.baseObjectList[i].type)){
                        	list[list.length] = this.baseObjectList[i];
                        }
                    }
                }
            }
            return list;
        },

        /**
         * OnLoad Hook. Initializes MobileConfig. Called upon body-onload.
         * @return void
         */
        onLoad: function(){
            var syncSet = JSUtils.getTextValue("SyncSet");
            if(syncSet != null){
                //dojo.debug("SyncSet:\n" + syncSet);
                syncSet = eval("("+syncSet+")");
                if(syncSet){
                    this.id = syncSet.id;
                    var qs = syncSet.querySets;
                    if(qs && qs.length > 0){
                        for(var i=0; i < qs.length; i++){
                            this.loadQuerySets(this.syncTreeRoot, qs[i]);
                        }
                    }
                    this.querySets = syncSet.querySets;
                }
            }
        },

        /**
         * Called before leaving the page.
         */
        onUnload: function(){
        	//disabled temporarily
            if(this.lastFormAction == "onSave"){
                //user already clicked on DONE, no need to save it.
                return true;
            }
            var result = this.onSave();
            if(!result){
                var msg = LC.getLabel("MobileConfig_Section_SyncSet", "AutoSave_PageUnloadError", MobileConfig.currentNode.title);
                return alert(msg);
            }
            
        },

        /**
         * OnSave Hook. Called upon when the form is submitted by clicking on done button.
         * @return returns true if save is successful; otherwise false.
         */
        onSave: function(){        	
            this.updateTreeData();
            var currentNode = MobileConfig.currentNode;
            if(currentNode && !MobileConfig.isRootNode(currentNode)){
                this.lastFormAction = "onSave";
                var xhrPost = {
                    "isSync" : true,
                    "savingNode": currentNode
                };
                MobileConfig.xhrPostSave(xhrPost);
                return (xhrPost.isSuccess == true);
            }
            return true;
        },

        /**
         * Updates the form element with tree data.
         * @return void
         */
        updateTreeData: function(){
            var result = {id: this.id, querySets: this.readQuerySets(this.syncTreeRoot)};
            JSUtils.setTextValue("SyncSet", dojo.json.serialize(result));
        },

        /**
         * Set the form action URL.
         * @param boolean xhrMode - if true, then sets to XHR otherwise; reset to default.
         * @return returns the form element.
         */
        setFormAction: function(/*boolean*/ xhrMode){
            //make sure that form action URL is pointing to right location;
            var form = document.getElementById(EditPageConstants.pEDIT_PAGE);
            form.action = (xhrMode == true? MACInfo.XHRHandlerURL : MobileConfig.formActionURL);
            return form;
        },

        /**
         * Loads the QuerySet in the tree recursively starting with given parent.
         * @return void
         */
        loadQuerySets: function(/*TreeNode*/parent, /*QuerySet*/qs){
        	qs.testResult = null;
        	qs.isTestResultCurrent = false;
            var node = this.addTreeNode(parent, qs.tableOrEnumId, qs);
            if(qs.querySets != null && qs.querySets.length > 0){
                for(var i=0; i < qs.querySets.length; i++){
                    this.loadQuerySets(node, qs.querySets[i]);
                }
            }
        },

        /**
         * Reads the QuerySet from the tree recursively.
         * @return QuerySet[]
         */
        readQuerySets: function(/*TreeNode*/parent){
            if(parent != null && parent.children != null && parent.children.length > 0){
                var child, qs, qsChildren;
                var qsArr = new Array();
                for(var i=0; i < parent.children.length; i++){
                    child = parent.children[i];
                    qs = child.object;
                    qsChildren = this.readQuerySets(child);
                    qs.querySets = qsChildren;
                    qsArr[qsArr.length] = qs;
                }
                return qsArr;
            }else{
                return null;
            }
        },

        /**
         * Adds the tree node
         * @return TreeNode - newly added node.
         */
        addTreeNode: function(/*TreeNode*/parent, /*string*/tableOrEnumId, /*QuerySet*/querySet){
            if(parent == null){
                dojo.debug("Can not add "+ tableOrEnumId + ". Parent is NULL");
                return;
            }
            var objDef = MobileConfig.getObjectDefinitionByType(tableOrEnumId);
            if(objDef == null){
                dojo.debug("Unable to find the object by type: " + tableOrEnumId);
                return;
            }
            querySet = querySet == null? {tableOrEnumId: tableOrEnumId} : querySet;
            var nodeId = querySet.id == null ? null : "Node_" + querySet.id;

            var filterImage = (querySet.itemCount != null && querySet.itemCount != 0) ? MACInfo.FilterIcon : "" ;
            var node = dojo.widget.createWidget("TreeNode", {title: objDef.label, object: querySet, afterLabel: filterImage});            
            
            //this is important for manual dojo parsing / performance improvement.
            djConfig.searchIds.push(node.widgetId);

            dojo.debug("Adding :" + objDef.label + "/" + tableOrEnumId + " WidgetId: " + node.widgetId + ", ID: " + node.id);
            node.isExpanded = true;
            parent.addChild(node);
            if (nodeId){
				node.titleNode.id = nodeId;
				var scopeTip = objDef.label;
				//the following comments ensure that the labels are loaded
				//LC.getLabel("FilterScope", "0");
				//LC.getLabel("FilterScope", "1");
				//LC.getLabel("FilterScope", "2");
				//LC.getLabel("FilterScope", "T");
				//LC.getLabel("FilterScope", "S");
				//LC.getLabel("FilterScope", "A");
				//LC.getLabel("FilterScope", "None");
				if (querySet.scope){
					scopeTip = scopeTip + ": " + LC.getLabel("FilterScope", querySet.scope);
				}else{
					scopeTip = scopeTip + ": " + LC.getLabel("FilterScope", "None");
				}
	            node.tooltip = dojo.widget.createWidget( "tooltip", {connectId: nodeId, caption: scopeTip} );	            
	        }
            return node;
        },

        /**
         * Gets the TreeNode starting from given node that has given object.
         * @param TreeNode parent - the node to start searching from (below)
         * @param string tableOrEnumId - the object type to look for
         * @return TreeNode - node with tableOrEnumId if found, otherwise null.
         */
        getTreeNode: function(/*TreeNode*/parent, /*string*/tableOrEnumId){
            if(parent != null && parent.children != null && parent.children.length > 0){
                var node, querySet;
                for(var i=0; i < parent.children.length; i++){
                    node = parent.children[i];
                    querySet = node.object;
                    if(querySet.tableOrEnumId == tableOrEnumId){
                        return node;
                    }
                }
            }
            return null;
        },

        /**
         * Removes the selected tree node. Updates the tree node icons and filter pane.
         * @return void
         */
        removeTreeNode: function(){
            var selectedNode = this.getSelectedNode();
            if(selectedNode != null && selectedNode.object != null && !selectedNode.object.isRoot){
                var next;
                var p = selectedNode.parent;
                this.syncTreeController.removeNode(selectedNode);
                if(!(p && p.children && p.children.length > 0)){
                    p.isFolder = false;
                }
                next = (p == null? this.syncTreeRoot : p);
                MobileConfig.selectNode(next);
                next.updateExpandIcon();
                this.syncTree.updateIconTree();
                MobileConfig.currentNode = null;
                //update selection
                MobileConfig.onSelectNode();
            }
        },

        /**
         * Checks whether given node is root node or not.
         * @return true, if the node is root, false otherwise.
         */
        isRootNode: function(/*TreeNode*/ node){
            return (node != null && node.object != null && node.object.isRoot == true);
        },

        /**
         * Updates the filter pane title.
         * @return void
         */
        updateFilterPaneTitle: function(title, filterPaneColor){
            if(title){
                JSUtils.setInnerHTML("filterPaneTitle", title);
                if(filterPaneColor){
                    dojo.html.setStyle("filterPaneBody", "background-color", filterPaneColor);
                }
            }
        },
        
        /**
         * Check for 302 condition.
         * @return string data.
         */
        checkFor302: function(data){
			//check for 302 error
	       	if(data && data.indexOf(MACInfo.XHRHandler302URL) != -1){
				if (window.location.replace){
					window.location.replace(MACInfo.MobileConfig302URL);
				}else{
					window.location.href = MACInfo.MobileConfig302URL;
				}
				return "";        		
	       	}
	       	MobileConfig.setFormAction(false);
	       	return data;
        },
        
        /**
         * Sends the XHR Post request to server
         * @param xhrPost is reference object containing post information.
         * @return void
         */
        xhrPostSave: function(/*MCXHRPost*/xhrPost){
            if(!(xhrPost && xhrPost.savingNode && xhrPost.savingNode.object && xhrPost.savingNode.object.id)){
                return;
            }
            var savingNode= xhrPost.savingNode; //short hand ref for better performance.
            if(MobileConfig.isRootNode(savingNode)){
                return;
            }
            var savingObj = savingNode.object;

            //change title to saving...
            MobileConfig.updateFilterPaneTitle(LC.getLabel("MobileConfig_Section_SyncSet", "FilterPane_Title_Saving", savingNode.title));

            this.updateTreeData();

            //prepare XHRInfo
            var xhrInfo = {};
            xhrInfo[MCXHRParams.pAction] = "SAVE";
            xhrInfo[MCXHRParams.pSaveObjType] = savingObj.tableOrEnumId;
            xhrInfo[MCXHRParams.pSaveObjId] = savingObj.id;
            xhrInfo[MCXHRParams.pCollisionParam] = MobileConfig.collisionParam;

            //save info post for later reference.
            xhrPost.xhrInfo = xhrInfo;

            var xhr = {
                xhrPost: xhrPost, /*reference for future use*/
                formNode: MobileConfig.setFormAction(true), /*use setFormAction(true) to change action to XHRHandler*/
                content: xhrInfo,
                sync: (xhrPost.isSync == true? true : false),
                load: function(type, data, event) {
                    //type parameter always have value "load"
                    data = MobileConfig.checkFor302(data);
		        			        	
                    //we got the html data, update the div.      
                    var result = eval("("+data+")");              
                    if (result && result[MCXHRParams.pIsSuccess]){
                    	xhrPost.isSuccess = true;
                    	xhrPost.savingNode.object.itemCount = result[MCXHRParams.pFilterItemCount];
                    	xhrPost.savingNode.object.scope = result[MCXHRParams.pScope];
                    	MobileConfig.collisionParam = result[MCXHRParams.pCollisionParam];                    	
                    }else{                    
                    	var content = (result && result[MCXHRParams.pData] ? result[MCXHRParams.pData] : "");
                    	xhrPost.isSuccess = false;
		                MobileConfig.filterPaneBody.setContent(content);
		            }                    
		            MobileConfig.onXHRPostSave(this.xhrPost, type);
                },
                error: function(type, errorObj){
                    //type parameter always have value "error"
                    MobileConfig.showFilterPaneError(errorObj.message);
                    xhrPost.isSuccess = false;
                    MobileConfig.onXHRPostSave(this.xhrPost, type);
                },
				encoding: "utf8"
            };
            dojo.io.bind(xhr);
        },

        /**
         * Generall callback for handling post-load request.
         * @param xhrPost - reference to xhrPost object
         * @param type - type of handler - either "load" or "error"
         */
        onXHRPostSave: function(/*MCXHRPost*/xhrPost, /*string*/type){
            //reset the form action to default one.
            MobileConfig.setFormAction(false);
            if(type=="load") {
				MobileConfig.onInitFilterPane();
			}
			if (!MobileConfig.isRootNode(xhrPost.savingNode)){
				MobileConfig.updateChangedNode(xhrPost.savingNode);
				MobileConfig.updateTestTotalsStyle(false);
			}

           //reset the loading title.
             MobileConfig.updateFilterPaneTitle(xhrPost.savingNode.title);
             //finally invoke the callback
             if(xhrPost && xhrPost.callback){
                 xhrPost.callback(xhrPost);
             }             
        },

        /**
         * Loads the filter pane for given node.
         * @param xhrPost is reference object containing post information.
         * @return void
         */
        xhrPostLoad: function(/*MCXHRPost*/xhrPost){
            if(!(xhrPost && xhrPost.loadingNode && xhrPost.loadingNode.object)){
            	MobileConfig.enableActionButtons(true);            
                return;
            }
            var loadingNode= xhrPost.loadingNode;
            var loadingObj = loadingNode.object;
            if(loadingObj.isRoot == true){
                MobileConfig.updateFilterPaneTitle(LC.getLabel("MobileConfig_Section_SyncSet", "FilterPane_DefaultTitle"), "#CCCCCC");
                MobileConfig.filterPaneBody.setContent("");    
                MobileConfig.enableActionButtons(true);            
                return;
            }
            //change title to loading and body color to white.
            MobileConfig.updateFilterPaneTitle(LC.getLabel("MobileConfig_Section_SyncSet", "FilterPane_Title_Loading", loadingNode.title), "#FFFFFF");

            //prepare XHRInfo
            var xhrInfo = {};
            xhrInfo[MCXHRParams.pAction] = "LOAD";
            xhrInfo[MCXHRParams.pLoadObjType] = loadingObj.tableOrEnumId;
            xhrInfo[MCXHRParams.pLoadObjId] =  loadingObj.id == null? "" : loadingObj.id;
            xhrInfo[MCXHRParams.pCollisionParam] = MobileConfig.collisionParam;

            //save info post for later reference.
            xhrPost.xhrInfo = xhrInfo;

            var xhr = {
                xhrPost: xhrPost, /*reference for future use*/
                formNode: MobileConfig.setFormAction(true), /*use setFormAction(true) to change action to XHRHandler*/
                content: xhrInfo,
                sync: (xhrPost.isAsync == true? true : false),
                load: function(type, data, event) {
                    //type parameter always have value "load"
                    data = MobileConfig.checkFor302(data);
                    
                    var result = eval("("+data+")");              
                    if (result && result[MCXHRParams.pIsSuccess] && result[MCXHRParams.pData]){
                    	xhrPost.isSuccess = true;
                    	MobileConfig.filterPaneBody.setContent(result[MCXHRParams.pData]);
                    	MobileConfig.onXHRPostLoad(this.xhrPost, type);
                    	MobileConfig.collisionParam = result[MCXHRParams.pCollisionParam];
                    }else{                    
                    	var content = (result && result[MCXHRParams.pData] ? result[MCXHRParams.pData] : "");
                    	xhrPost.isSuccess = false;
		                MobileConfig.filterPaneBody.setContent(content);
		            }		                                
                },/*load-handler*/

                error: function(type, errorObj){
                    //type parameter always have value "error"
                    MobileConfig.showFilterPaneError(errorObj.message);
                    xhrPost.isSuccess = false;
                    MobileConfig.onXHRPostLoad(this.xhrPost, type);
                }, /*error-handler*/
				encoding: "utf8"
            };
            dojo.io.bind(xhr);
        },

        /**
         * Generall callback for handling post-load request.
         * @param xhrPost - reference to xhrPost object
         * @param type - type of handler - either "load" or "error"
         */
        onXHRPostLoad: function(/*MCXHRPost*/xhrPost, /*string*/type){
            //reset the form action to default one.
            MobileConfig.setFormAction(false);
			
			if(type == "load") {
				MobileConfig.onInitFilterPane();
			}
            //reset the loading title.
            MobileConfig.updateFilterPaneTitle(xhrPost.loadingNode.title);
            //finally invoke the callback
            if(xhrPost && xhrPost.callback){
            	xhrPost.callback(xhrPost);
            }
        },
		
		/**
		 * This function is called to initialize the filter pane.
		 */
		onInitFilterPane: function(){
			try{
				//initialize filter criteria
				onLoadCriteria();
			}catch(e){
			}
			//Initialize scopes:
			MobileConfig.onChangeScope();
		},

        /**
         * Show filter pane error message - error from XHR.
         * @param string message - Error Message
         * @return void
         */
        showFilterPaneError: function(/*string*/ message){
            dojo.debug("XHR Error: " + message);
            MobileConfig.filterPaneBody.setContent("<strong>" + LC.getLabel("MobileConfig_Section_Filter", "ExceptionTitle") + "</strong>"
                + "<br><br><div class='errorMsg'>" + message + "</div>");
        },

        /**
         * Gets the selected TreeNode
         * @return TreeNode - selected node; null if not selected.
         */
        getSelectedNode: function(){
            if(this.syncTree != null && this.syncTree.selector != null){
                return this.syncTree.selector.selectedNode;
            }
            return null;
        },

        /**
         * Selects the given node in the tree.
         * To enforce single-item selection, this will un-select existing node.
         * @param TreeNode node - Node to be selected.
         * @return void
         */
        selectNode: function(/*TreeNode*/node){
            if(node){
                //enforce single node selection
                var sel = MobileConfig.getSelectedNode();
                if(sel){
                    this.syncTree.selector.deselect(node);
                }
                this.syncTree.selector.doSelect(node);
            }
        },
        
		/**
		 * Callback - called when radio button scope is changed (clicked).
		 */
		onChangeScope: function(/*radio*/ scope){
			//check if the none scope is initialized or not
			var showFC = true;
		
			//check if scope is passed, otherwise go thru all available scopes.
			if(scope == null){
				//for initialization:
				var scopes = document.getElementsByName(MCFilterPaneParams.pSCOPE);
				if(scopes && scopes.length > 0){
					for(var i=0; i < scopes.length; i++){
						if(scopes[i].value == MCFilterPaneParams.NONE_SCOPE_VALUE){
							showFC = !scopes[i].checked;
							break;
						}
					}
				}
			}else if(scope.value == MCFilterPaneParams.NONE_SCOPE_VALUE){
				showFC = false;
			}
			
			if(showFC){
				JSUtils.showEx("filterCriteriaBox", "maxRecordLimitNumRow");
			}else{
				JSUtils.hideEx("filterCriteriaBox", "maxRecordLimitNumRow");
				//select no limit checkbox for max records.
				JSUtils.setCheckbox(MCFilterPaneParams.pMAX_RECORD_RADIO + MCFilterPaneParams.pNO_LIMIT, true);
			}
			MobileConfig.maxRecordButtonHandler();
		},
		
        /**
         * Callback - called when node is selected.
         * Do not use "this" reference in this function.
         * @return void.
         */
        onSelectNode: function(){        	
            var /*TreeNode*/currentNode = MobileConfig.currentNode;
            var /*TreeNode*/selectedNode = MobileConfig.getSelectedNode();

            //Update the MobileConfig.currentNode only in this method.
            var loadCallback = function(xhrPost){
                if(xhrPost.isSuccess){
                    MobileConfig.currentNode = MobileConfig.isRootNode(xhrPost.loadingNode)? null : xhrPost.loadingNode;
                }else{
                    // rollback the selection. unselect loadingNode and select savingNode.
                    MobileConfig.selectNode(xhrPost.savingNode);
                }
                MobileConfig.enableActionButtons(true);
            };/*loadCallback*/

            var saveCallback =  function(xhrPost){
                if(xhrPost.isSuccess){
                    MobileConfig.currentNode = MobileConfig.isRootNode(xhrPost.loadingNode)? null : xhrPost.loadingNode;
                    //we need this to avoid posting the of the saved node data
                    MobileConfig.filterPaneBody.setContent("");                    
                    xhrPost.callback = loadCallback;
                    MobileConfig.xhrPostLoad(xhrPost);
                }else{
                    // rollback the selection. unselect loadingNode and select savingNode
                    MobileConfig.selectNode(xhrPost.savingNode);
                    MobileConfig.enableActionButtons(true);
                }                
            };/*saveCallback*/


            var xhrPost = {
                "savingNode" : currentNode,
                "loadingNode" : selectedNode
            };  
            MobileConfig.enableActionButtons(false);          
            if(currentNode != null){
            	
                //save currentNode first and then load selectedNode
                xhrPost.callback = saveCallback;
                return MobileConfig.xhrPostSave(xhrPost);
            }else{
                //load selectedNode
                xhrPost.callback = loadCallback;
                MobileConfig.xhrPostLoad(xhrPost);
            }
        },

        /**
         * Displays Add Dialog
         * @return void
         */
        showAddDialog: function(){
            if(MobileConfig.dlgAdd != null){            
            	this.dlgAdd.createContent();
                MobileConfig.dlgAdd.show();
            }else{
                dojo.debug("dialog is null");
            }
        },

        /**
         * Hides add dialog
         * @return void
         */
        hideAddDialog: function(){
            if(MobileConfig.dlgAdd != null){
                MobileConfig.dlgAdd.hide();
            }
        },

        /**
         * Callback - called when OK button on add dialog is clicked.
         */
        onOkAddDialog: function(){
            var sel = dojo.byId("dlgAdd_selectObj");
            if(sel != null){
                var selIndex = sel.selectedIndex;
                if(selIndex != -1){
                    var opt = sel.options[selIndex];
                    if(opt != null && opt.value != null && opt.value.length > 0){
                        var currentNode = this.getSelectedNode();
                        var parentNode = currentNode == null? this.syncTreeRoot : currentNode;
                        // create new queryset in the db
                        this.xhrCreateQuerySet(parentNode, opt.value);
                        this.hideAddDialog();
                    }
                }
            }
        },

        /**
         * Makes a call to MobileConfigXHRHandler to create a new query set in the database.
         * Used when adding a new node to the data set tree.
         */
        xhrCreateQuerySet: function(/*TreeNode*/ parent, optValue){
            var /*QuerySet*/ parentObject = parent == null? null : parent.object;
            var parentId = (parentObject && parentObject.id ? parentObject.id : "");
            
            // create new queryset in the database
            // prepare XHRInfo
            var xhrInfo = {};
            xhrInfo[MCXHRParams.pAction] = "CREATE";
            xhrInfo[MCXHRParams.pSaveObjType] = optValue;
            xhrInfo[MCXHRParams.pSaveObjParentId] = (parentObject && parentObject.id ? parentObject.id : "");
            xhrInfo[MCXHRParams.pCollisionParam] = MobileConfig.collisionParam;

            // XHR call to add the tree node in the database
            var xhr = {
                formNode: MobileConfig.setFormAction(true),
                content: xhrInfo,
                load: function(load, data, e) {
                    //check for 302 error
                    data = MobileConfig.checkFor302(data);
                    var result = eval("("+data+")");              
                    if (result && result[MCXHRParams.pIsSuccess] && result[MCXHRParams.pSaveObjId]){
                        var newQuerySetId = result[MCXHRParams.pSaveObjId];      
                        var scope = result[MCXHRParams.pScope];                   
                        var /*QuerySet*/ newObject = {tableOrEnumId: optValue, id: newQuerySetId, scope: scope};
                        if (parentId != ""){
             				newObject.parentId = parentId;
			            }
                        var /*TreeNode*/ newNode = MobileConfig.addTreeNode(parent, optValue, newObject);
                        MobileConfig.collisionParam = result[MCXHRParams.pCollisionParam];
                        MobileConfig.selectNode(newNode);
                        MobileConfig.onSelectNode();
                        MobileConfig.updateTestTotalsStyle(false);
                    }                    
                    else {
                        // server-side error occured
                        MobileConfig.filterPaneBody.setContent(result[MCXHRParams.pData]);
                    }
                },
                error: function(t, e) {
                    MobileConfig.setFormAction(false);
                    MobileConfig.showFilterPaneError(e.message);
                },
				encoding: "utf8"
            };
            dojo.io.bind(xhr);
        },

        /**
         * Makes a call to MobileConfigXHRHandler to delete a query set from the database.
         * Used when removing a node from the data set tree.
         */
        xhrDeleteQuerySet: function(/*TreeNode*/ delNode){
            var /*QuerySet*/ delObject = delNode == null? null : delNode.object;

            if (delObject == null || delObject.isRoot){
                return;
            }

            // delete the queryset
            // prepare XHRInfo
            var xhrInfo = {};
            xhrInfo[MCXHRParams.pAction] = "DELETE";
            xhrInfo[MCXHRParams.pSaveObjId] = (delObject && delObject.id ? delObject.id : "");
            xhrInfo[MCXHRParams.pCollisionParam] = MobileConfig.collisionParam;

            // XHR call to delete the query set from the database
            var xhr = {
                formNode: MobileConfig.setFormAction(true),
                content: xhrInfo,
                load: function(load, data, e) {
                	data = MobileConfig.checkFor302(data);
                    var result = eval("("+data+")");              
                    if (result && result[MCXHRParams.pIsSuccess]){
                        MobileConfig.filterPaneBody.setContent("");
                        MobileConfig.collisionParam = result[MCXHRParams.pCollisionParam];
                        MobileConfig.removeTreeNode();         
                        MobileConfig.updateTestTotalsStyle(false);               
                    }
                    else {
                        // server-side error occured
                        MobileConfig.filterPaneBody.setContent(result[MCXHRParams.pData]);    
                        MobileConfig.updateTestTotalsStyle(false);
                    }
                },
                error: function(t, e) {
                    MobileConfig.setFormAction(false);
                    MobileConfig.showFilterPaneError(e.message);
                },
				encoding: "utf8"
            };
            dojo.io.bind(xhr);
        },

		getQuerySetTestResult: function(results, querySetId){
			if (results == null || !(results instanceof Array) || results.length == 0){
				return null;
			}
			for (var i=0; i < results.length; i++){
				if( results[i].id == querySetId){
					return results[i];
				}
			}
			return null;
		},

		/**
		*  Display test data size result for the tree nodes (query sets)
		*/
        setQuerySetsTestResult: function(/*TreeNode*/parent, results){
        	if (parent != null){
        		if ( !MobileConfig.isRootNode(parent)){
        			var querySet = parent.object;
					var qsTestResult = results ? this.getQuerySetTestResult(results, querySet.id) : null;
					querySet.testResult = qsTestResult;
					querySet.isTestResultCurrent = true;
					MobileConfig.refreshAfterNodeHTML(parent);
        		}
	        	if (parent.children != null){
	        		for (var i=0; i<parent.children.length; i++){
	        			this.setQuerySetsTestResult(parent.children[i], results);
	        		}
	        	}
	        }        	
        },
        
        
        /**
        * Update filter icon and test data size results on UI
        */
       refreshAfterNodeHTML: function(/*TreeNode*/ node){
        	if ( node != null && !MobileConfig.isRootNode(node) ){
	       		var querySet = node.object;
	       		var qsTestResult = querySet.testResult;
				var filterImage = (querySet.itemCount != null && querySet.itemCount != 0) ? MACInfo.FilterIcon : "&nbsp;" ;	
				var testResult = qsTestResult ? " (" + qsTestResult.recordCount + ", " + qsTestResult.dataSize + ") " : "";				        	
	        	var testResultStyle = querySet.isTestResultCurrent ? "testResultsCurrent" : "testResultsModified";	
	        	var warningIconId = null;
	        	if (qsTestResult && qsTestResult.configError && qsTestResult.configError.length > 0){
	        		warningIconId = 'img_warning_' + querySet.id;
	        		testResult = testResult + MACInfo.WarningIcon.replace('%ID%', warningIconId);
	        	}
	        	node.afterLabelNode.innerHTML = filterImage + testResult;
	        	dojo.html.setClass(node.afterLabelNode, testResultStyle);
	        	if (warningIconId){
	        		MobileConfig.createTestErrorTooltip(warningIconId, qsTestResult.configError);
	        	}				
        	}
        },
        
        /**
        * Update saved node filter icon and test results. Update children nodes
        * is test results were current before 
        */        
        updateChangedNode: function(/*TreeNode*/ node){
        	if ( node != null && !MobileConfig.isRootNode(node) ){
        		var querySet = node.object;
        		var wasTestResultCurrent = querySet.isTestResultCurrent;
        		querySet.isTestResultCurrent = false;
        		MobileConfig.refreshAfterNodeHTML(node);
        		if (wasTestResultCurrent && node.children && node.children.length > 0){
        			for (var i=0; i<node.children.length; i++){
        				MobileConfig.updateChangedNode(node.children[i]);
        			}
        		}
        		//update the tooltip
        		var scopeTip = node.title;
				if (querySet.scope){
					scopeTip = scopeTip + ": " + LC.getLabel("FilterScope", querySet.scope);
				}else{
					scopeTip = scopeTip + ": " + LC.getLabel("FilterScope", "None");
				}
        		if (node.tooltip){
        			node.tooltip.uninitialize();
        		}
        		node.tooltip = dojo.widget.createWidget( "tooltip", {connectId: node.titleNode.id, caption: scopeTip} );
        	}
        },                
        
        /**
        * Update the style of test totals element based on whether the results are current (valid) or not
        */
        updateTestTotalsStyle: function(valid){
        	if (MobileConfig.testResultsDisplayed){        	
	        	var testResultsDiv = document.getElementById("testTotals");
	        	if (testResultsDiv){
		        	var className = valid ? "testResultsCurrent" : "testResultsModified";
		        	testResultsDiv.className = className;
		        	var estimateButton = document.getElementsByName("EstimateDataSize");
		        	if (estimateButton && estimateButton.length == 1){
		        		var buttonTextEstimate = LC.getLabel("MobileConfig_Section_SyncSet", "TestDataSize");
						var buttonTextRefresh = LC.getLabel("MobileConfig_Section_SyncSet", "RefreshDataSize");	        		
		        		estimateButton[0].value = valid ? buttonTextEstimate : buttonTextRefresh;
		        	}
	        	}
	        }
        },
        
        /**
        *	Display test data size results
        */
        displayTestDataResults: function(results) {
        	var qsTestResults = null;
        	var totals = "";
        	if (results){
 				var qsTestResults = results[MCXHRParams.pQSTestResults];
 				var totals = results[MCXHRParams.pTotalsElement];
        	}
	        this.setQuerySetsTestResult(this.syncTreeRoot, qsTestResults);
	        if (results){
	        	JSUtils.setInnerHTML("testDataSizeDiv", totals);	        	
	        }else{
	        	JSUtils.setInnerHTML("testTotals", "");	        	
	        }
	        MobileConfig.updateTestTotalsStyle(true);
	        MobileConfig.testResultsDisplayed = (results != null);       	
        },        
        
        /**
         * Makes a call to MobileConfigXHRHandler to test user data size
         */
        xhrPostTestDataSize: function(){
            // prepare XHRInfo
            var xhrInfo = {};
            xhrInfo[MCXHRParams.pAction] = "TESTDATASIZE";
            xhrInfo[MCXHRParams.pSaveObjId] = "";
			
            // XHR call to test datasize
            var xhr = {
                formNode: MobileConfig.setFormAction(true),
                content: xhrInfo,
                load: function(load, data, e) {
                	data = MobileConfig.checkFor302(data);                	
					var result = eval("("+data+")");
					if (result && result[MCXHRParams.pIsSuccess]){						
						MobileConfig.displayTestDataResults(result);
					}else
					{
						JSUtils.setInnerHTML("testTotals", result[MCXHRParams.pData]);
						MobileConfig.updateTestTotalsStyle(true);
					}					
	                MobileConfig.hideWaitDialog();
                },
                error: function(t, e) {
                    MobileConfig.setFormAction(false);
                    MobileConfig.showFilterPaneError(e.message);
                    MobileConfig.hideWaitDialog();
                },
				encoding: "utf8"
            };
            MobileConfig.showWaitDialog();
            dojo.io.bind(xhr);
        },        

        onCancelAddDialog: function(){
            this.hideAddDialog();
        },

        onTreeMenuAdd: function(){
            MobileConfig.onAddSyncObj();
        },

        onTreeMenuRemove: function(){
            MobileConfig.onRemoveSyncObj();
        },

        onAddSyncObj: function(){
            this.populateObjectList(this.getSelectedNode());            
            this.showAddDialog();
        },

        onRemoveSyncObj: function(){
            this.xhrDeleteQuerySet(this.getSelectedNode());
        },
		
		onTestDataSize: function(){		
			
            var currentNode = MobileConfig.currentNode;

            var loadCallback = function(xhrPost){
                if(xhrPost.isSuccess){
                	//load the currect node
                	MobileConfig.clearTestResults();
                    MobileConfig.xhrPostTestDataSize(xhrPost);
                }else{
					//error????
                }            
            };

            var saveCallback =  function(xhrPost){
                if(xhrPost.isSuccess){
					xhrPost.callback = loadCallback;                	
                	//load the currect node
                	MobileConfig.xhrPostLoad(xhrPost);
                }else{
					//error????
                }
            };            

            var xhrPost = {
                "savingNode" : currentNode,
                "loadingNode" : currentNode
            };
                        
            if(currentNode != null){
                //save currentNode first and then load selectedNode
                xhrPost.callback = saveCallback;
                MobileConfig.xhrPostSave(xhrPost);
            }else{
                //load selectedNode
                xhrPost.callback = null;
                MobileConfig.clearTestResults();
                MobileConfig.xhrPostTestDataSize(xhrPost);
            }
		},
		
		findObjectInSiblings: function(/*TreeNode*/ parent, /*string*/ objectType, /*int*/ maxMultipleObjects ){
            if(objectType && parent && parent.children && parent.children.length > 0){
            	var /*TreeNode*/ sibling;
            	var counter = 0;
            	var max = maxMultipleObjects ? maxMultipleObjects : 1;
            	for(var i=0; i < parent.children.length; i++){
            		sibling = parent.children[i];
            		if(sibling && sibling.object && sibling.object.tableOrEnumId && sibling.object.tableOrEnumId == objectType){
            			counter++;
            			if (max == counter){
	            			return true;
	            		}
            		}
            	}
            }
            return false;
		},
		
        findObjectInParent: function(/*TreeNode*/ parent, /*string*/objectType, /*boolean*/ searchSiblings, /*int*/ maxMultipleObjects){
            //lookup object type in parent hierarchy.
            var parentObj = parent? parent.object : null;
            if(parent != null && parentObj != null && objectType != null){
                if(parentObj){
                	//check optional searchSiblings
                	if(searchSiblings && this.findObjectInSiblings(parent, objectType, maxMultipleObjects)){
                		return true;
                	}
                    if(parentObj.isRoot){
                        return false;
                    }
                    if(parentObj.tableOrEnumId == objectType){
                        return true;
                    }
                    return this.findObjectInParent(parent.parent, objectType);
                }
            }
            return false;
        },

        populateObjectList: function(/*TreeNode*/parent){
            var /*Array*/ objDefList, /*string*/ parentObjType;

            parent = parent == null? this.syncTreeRoot : parent;
            parentObjType = parent.object.isRoot == true? null : parent.object.tableOrEnumId;
            parentObjLabel = null;

            if(parentObjType == null){
                objDefList = this.getTopLevelObjects(parent);
            }else{
                objDefList = new Array();
                var objDef = this.getObjectDefinitionByType(parentObjType);
                parentObjLabel = objDef? objDef.label : "";
                if(objDef){
                	var children, childDef;
                	var isTopLevelParent = MobileConfig.isRootNode(parent.parent);
                	children = objDef.children;
                	if(children && children.length > 0){
	                    for(var i=0; i < children.length; i++){
	                    	childDef = this.getObjectDefinitionByType(children[i].type);
	                    	if(!isTopLevelParent){
	                    		//exclude FKDomains (Child/Parent)
	                    		childDef = children[i].isFKDomain ? null : childDef;
	                    	}
	                    	var searchSiblings = !MACInfo.AllowMultipleEntities? true : children[i].isFKDomain || children[i].addOnlyOnce || MACInfo.MaxMultipleEntities;
	                    	var maxMultipleObjects = null;
	                    	if (searchSiblings){
		                    	if (!MACInfo.AllowMultipleEntities || children[i].isFKDomain || children[i].addOnlyOnce){
		                    		maxMultipleObjects = 1;
		                    	} else {
		                    		maxMultipleObjects = MACInfo.MaxMultipleEntities;
		                    	}
		                    }
	                        if(childDef && !this.findObjectInParent(parent, childDef.type, searchSiblings, maxMultipleObjects)){
	                        	objDefList[objDefList.length] = childDef;
	                        }
	                    }
                    }
                }
            }
            this.setObjectList(objDefList);
        },

        setObjectList: function(/*ObjectDefinition[]*/ objList){
            if(MobileConfig.dlgAdd == null){
                MobileConfig.createAddDialog();
            }
        	this.dlgAdd.setObjectList(objList);
        },

        /**
         * Event handler for the 'onClick' event of the set max record limit radio buttons
         */
        maxRecordButtonHandler: function(){
            var btnMaxRec = document.getElementsByName(MCFilterPaneParams.pMAX_RECORD_RADIO);
            var orderByDiv = document.getElementById(MCFilterPaneParams.pORDER_BY_DIV);
            if (orderByDiv != null && btnMaxRec != null){
                for(var i=0; i<btnMaxRec.length; i++){
                    if(btnMaxRec[i].checked){
                        if(btnMaxRec[i].value == MCFilterPaneParams.pNO_LIMIT){
                            orderByDiv.style.display = 'none';
                        }else{
                            orderByDiv.style.display = 'inline';
                        }
                        break;
                    }
                }
            }
        },

        /**
         * Event handler for the 'onFocus' event of the max record limit text input box
         */
        maxRecordTextBoxHandler: function(){
            var btnMaxRec = document.getElementsByName(MCFilterPaneParams.pMAX_RECORD_RADIO);
            var orderByDiv = document.getElementById(MCFilterPaneParams.pORDER_BY_DIV);
            if (orderByDiv != null && btnMaxRec != null){
                for(var i=0; i<btnMaxRec.length; i++){
                    if(btnMaxRec[i].value == MCFilterPaneParams.pSET_LIMIT){
                        btnMaxRec[i].checked = true;
                        orderByDiv.style.display = 'inline';
                    }else{
                        btnMaxRec[i].checked = false;
                    }
                }
            }
        },
        
        enableActionButtons: function(/*boolean*/ enable){         	
        	var buttonClass = enable ? "btn" : "btnDisabled";
        	var btns = new Array("add_button", "remove_button", "EstimateDataSize");
        	for (var i=0; i<btns.length; i++){
        		var btn = document.getElementById(btns[i]);        	
	        	if (btn){
    	    		btn.disabled = !enable;
    	    		btn.className = buttonClass;
        		}
        	}        	
        },
        
        clearTestResults: function(){
        	MobileConfig.displayTestDataResults(null);
        }
                                
};/*class: MobileConfig */


/**
 * Pagination controls for navigating a list of many records.
 * Takes a handler function to implement goToPage(pageNum).
 * Implementor is responsible for setting new Paginator state.
 *
 * @author jtroup
 * @since 154
 */
function Paginator(args) {
	if (args)
		this.init(args);
}

Paginator.prototype.init = function(args) {
	if(args["listId"]) {
		this.listId = args["listId"];
		this.id = this.listId + "_paginator";
	} else {
		this.id = args["id"];
	}
	Paginator.addPaginator(this);

	this.containerIds = args["containerIds"];
	this.handler = args["handler"];

	this.ref = "Paginator.instances['" + this.id + "']";

	this.setState(args);
}

Paginator.prototype.setState = function(args) {
	this.currentPage = parseInt(args["currentPage"]) || this.currentPage || 1;
	this.recordsPerPage = parseInt(args["recordsPerPage"]) || this.recordsPerPage || 50;
	this.totalRecords = parseInt(args["totalRecords"]) || this.totalRecords;

	/* if totalRecords is unavailable, implementor must specify these two arguments */
	this.recordsOnThisPage = parseInt(args["recordsOnThisPage"]);
	this.more = args["more"];


	if (this.totalRecords) {
		this.totalPages = Math.ceil(this.totalRecords / this.recordsPerPage);
	}

	this.startingRecord = (this.currentPage-1)*this.recordsPerPage + 1;

	if (!args["nodraw"]) {
		var self = this;
		window.sfdcPage.appendToOnloadQueue(function() {self.draw();});
	}
}

Paginator.prototype.draw = function() {
	var html = [];
    html.push("<div class='paginator'>");

	html.push("<span class='left'>");
	html.push(this.getRecordCounts());
	html.push("</span>");

	html.push(this.getPrevNextLinks());

	html.push("<span class='right'>");
	html.push(this.getPageXofY());
	html.push("</span>");

	html.push("</div>");
	html.push("<div class='clearingBox'/>");

	for(var i=0; i < this.containerIds.length; i++) {
		document.getElementById(this.containerIds[i]).innerHTML = html.join('').replace(/__CID__/g, this.containerIds[i]);
	}
}

Paginator.keyHandle = function(e) {
    if (window.ActiveXObject && e.keyCode == KEY_ENTER) {
        getEventTarget(e).onchange();
    }
}

Paginator.prototype.getTempId = function(idSuffix) {
	return "__CID__"+idSuffix;
}

Paginator.prototype.getPageXofY = function() {
	var html = [];

	if (this.totalPages) {
		var idSuffix = "_getPageXofY";
		html.push("<label for='");
		html.push(this.getTempId(idSuffix));
		html.push("'>")
		html.push(LC.getLabel("Paginator", "page"));
		html.push("</label>");
		html.push("<input class='pageInput' maxlength='4' onchange=\"");
		html.push(this.ref);
		html.push(".goToPage(this.value)\"");
        html.push(" onkeydown=\"");
        html.push("Paginator.keyHandle(event)\"");
        html.push(" value='");
		html.push(this.currentPage);
		html.push("' id='");
		html.push(this.getTempId(idSuffix));
		html.push("'/>")
		html.push(LC.getLabel("Paginator", "of", this.totalPages));
	} else {
		html.push(LC.getLabel("Paginator", "page"));
		html.push("&nbsp;");
		html.push(this.currentPage);
	}
	return html.join('');
}

Paginator.prototype.getRecordCounts = function() {
	if (!this.totalRecords && this.recordsOnThisPage == 0) {
		return "0";
	} else {
		var html = [];
		html.push(this.startingRecord);
		html.push("-");

		var lastRecord = 0;
		if(this.totalRecords) {
			lastRecord = Math.min((this.startingRecord + this.recordsPerPage - 1),this.totalRecords);
		} else {
			lastRecord = Math.min((this.startingRecord + this.recordsPerPage - 1),(this.startingRecord + this.recordsOnThisPage - 1));
		}
		html.push(lastRecord);
		if (this.totalRecords) {
			html.push(" ");
			html.push(LC.getLabel("Paginator", "of", this.totalRecords));
		}

		return html.join('');
	}
}

Paginator.prototype.getPrevNextLinks = function() {
	var html = [];
	var jscall = "";

	html.push("<span class='prevNextLinks'>");

	// <<
	if (this.currentPage != 1) {
		jscall = this.ref + ".goToPage(1)";
		html.push("<a title='");
		html.push(LC.getLabel("Paginator", "first_page"));
		html.push("' class='prevNext' href=\"javascript:");
		html.push(jscall);
		html.push("\">");
	} else {
		html.push("<span class='prevNext prevNextDisabled'>");
	}
	html.push("&lt;&lt;");
	if (this.currentPage != 1) {
		html.push("</a>");
	} else {
		html.push("</span>");
	}

	// < Previous
	if (this.currentPage != 1) {
		jscall = this.ref + ".goToPage(" + (this.currentPage-1) + ")";
		html.push("<a title='");
		html.push(LC.getLabel("Paginator", "previous_page"));
		html.push("' class='prevNext' href=\"javascript:");
		html.push(jscall);
		html.push("\">");
	} else {
		html.push("<span class='prevNext prevNextDisabled'>");
	}
	html.push("&lt; ")
	html.push(LC.getLabel("Paginator", "previous"));
	if (this.currentPage != 1) {
		html.push("</a>");
	} else {
		html.push("</span>");
	}

	// Next >
	if (this.more || (this.totalPages && this.currentPage != this.totalPages)) {
		jscall = this.ref + ".goToPage(" + (this.currentPage+1) + ")";
		html.push("<a title='");
		html.push(LC.getLabel("Paginator", "next_page"));
		html.push("' class='prevNext' href=\"javascript:");
		html.push(jscall);
		html.push("\">");
	} else {
		html.push("<span class='prevNext prevNextDisabled'>");
	}
	html.push(LC.getLabel("Paginator", "next"));
	html.push(" &gt;")
	if (this.more || (this.totalPages && this.currentPage != this.totalPages)) {
		html.push("</a>");
	} else {
		html.push("</span>");
	}

	// >>
	if (this.totalPages && this.currentPage != this.totalPages) {
		jscall = this.ref + ".goToPage(" + this.totalPages + ")";
		html.push("<a title='");
		html.push(LC.getLabel("Paginator", "last_page"));
		html.push("' class='prevNext' href=\"javascript:");
		html.push(jscall);
		html.push("\">");
	} else {
		html.push("<span class='prevNext prevNextDisabled'>");
	}
	html.push("&gt;&gt;");
	if (this.totalPages && this.currentPage != this.totalPages) {
		html.push("</a>");
	} else {
		html.push("</span>");
	}

	html.push("</span>");

	return html.join('');
}

Paginator.prototype.goToPage = function (pageNum) {
	if (isNaN(pageNum) || pageNum < 1) {
		pageNum = 1;
    } else if (pageNum > this.totalPages) {
		pageNum = this.totalPages;
	}

	if (this.handler)
		this.handler(pageNum);
}

Paginator.addPaginator = function(what) {
	Paginator.instances[what.id] = what;
}

Paginator.instances = {};
//toggles all enabled checkboxes whose ids are specified in the 'checkboxes' array
//their state is modified according to the checkbox identified by 'controllerId'
function toggleDependentCheckboxes(controllerId, checkboxes) {
    var controller = document.getElementById(controllerId);
    var len = checkboxes.length;
    for(var i = 0; i<len; i++) {
        var checkbox = document.getElementById(checkboxes[i]);
        if(checkbox.disabled == '') {
            checkbox.checked = controller.checked;
        }
    }
}
/*
 * @author ldelascurain
 * @since 150
 *
 */

function FieldTree( rootList, formulaType, servletUrl ) {

    this.rootList = rootList;        //List of objects
    this.currentNode = FieldTree.ROOT_NODE;
    this.currentDepth = 0;
    this.formulaType = formulaType;    
    this.servletUrl = servletUrl;
}


FieldTree.LOADING_MARKER = "__";
FieldTree.ROOT_NODE = new Object();

FieldTree.prototype.getCurrentList = function() {
	if (this.currentNode === FieldTree.ROOT_NODE){
		return this.rootList; 
	} else {
	    return this.getChildren(this.currentNode);
	}
};

FieldTree.prototype.ascend = function(depthIn){

    var depth = depthIn ? depthIn : this.currentDepth - 1;
    if (depthIn === 0){
        depth = 0;
    }
    if (depth > this.currentDepth){
        depth = this.currentDepth;
    }

    while(this.currentDepth > depth){
         var parent = this.currentNode;
         if (!parent){
             return;
         }
         else if (!parent.parent) {
             this.currentNode = FieldTree.ROOT_NODE;
             this.currentDepth = 0;
         }
         else {
             this.currentNode = parent.parent;
             this.currentDepth--;
         }
    }
};

FieldTree.prototype.handleChildrenResponse = function(response, nodeToRefresh, onLazyLoad){
	var result = eval(Util.evalAjaxServletOutput(response.responseText)[AjaxGetFieldTreeChildren.NODE_LIST]);
	nodeToRefresh.setChildren(result);
	if (onLazyLoad){
		onLazyLoad(nodeToRefresh);
	}
};

FieldTree.prototype.handleChildrenError = function(response, nodeToRefresh, onLazyLoad){
	nodeToRefresh.setChildren([new FieldTreeNode(FieldTree.LOADING_MARKER, true, null, LC.getLabel("Global", "error"), true)]);
	if (onLazyLoad){
		onLazyLoad(nodeToRefresh);
	}
}

FieldTree.prototype.descend = function( selectedKey ) {
    var selectedNode = this.getNodeFromCurrentList( selectedKey );
    if (!selectedNode){
        return false;
    }
    if (selectedNode.isLeaf){
        return false;
    } 
    this.currentNode = selectedNode;
    this.currentDepth++;
    return true;
};

FieldTree.prototype.getChildren = function( selectedNode, onLazyLoad ){
	if (!selectedNode.isLeaf && !selectedNode.children){
		message = {};
		message[AjaxGetFieldTreeChildren.NODE_KEY] = selectedNode.getLabelToInsert(true);
		message[AjaxGetFieldTreeChildren.FORMULA_TYPE] = this.formulaType;
		var self = this;
		XBrowser.postHttpResponse(this.servletUrl, function(response) {self.handleChildrenResponse(response, selectedNode, onLazyLoad);}, 
			XBrowser.buildPost(message), function(response) {self.handleChildrenError(response, selectedNode, onLazyLoad);});
		selectedNode.setChildren([new FieldTreeNode(FieldTree.LOADING_MARKER, true, null, LC.getLabel("Global", "loading"), true)]);
	}
    return selectedNode.children;
};

FieldTree.prototype.getNodeFromCurrentList = function( selectedKey ) {
    var selectedNode;
    var currentList = this.getCurrentList();
    for(var i=0; i < currentList.length; i++){
        if (currentList[i].key == selectedKey ){
            selectedNode = currentList[i];
            break;
        }
    }
    return selectedNode;
};


function CustomSummaryFieldAttributes(servletUrl, parentEntityEnumOrId, entityId, fieldTargetId, radioName, oppLabels, numFilters, initialMap){
	this.radios = document.getElementsByName(radioName);
	this.parentEntityEnumOrId = parentEntityEnumOrId;
	this.servletUrl = servletUrl;
	this.entityElement = document.getElementById(entityId);
	this.fieldTarget = document.getElementById(fieldTargetId);
	if (this.entityElement){
		this.currentEntity = this.getEntityValue(this.entityElement.options[this.entityElement.selectedIndex].value);
	} else {
		//Invariant:  entityElement exists, or initialMap exists and has exactly one key
		for (var entityName in initialMap){
  			//Get the first key, should only be one
			this.currentEntity = entityName;
			break;
		}
	}
	
	this.oldOpVal = null;
	for (var i = 0; i < this.radios.length; i++){
		if (this.radios[i].checked){
			this.oldOpVal = this.radios[i].value;
			break;
		}
	}
	if (initialMap){
		this.cache = initialMap;
	} else {
		this.cache = {};
	}
	this.criteriaCache = {};
		
	var self = this;
	
	this.handleRadioClick = function(e){
		var newOpVal;
		for (var i = 0; i < self.radios.length; i++){
			if (self.radios[i].checked){
				newOpVal = self.radios[i].value;
				break;
			}
		}
		if (CustomSummaryFieldAttributes.getShownFields(newOpVal) != CustomSummaryFieldAttributes.getShownFields(self.oldOpVal)){
			self.setCurrentEntity();
		}
		self.oldOpVal = newOpVal;
	}
	
	this.handleEntityChange = function(e){
		var entityElementValue = self.getEntityValue(self.entityElement.options[self.entityElement.selectedIndex].value);
		self.setCurrentEntity(entityElementValue);	
	}
	
	this.handleFilterViewClick = function(e){
		var radio = getEventTarget(getEvent(e));
		document.getElementById(CriteriaInputConstants.FILTER_SECTION_ID).style.display = (radio.value == "1" ? "block" : "none");
	}
	
	this.cacheFieldsFromResponse = function(request){
		var response = Util.evalAjaxServletOutput(request.responseText);
		var fields = response[AjaxLoadFieldsForEntity.pFIELD_LIST];
		self.cache[response[AjaxLoadFieldsForEntity.pENTITY_NAME]] = fields;
		self.fillFieldsFromCache();
	}
	
	/**
	 * This can be called with no arguments to refresh the list based on this.currentEntity
	 */
	this.setCurrentEntity = function(value){
		if (typeof(value) != "undefined"){
			self.currentEntity = value;
		}
		if (self.currentEntity){
			self.setOpsEnabled(true);
			var fields = self.cache[self.currentEntity];
			if (fields){
				self.fillFieldsFromCache();
			} else {
				var	postMap = {};
				postMap[self.entityElement.name] = self.currentEntity;
				postMap[AjaxLoadFieldsForEntity.pPARENT_ENTITY_NAME] = self.parentEntityEnumOrId;
				XBrowser.postHttpResponse(self.servletUrl, self.cacheFieldsFromResponse, XBrowser.buildPost(postMap));
			}
		} else {
			self.setOpsEnabled(false);
		}
	}
	
	this.setOpsEnabled = function(enabled){
		if (self.radios && self.radios.length > 0){
			//will be empty if field is managed-installed or managed-released
			for (var i = 0; i < self.radios.length; i++){
				self.radios[i].disabled = !enabled;
				if (!enabled){
					self.radios[i].checked = false;
				}
			}
		}
		if (self.fieldTarget){
			self.fieldTarget.disabled = !enabled;
			if (!enabled){	
				self.fieldTarget = Util.refreshDynamicSelect(self.fieldTarget, [], true);
				self.fieldTarget.disabled = true;
			}
		}
	}
	
	var prevCriteriaData;
	if (this.currentEntity){
		prevCriteriaData = new CriteriaEntityData(this.currentEntity, this.cache[this.currentEntity]);
		this.criteriaCache[this.currentEntity] = prevCriteriaData;
	}
	this.criteriaInput = new CriteriaInput(oppLabels, numFilters, prevCriteriaData);
	
	if 	(this.currentEntity){
		this.setCurrentEntity();
	} else {
		this.setOpsEnabled(false);
	}

	this.initEvents();		
}

CustomSummaryFieldAttributes.prototype.getEntityValue = function(picklistVal){
	if (!picklistVal){
		return null;
	}
	return picklistVal.substring(0, picklistVal.indexOf('.'));
}

CustomSummaryFieldAttributes.prototype.showOptions = function(shown){
	document.getElementById(SummaryFieldConstants.OPTIONS_ID).style.display = shown ? 'block' : 'none';
}

CustomSummaryFieldAttributes.prototype.initEvents = function(){
	for (var i = 0; i < this.radios.length; i++){
		addEvent(this.radios[i], 'click', this.handleRadioClick, false);
	}
	var filterViewRadios = document.getElementsByName(CriteriaInputConstants.SHOW_SUMMARY_FILTER);
	for (var i = 0; i < filterViewRadios.length; i++){
		addEvent(filterViewRadios[i], 'click', this.handleFilterViewClick, false);
		if (filterViewRadios[i].value == "1" && filterViewRadios[i].checked){
			document.getElementById(CriteriaInputConstants.FILTER_SECTION_ID).style.display = "block";
		}
	}
	if (this.entityElement){
		addEvent(this.entityElement, 'change', this.handleEntityChange, false);
	}
}

CustomSummaryFieldAttributes.prototype.setCurrentCriteria = function(entity){
	var fields = this.cache[entity];
	if (!fields){
		Gack.sendGack("criteriadata set before fields loaded.  Entity: " + entity);
	}	
	var criteriaEntity = this.criteriaCache[entity];
	if (!criteriaEntity){
		criteriaEntity = new CriteriaEntityData(entity, fields);
		this.criteriaCache[entity] = criteriaEntity;
	}
	this.criteriaInput.setEntity(criteriaEntity);
}

CustomSummaryFieldAttributes.prototype.fillFieldsFromCache = function(){
	var shownFields;	
	for (var i = 0; i < this.radios.length; i++){
		if (this.radios[i].checked){
			shownFields = CustomSummaryFieldAttributes.getShownFields(this.radios[i].value);
			break;
		}
	}
	
	this.setCurrentCriteria(this.currentEntity);
	
	var anyOptions = false;
	var prevOptionIndex = 0;
	if (this.fieldTarget){
		if(!shownFields){
			this.fieldTarget = Util.refreshDynamicSelect(this.fieldTarget, [], true, "")
		} else {
			var prevOption;
			if (this.fieldTarget.options && this.fieldTarget.selectedIndex >= 0){
				//Options already exist, see if one is selected and hold on to it
				prevOption = this.fieldTarget.options[this.fieldTarget.selectedIndex].value;
			}
			
			var options = []
			var fields = this.cache[this.currentEntity];
			var numShownOptions = 1;
			for (var i = 0; i < fields.length; i++){
				if (fields[i].columnType in shownFields){
					anyOptions = true;
					options.push([fields[i].label, fields[i].name]);
					numShownOptions++;
				}
			}
			this.fieldTarget = Util.refreshDynamicSelect(this.fieldTarget, options, true, prevOption);
		}
	
		if (!anyOptions){
			this.fieldTarget.disabled = true;
		} else {
			this.fieldTarget.disabled = false;
		}
	}
}

CustomSummaryFieldAttributes.getShownFields = function(enumVal) {
	switch (enumVal){
		case "0":
			return null;
		case "1":
			var ar = {};
			for (var type in ColumnType){
				if (ColumnType[type].isNumber){
					ar[type] = true; 
				}
			}
			return ar;
		case "2":
		case "3":
			var ar = {};
			for (var type in ColumnType){
				if (ColumnType[type].isNumber || ColumnType[type].isDate){
					ar[type] = true; 
				}
			}
			return ar;
	}
}

/*
* @author mpolcari
* @since 144
*/
function OverviewPage() {}

OverviewPage.prototype = new GenericSfdcPage();

function ValidateFormula(servletUrl, buttonId, validTextId, bodyId, fieldArray){
	
	
	this.bodyId = bodyId;
	this.validTextId = validTextId;
	this.fieldArray = fieldArray;
	this.servletUrl = servletUrl;
	
	this.isLoading = false;
	this.loading = new LoadingScreen(document.getElementById(bodyId).parentNode, LC.getLabel("Scontrol", "CheckingSyntax"));
	
	var self = this;
	
	this.handleCheckSyntaxResponse = function(request){
		response = Util.evalAjaxServletOutput(request.responseText);
		document.getElementById(self.validTextId).innerHTML = response[AjaxServlet.ERROR_MSG_KEY];
		if (!response[AjaxValidateFormula.VALID_KEY]){
			var range = response[AjaxValidateFormula.RANGE_KEY];
			if (range){
				setContentWindow(window);
				setSelectionInEditor(self.bodyId, range[0], range[1]);
			}
		}
		self.setLoading(false);
	};
	
	this.handleCheckSyntaxError = function(request){
		document.getElementById(self.validTextId).innerHTML = LC.getLabel("Scontrol", "AjaxError");
		self.setLoading(false);
	};
	
	this.handleCheckSyntaxClick = function(e){
		self.setLoading(true);
		var postMap = {};
		for (var i = 0; i < self.fieldArray.length; i++){
			postMap[self.fieldArray[i]] = document.getElementById(self.fieldArray[i]).value;
		}
		postMap[self.bodyId] = document.getElementById(self.bodyId).value;
		XBrowser.postHttpResponse(self.servletUrl, self.handleCheckSyntaxResponse, 
			XBrowser.buildPost(postMap), self.handleCheckSyntaxError);
	};
	
	addEvent(document.getElementById(buttonId), "click", this.handleCheckSyntaxClick, true);
	
}

ValidateFormula.prototype.setLoading = function(val){
	if (val != this.isLoading){
		if (val){
			this.loading.show();
			this.isLoading = true;
		} else {
			this.loading.hide();
			this.isLoading = false;
		}
	}
};
/**
 * @author zzhou
 * since 148
 * CrtLayout Available Section javascript code; also see CrtLayout.js, AvailableField.js, Lookups.js
 */


CrtLayoutElement.availableSections = {};

AvailableSection.prototype.addField = function(availField) {
    this.fields[availField.id] = availField;
}

//theorically it will make more sense to attach event handlers to the individual field element themselves
//however setting all the event handlers on each of the fields would take too long on a page with many fields
//thus we attach events to the parent element and then delegate to the appropriate event handler during events
AvailableSection.prototype.attachEvents = function(pageNum) {
    var self = this;
    var tableElem = document.getElementById(self.getPagenationId(self.sectionId,pageNum));
    addEvent(tableElem, 'mouseover', function(evt) {self.handleMouseOver(evt);}, false);
    addEvent(tableElem, 'mouseout', function(evt) {self.handleMouseOut(evt);}, false);
    addEvent(tableElem, 'mousedown', function(evt) {self.handleMouseDown(evt);}, false);
    addEvent(tableElem, 'click', function(evt) {self.handleMouseClick(evt);}, false);

}

AvailableSection.prototype.handleMouseOver = function(evt) {
    var elem = getEventTarget(evt);
    var field = this.fields[elem.id];
    if (field) {
        if (!field.elem) {
            field.elem = elem;
        }
        field.handleMouseOver(evt);
        return;
    }

    if (CrtLayoutElement.mouseDown && CrtLayoutElement.dragMove) {
        //swap to appropriate section based on the currentSelectedObj
        CrtLayoutElement.clearHighlights();
        var fieldValue = MoveableItem.currentSelectedObj.itemId;
        var sectionObj = CrtLayoutElement.getSectionFromFieldValue(fieldValue);
        sectionObj.highlightSection(fieldValue);
    } else {
        CrtLayoutElement.handleMouseOver(evt);
    }
}

AvailableSection.prototype.handleMouseOut = function(evt) {
    var elem = getEventTarget(evt);
    var field = this.fields[elem.id];
    if (field) {
        if (!field.elem) {
            field.elem = elem;
        }
        field.handleMouseOut(evt);
    }
}

AvailableSection.prototype.handleMouseDown = function(evt) {
    var elem = getEventTarget(evt);
    var field = this.fields[elem.id];
    if (field) {
        if (!field.elem) {
            field.elem = elem;
        }
        field.handleMouseDown(evt);
        return;
    }
}

AvailableSection.prototype.handleMouseClick = function(evt) {
    var elem = getEventTarget(evt);
    var field = this.fields[elem.id];
    if (field) {
        if (!field.elem) {
            field.elem = elem;
        }
        field.handleMouseClick(evt);
        return;
    }
}

CrtLookupSection.getSectionIdFromPrim = function(primaryObjId) {
    return primaryObjId + '_' + LookupsUi.LOOKUPS;
}

AvailableSection.prototype.highlightSection = function(fieldValue) {
    var pageNum = this.fields[fieldValue].pageNum;
    this.swapToSectionDiv(null,pageNum);
    var sectionObj = document.getElementById(this.getPagenationId(this.sectionId,pageNum));
    sectionObj.className = sectionObj.className + ' lookupHighlightSection';
    CrtLayoutElement.highlightAvailSection = this;
}

AvailableSection.prototype.handleMouseUp = function(evt) {
    var sectionObj = document.getElementById(this.getPagenationId(this.sectionId,this.currentPage));
    sectionObj.className = "availSectionTable";
    CrtLayoutElement.highlightAvailSection = null;
}

function AvailableSection(sectionId, divId, headerTitle) {
        this.sectionId = sectionId;
        this.divId = divId;
        this.sectionHeaderId = this.sectionId+'_HEADER';
        this.sectionFooterId = this.sectionId+'_FOOTER';
        this.currentPage = 1;
        this.headerTitle = headerTitle;
        //avail fields
        this.fields = {};

        //add section to map of all LookupSections;
        CrtLayoutElement.availableSections[this.sectionId] = this;
 }

//extend Available Section to CrtLookupSection
CrtLookupSection.prototype = new AvailableSection();

 function CrtLookupSection(sectionId, divId, headerTitle) {
        this.sectionId = sectionId;
        this.divId = divId;
        this.sectionHeaderId = this.sectionId+'_HEADER';
        this.sectionFooterId = this.sectionId+'_FOOTER';
        this.currentPage = 1;
        this.headerTitle = headerTitle;
        //avail fields
        this.fields = {};


    //add section to map of allLookupSections;
    CrtLayoutElement.availableSections[sectionId] = this;
}

AvailableSection.prototype.moveCells = function() {
           //first set the old positions to empty for all the cells being moved
         CrtLayoutElement.sectionsToReformat = {};
         for (var i=0; i < MoveableItem.selectedBucket.length; i++) {
                var item = MoveableItem.selectedBucket[i];
                 //cannot move available fields around
               if (item.inLayout) {
                  item.fieldObj.handleMoved();
                  if (this.fields[item.itemId]) {
                      this.fields[item.itemId].handleMoveTo();
                  }
                  //or else needs to move these fields to another section
                  else {
                      CrtLayoutElement.getSectionFromFieldValue(item.itemId).fields[item.itemId].handleMoveTo();
                  }
               }
         }
        CrtLayoutElement.reformatSections();
   }

//return the lookup fields in terms of a CrtFieldCollection
CrtLookupSection.prototype.getFieldCollection = function() {
    var lookups = new CrtFieldCollection();
    for (var i in this.fields) {
        var field = this.fields[i].getFieldValue();
        var iFieldSep = field.indexOf(CrtLayoutElement.FIELD_SEP);
        var iIdSep = field.indexOf(CrtLayoutElement.COL_SEP);
        var path = field.substring(0,iFieldSep);
        var fieldName = field.substring(iFieldSep+1,iIdSep);
        lookups.addField(path,fieldName);
    }
    return lookups;
}

CrtLookupSection.prototype.removeFieldCollection = function(removedFields) {
    var allFieldKeys = removedFields.getAllFieldKeys();
    for (var i=0; i<allFieldKeys.length; i++) {
        var crtFieldObj = removedFields.getField(allFieldKeys[i]);
        var colId = "";
        var stuff = CrtLayoutElement.initialStateColIdMap;
        if (CrtLayoutElement.initialStateColIdMap[crtFieldObj.objectPath+CrtLayoutElement.FIELD_SEP+crtFieldObj.field]) {
            colId = CrtLayoutElement.initialStateColIdMap[crtFieldObj.objectPath+CrtLayoutElement.FIELD_SEP+crtFieldObj.field];
        }
        var fieldValue = this.createFieldKey(crtFieldObj,colId);

        //remove fields from layout and reformat the table
        this.fields[fieldValue].removeFromLayout();
        delete this.fields[fieldValue];
    }

    //reformat tables
    CrtLayoutElement.reformatSections();
}

//add the drop down picklist for the lookupSection
CrtLookupSection.prototype.addPicklist = function(primObjDivId) {
    //select Element
    var selectedElement = document.getElementById(CrtLayoutElement.FIELD_TYPE_SELECT_NAME);

    //create the drop down list to select this lookup section div
    var newOpt = new Option(selectedElement.options[selectedElement.selectedIndex].text+ ' ' + LC.getLabel("CRTLookupLayer","viaLookupParen"), this.sectionId, false, false);
    Util.insertOption(selectedElement,newOpt,selectedElement.selectedIndex+1);
}

//remove the section by removing it from the document node tree;
//also remove the selected element
//also remove of it's fields from layout section
CrtLookupSection.prototype.remove = function() {
    //remove the option from the select picklist
    var selectedElement = document.getElementById(CrtLayoutElement.FIELD_TYPE_SELECT_NAME);
    //decide which one to remove
    if (selectedElement.options[selectedElement.selectedIndex].value == this.sectionId) {
        var selectInd = selectedElement.selectedIndex;
        selectedElement.options[selectedElement.selectedIndex]=null;
        selectedElement.options[selectInd-1].selected = true;
    } else {
        selectedElement.options[selectedElement.selectedIndex+1]=null;
    }

    CrtLayoutElement.swapAvailableType(selectedElement);

    //remove the element
    var divElem = document.getElementById(this.getPagenationId(this.divId,1));
    divElem.parentNode.removeChild(divElem);

    //remove all fields and reformat layout tables
    var tableId;
    for (var i in this.fields) {
        this.fields[i].removeFromLayout();
    }
    CrtLayoutElement.reformatSections();
}

//swap to the appropriate div and change the available section picklist
AvailableSection.prototype.swapToSectionDiv = function(fromPage,toPage) {
    //select Element
    var selectedElement = document.getElementById(CrtLayoutElement.FIELD_TYPE_SELECT_NAME);

    //select to the appropriate picklist value/section div if needed
    if (selectedElement.options[selectedElement.selectedIndex].value != this.sectionId) {
        for (var i=0; i< selectedElement.options.length; i++) {
            if (selectedElement.options[i].value == this.sectionId) {
                selectedElement.options[i].selected = true;
                break;
            }
        }

    }
    CrtLayoutElement.swapAvailableType(selectedElement,fromPage,toPage);

}


//SPECIAL function to move lookup fields initially to the layout sections
CrtLookupSection.prototype.moveFields = function(newFields) {
    //move it to the section with the appropriate name
    //TODO what happens if we have unique section names (with numbering)?
    var primObjId = CrtLayoutElement.getPrimObjId(this.divId,CrtLayoutElement.DIV_SEP);
    var secName = CrtLayoutElement.getPrimObjMetaMap()[primObjId].label;
    var map = CrtLayoutElement.sectionNameIdMap;
    var secObj = CrtLayoutElement.sectionNameIdMap[secName];
    if (!secObj) {
        //if we don't have section with that name, create the section and get its table again
        secObj = CrtLayoutElement.createNewSection(secName);
    }

    //add all newly added fields to the selected bucket and then try to insert them
    for (var i=0; i<newFields.length; i++) {
        newFields[i].addSelection();
    }
    //try to insert these cells now
    //move these cells to the end of the section
    secObj.moveCells(secObj.numRows-1,secObj.numCols-1);
    MoveableItem.clearSelectedItems();
}

AvailableSection.prototype.renderFields = function() {
    //only for lookups do we regenerate the divs if necessary
    if (this instanceof CrtLookupSection) {
        this.removeDivs();
    }

    var fieldsArray = [];
    for (var i in this.fields) {
           fieldsArray.push(this.fields[i]);
    }
    //do some paging-related calculations
    var numCols = fieldsArray.length > CrtLayoutElement.NUM_ROWS_PER_AVAILABLE_SECTION ? 2 : 1;
    this.numPages = Math.ceil(fieldsArray.length / (numCols * CrtLayoutElement.NUM_ROWS_PER_AVAILABLE_SECTION));

    var k=0;
    var innerHTML;
    //parent Node is just the parent of the primary obj div
    var parentNode = document.getElementById("tcForAvailableSections");
    for (var pageNum=1; pageNum <= this.numPages; pageNum++) {
        /*init html elements */
        //div element

        var lookupDivElem = document.createElement("div");
        lookupDivElem.id = this.getPagenationId(this.divId,pageNum);
        lookupDivElem.className = 'availFieldsSection';
        lookupDivElem.style.display = 'none';
        innerHTML = [];

        //table header div element
        innerHTML.push('<div id=\"' + this.getPagenationId(this.sectionHeaderId,pageNum) + '\" style=\"padding:4px;\">');

        //title is '<Object> fields'
        //var html = '';
        innerHTML.push('<div>' + this.headerTitle + ' <span class="availHeadPaging">[Page' + pageNum + '/' + this.numPages + ']</span></div>');

        innerHTML.push(this.addPagingDivs(pageNum));
        innerHTML.push('</div>');

        //main table element div
        innerHTML.push('<div class=\"lookupSectionTableDiv noFloat\">');

        //section table element
        innerHTML.push('<table id=\"' + this.getPagenationId(this.sectionId,pageNum) + '\" class=\"availLookupSectionTable\">');
        innerHTML.push('<tbody>');
        //insert cells for each lkup section table
        for (var j=0; j < CrtLayoutElement.NUM_ROWS_PER_AVAILABLE_SECTION && k < fieldsArray.length; j++) {
            innerHTML.push('<tr>')
            for (var l =0; l < numCols && k < fieldsArray.length; l++, k++) {
                //fix the pageNum of the field to it's actual section
                var field = fieldsArray[k];
                field.pageNum = pageNum;
                innerHTML.push('<td id=\"' + field.id + '\" class=\"availField ');
                innerHTML.push(field.inLayout ? 'usedAvailField' : 'unusedAvailField');
                innerHTML.push('\">' + field.formatDName() + '</td>');
            }
            innerHTML.push('</tr>');
        }
        innerHTML.push('</tbody></table></div>');

        innerHTML.push('<div id=\"' + this.getPagenationId(this.sectionFooterId,pageNum) + '\">');
        innerHTML.push(this.addPagingDivs(pageNum));

        //no float div
        innerHTML.push('</div>');
        innerHTML.push('<div class=\"noFloat\"></div>');

        lookupDivElem.innerHTML += innerHTML.join('');
        parentNode.appendChild(lookupDivElem);
        this.attachEvents(pageNum);
    }
}

AvailableSection.prototype.getPagenationId = function(id, pageNum) {
     return id+'_'+pageNum;
 }

CrtLookupSection.prototype.removeDivs = function() {
    //remove all pagenated divs
    for (var i=1; i <= this.numPages; i++) {
        divElem = document.getElementById(this.getPagenationId(this.divId,i));
        //remove this div (and regenerate it later)
        divElem.parentNode.removeChild(divElem);
    }
}

//add the divs for when we do paging
AvailableSection.prototype.addPagingDivs = function(pageNum) {

        var html = [];
        //page selector buttons
        if (this.numPages > 1) {
            html.push('<hr class=\"availHeadLine\">');
            html.push('<div>');
            //prev button
            if (pageNum > 1) {
                html.push('<span class="prevButton">');
                html.push('<a onclick="CrtLayoutElement.availableSections[\'' + this.sectionId + '\'].swapPages(' + pageNum +',' + (pageNum-1) + ');">');
                html.push(CrtLayoutElement.PAGE_PREV_IMG);
                html.push(CrtLayoutElement.PAGE_PREV);
                html.push('</a>');
                html.push('</span>');
            }
            //next button
            if (pageNum < this.numPages) {
                html.push('<span class="nextButton">');
                html.push('<a onclick="CrtLayoutElement.availableSections[\'' + this.sectionId + '\'].swapPages(' + pageNum + ',' + (pageNum+1) + ');">');
                html.push(CrtLayoutElement.PAGE_NEXT);
                html.push(CrtLayoutElement.PAGE_NEXT_IMG);
                html.push('</a>');
                html.push('</span>');
            }
            html.push('</div>');
        }
        return html.join('');
}
CrtLookupSection.prototype.getFieldFromMeta = function(primObjMData, fieldsMData, path,fieldName) {
    var iFieldSep = path.lastIndexOf('.');
    var iSep = path.indexOf('.');
    var table = primObjMData[path.substring(0,iSep)].table;
    var lookup;
    while (iSep != iFieldSep) {
        lookup = path.substring(iSep+1,path.indexOf('.',iSep+1));
        table = fieldsMData[table][lookup].lookup;
        iSep = path.indexOf('.',iSep+1);
    }
    lookup = path.substring(iSep+1);
    table = fieldsMData[table][lookup].lookup;
    return fieldsMData[table][fieldName];
}

CrtLookupSection.prototype.insertFieldCollection = function(fieldCollection,primObjMData,fieldsMData) {
    var allFieldKeys = fieldCollection.getAllFieldKeys();
    var newFields = [];
    for (var i=0; i<allFieldKeys.length; i++) {
        //make sure we are not trying to add an existing column
        var fieldKey;
        var crtFieldObj = fieldCollection.getField(allFieldKeys[i]);
        //find the existing fieldKey for this objectPath+field if available or else
        if (CrtLayoutElement.initialStateColIdMap[crtFieldObj.objectPath+CrtLayoutElement.FIELD_SEP+crtFieldObj.field]) {
            fieldKey = this.createFieldKey(crtFieldObj,CrtLayoutElement.initialStateColIdMap[crtFieldObj.objectPath+CrtLayoutElement.FIELD_SEP+crtFieldObj.field]);
        } else {
        //create a new lookupfield in the section and add it to fields collection
            fieldKey = this.createFieldKey(crtFieldObj,"");
        }

        //get metadata based on path
        var dataField = this.getFieldFromMeta(primObjMData,fieldsMData,crtFieldObj.objectPath,crtFieldObj.field);
        this.addField(new AvailableField(this.sectionId,fieldKey,dataField.label,true,true));
        newFields.push(this.fields[fieldKey]);
    }
    this.moveFields(newFields);
}


CrtLookupSection.prototype.createFieldKey = function(crtFieldObj, colId) {
    return crtFieldObj.objectPath+CrtLayoutElement.FIELD_SEP+crtFieldObj.field+CrtLayoutElement.COL_SEP+colId;
}

CrtLookupSection.prototype.getField = function(fieldId) {
    return this.fields[fieldId];
}

AvailableSection.prototype.swapToPage = function(pageNum){
    if (!pageNum) {
        pageNum = 1;
    }
    document.getElementById(this.getPagenationId(this.divId,pageNum)).style.display = 'block';
    this.currentPage = pageNum;
    CrtLayoutElement.currentDisplayedSec = this;
}

AvailableSection.prototype.swapPages = function(fromPageNum,toPageNum) {
    this.swapFromPage(fromPageNum);
    this.swapToPage(toPageNum);
}
AvailableSection.prototype.swapFromPage = function(pageNum) {
    if (!pageNum) {
        pageNum = this.currentPage;
    }
    document.getElementById(this.getPagenationId(this.divId,pageNum)).style.display = 'none';
    CrtLayoutElement.currentDisplayedSec = null;
}


function iframeShim(theDiv){
    this.div = theDiv;
    if (this.div.currentStyle) {
        if (XBrowser.userAgent.isIE7) {
            // IE7, no need for shim, but have to use IE opacity filter
            this.setStyle = this.setStyleNonIE;
            this.setOpacity = this.setOpacityIE;
            this.getOpacity = this.getOpacityIE;
        } else {
            // We only need this in IE6
            var frame = document.createElement("iframe");
            frame.src = IFrameElement.BLANK_SRC;
            frame.frameBorder = "0";
            frame.scrolling = "no";
            frame.className = "iframeShim";
            frame.style.zIndex = this.div.currentStyle.zIndex - 1;
            var offsetLeft = getLocalOffsetLeft(this.div);
            var styleLeft = this.div.currentStyle.left;
            if (offsetLeft == 0 && styleLeft){
                frame.style.left = styleLeft;
            } else {
              	frame.style.left = offsetLeft;
        	}
            var offsetTop = getLocalOffsetTop(this.div)
            var styleTop = this.div.currentStyle.top;
            var styleBottom = this.div.currentStyle.bottom;
            if (offsetTop == 0 && (styleTop || styleBottom)){
            frame.style.top = styleTop;
                frame.style.bottom = styleBottom;
            } else {
	           frame.style.top = offsetTop;
        	}
            frame.style.height = this.div.offsetHeight;
            frame.style.position = "absolute";
            frame.style.display = this.div.currentStyle.display;
            this.iframe = frame;

            this.div.parentNode.insertBefore(this.iframe, this.div);
            this.setStyle = this.setStyleIE;
            this.setOpacity = this.setOpacityIE;
            this.getOpacity = this.getOpacityIE;
        }
    } else {
        //Non IE, just pass calls through
        this.setStyle = this.setStyleNonIE;
        this.setOpacity = this.setOpacityNonIE;
        this.getOpacity = this.getOpacityNonIE;
    }
}

iframeShim.prototype = {
    setStyleNonIE : function(prop, val){
                        this.div.style[prop] = val;
                    },

    setStyleIE : function(prop, val){
                        this.div.style[prop] = val;
                        if (prop != 'position'){
                        	//Iframe must remain position:absolute
	                        this.iframe.style[prop] = val;
                        }
                        //Refresh iframe's width and height from the browser calculated offsets.
                        this.iframe.style.width = this.div.offsetWidth + "px";
	                    this.iframe.style.height = this.div.offsetHeight + "px";
	                    this.iframe.style.left = getLocalOffsetLeft(this.div);
				        this.iframe.style.top = getLocalOffsetTop(this.div);

                 },

    setOpacityNonIE : function(val){
                            if (val < 0) val = 0;
                            if (val > 1) val = 1;
                            this.div.style.opacity = val;
                      },

    setOpacityIE : function(val){
                        if (val < 0) val = 0;
                        if (val > 1) val = 1;
                        this.div.filters.alpha.opacity = (val * 100);
                        //Iframe stays at opacity 0
                   },

    getOpacityNonIE : function() { return getCurrentStyle(this.div, 'opacity'); },
    getOpacityIE : function() { return this.div.filters.alpha.opacity / 100.0; },

    getStyle : function(prop) {
        return this.div.style[prop];
    }

}

function CustomEntityDefinition(selectElemId, radioName) {
	//If the the select doesn't exist, we don't need anything else (might be a managed entity)
	if (!document.getElementById(selectElemId)){
		return;
	}
    this.picker = selectElemId;
    this.radioName = radioName;

    var self = this;

    this.enableScontrolPicker = function(e) {
        var radio = getEventTarget(getEvent(e));
        document.getElementById(selectElemId).disabled = (radio.value == "1" ? false : true);
        document.getElementById(selectElemId).value = (radio.value == "1" ? document.getElementById(selectElemId).value : "");
    }

    var radios = document.getElementsByName(this.radioName);

    for( var i=0; i<radios.length; i++){
        addEvent(radios[i], "click", this.enableScontrolPicker, false);
    }

    document.getElementById(selectElemId).disabled = (document.getElementById(selectElemId).value == "" ? true : false);

}

CustomEntityDefinition.handleAutoNumberSel = function(s,e1,e2) {
    var b =s.selectedIndex == 0;
    toggleRow(e1, !b);
    if (e2) toggleRow(e2, !b);
}
CustomEntityDefinition.hasAlerted = false;
CustomEntityDefinition.displayFormatChangeWarning = function() {
    if (!CustomEntityDefinition.hasAlerted) {
        alert(LC.getLabel('Page_CustomEntityDefinition_Edit', 'DisplayFormatChangeWarning'));
        CustomEntityDefinition.hasAlerted = true;
    }
}

CustomEntityDefinition.setNameLabel = function(masterLabel, nameElem) {
    if (nameElem.value.length == 0 && masterLabel.value.length != 0) {
        var max = nameElem.maxLength;
        var targetVal = LC.getLabel('Page_CustomEntityDefinition_Edit', 'DefaultNameLabel', masterLabel.value);
        if (targetVal.length > max){
            targetVal = targetVal.substring(0, max);
        }
        nameElem.value = targetVal;
    }
}


/*
* @author mpolcari
* @since 144
*/
function EditPage() {
	this.saved = false;
	this.submitButtons = [];
	this.originalButtonClasses = [];
	this.originalButtonValues = [];
	this.pressedButton = null;
}

EditPage.prototype = new GenericSfdcPage();

EditPage.prototype.initButtons = function(buttonNames) {
    var self = this;
    for (var i = 0; i < buttonNames.length; i++) {
        var elements = document.getElementsByName(buttonNames[i]);
        for (var j = 0; j < elements.length; j++) {
            this.submitButtons.push(elements[j]);
            this.originalButtonClasses.push(elements[j].className);
            this.originalButtonValues.push(elements[j].value);
            addEvent(elements[j], "click", function(e) { self.pressedButton = getEventTarget(e); }, false);
        }
    }
}


/**
 * disable all the save buttons after the user clicks on one of them
 */
EditPage.prototype.disableSaveButtons = function() {
	if (this.saved) {
		return false;
	} else {
	    // don't disable the buttons if cancel was pressed
	    if (!this.pressedButton || this.pressedButton.name != EditPageConstants.pCANCEL) {
	        this.disableButtons();
	    }
		this.saved = true;
		return true;
	}
}


EditPage.prototype.disableButtons = function() {
	for (var i = 0; i < this.submitButtons.length; i++) {
		this.submitButtons[i].className = "btnDisabled";
		this.submitButtons[i].value = LC.getLabel("Buttons", "saving");
	}
}

EditPage.prototype.enableSaveButtons = function() {
	if (!this.saved) {
		return false;
	} else {
		for (var i = 0; i < this.submitButtons.length; i++) {
			this.submitButtons[i].className = this.originalButtonClasses[i];
			this.submitButtons[i].value = this.originalButtonValues[i];
		}
		this.saved = false;
		return true;
	}
}

function ListViewport(id, type) {
	this.id = id;
	this.type = type;
	this.filter = null;
	this.inlineEditData = null;
	
	this.listViewport = null;
	this.filterLinks = null;
	this.rolodex = null;
	this.listBody = null;
	this.bottomNav = null;
	this.listSelect = null;
	this.pageState = null;
	this.rolodexState = null;
	this.exception = null;
	this.buttons = null;
	this.printLink = null;
	this.offPageIds = null;
	
	this.loading = null;
	this.saving = null;
	this.paginator = null;
	this.grid = null;
	this.linkTemplates = null;
	this.retURL = null;
		
	this.url = "/_ui/common/list/ListServlet";
	this.xhr = null;
	
	this.rolodexIndex = null;
	
	this.debug = new QueryString().get('debug');

	ListViewport.addListViewport(this);
	
	var self = this;
	window.sfdcPage.appendToOnloadQueue(function() {self.init();});
	window.sfdcPage.appendToOnloadQueue(function() {self.redefineSidebarPin();});
    addEvent(window, "resize", function(){ self.resize();});
}

ListViewport.DEFAULT_COLUMN_WIDTH = 125;

ListViewport.prototype.resetTimer = function () {
	this.timepoint(null, true);
}

ListViewport.prototype.timepoint = function (label, reset) {	
	if (!this.debug)
		return;

	if (!this.timer || reset) {
		this.timer = new Date();
		this.times = [];
	} else {
		var start = this.timer;
		this.timer = new Date();
		var elapsed = this.timer.getTime() - start.getTime();
		this.times.push({label: label, elapsed: elapsed});
	}
}

ListViewport.prototype.dumpObject = function(obj) {
	if (!this.debug)
		return;
	
	var tab = "&nbsp;&nbsp;&nbsp;&nbsp;";
	for (var item in obj) {
		var str = [];
		str.push(tab);
		str.push(item);
		str.push(": ");
		str.push(obj[item]);
		this.times.push(str.join(''));
	}
}

ListViewport.prototype.toggle = function() {
	if (!this.debugContent) {
		return;
	}
	
	if (this.debugContent.style.display == "none") {
		this.debugContent.style.display = "";
	} else {
		this.debugContent.style.display = "none";
	}
}

ListViewport.prototype.outputTimes = function() {
	if (!this.times)
		return;
		
	var total = 0;
	var html = [];
	html.push("==========<br/>");
	for (var i=0; i<this.times.length; i++) {
		if (typeof(this.times[i].elapsed)=="number") {
			html.push(this.times[i].elapsed);
			html.push("ms");
			var tabnum = 8-(this.times[i].elapsed+"").length
			for (var j=0; j<tabnum; j++) {
				html.push("&nbsp;");
			}
			html.push(this.times[i].label);
			html.push("<br/>");
			total += this.times[i].elapsed;
		} else {
			html.push(this.times[i]);
			html.push("<br/>");
		}
	}
	html.push("----------<br/><b>");
	html.push(total);
	html.push("ms");
	var tabnum = 8-(total+"").length
	for (var j=0; j<tabnum; j++) {
		html.push("&nbsp;");
	}
	html.push("TOTAL TIME FROM REQUEST TO COMPLETION</b>");
	
	if (!this.debugDiv) {
		this.debugDiv = document.createElement('div');
		this.debugDiv.id = this.id + "_debugDiv";
		this.debugDiv.style.position = "absolute";
		this.debugDiv.style.top = "0px";
		this.debugDiv.style.left = "250px";
		this.debugDiv.style.border = "2px solid red";
		this.debugDiv.style.margin = "3px";
		this.debugDiv.style.padding = "3px";
		this.debugDiv.style.backgroundColor = "white";
		this.debugDiv.style.fontFamily = "Courier New, Courier, monospace";
		var toggle = document.createElement('input');
		toggle.type = "button";
		toggle.value = "Show/Hide Debug Log";
		toggle.className = "btn";
		var self = this;
		toggle.onclick = function() {self.toggle()};
		this.debugDiv.appendChild(toggle);
		this.debugContent = document.createElement('div');
		this.debugDiv.appendChild(this.debugContent);
		document.body.appendChild(this.debugDiv);
	}
	this.debugContent.innerHTML = html.join('');
}

ListViewport.prototype.init = function() {
    /* We need to redefine this function so it will work properly with custom buttons that use the SControl function GETRECORDIDS */
    var self = this;
    Scontrol.prototype.getSelectedRecordIdsFromForm = function () {
        return self.grid.getSelectionModel().selections.keys;
    }

	this.getReferences();
	this.initializeLinkTemplates();
	this.resize();
	
	var qs = new QueryString();

	// make the first request
	this.getListData({
		listid: this.listSelect.value,
		action: "newfilter",
		page: this.pageState.value || qs.get('page'),
		rolodexIndex: this.rolodexState.value || qs.get('rolodexIndex')
	});
}

ListViewport.prototype.getReferences = function() {
	this.listViewport = document.getElementById(this.id + "_listViewport");
	this.filterLinks = document.getElementById(this.id + "_filterLinks");
	this.rolodex = document.getElementById(this.id + "_rolodex");
	this.listBody = document.getElementById(this.id + "_listBody");
	this.bottomNav = document.getElementById(this.id + "_bottomNav");
	this.listSelect = document.getElementById("listSelect");
	this.pageState = document.getElementById(this.id + "_pageState");
	this.rolodexState = document.getElementById(this.id + "_rolodexState");
	this.exception = document.getElementById(this.id + "_exception");
	this.buttons = document.getElementById(this.id + "_buttons");
	this.printLink = document.getElementById(this.id + "_printLink");
	this.offPageIds = document.getElementById(this.id + "_offPageIds");

	this.loading = new LoadingScreen(this.listBody, LC.getLabel('Global', 'loading'), this.id + "_loading");
	this.saving = new LoadingScreen(this.listBody, LC.getLabel('Buttons', 'saving'), this.id + "_saving");
}

ListViewport.prototype.initializeLinkTemplates = function() {
    this.linkTemplates = {
        newLink : new Ext.Template('<a href="/ui/list/FilterEditPage?ftype={filterType}&retURL=%2F{entityType}%3Ffcf%3D{filterId}">',
                           LC.getLabel("Filter", "new"),
                           '</a>').compile(),
        editLink : new Ext.Template('<a href="/ui/list/FilterEditPage?id={filterId}&retURL=%2F{entityType}%3Ffcf%3D{filterId}">',
                                    LC.getLabel("Filter", "edit"),
                                    '</a>').compile(),
        deleteLink : new Ext.Template('<a onclick="return confirm(\'',
                                      LC.getLabel("Filter","DeleteConfirm"),
                                      '\')" ',
                                      'href="/setup/own/deleteredirect.jsp?id={filterId}&delID={filterId}&retURL=%2F{entityType}">',
                                      LC.getLabel("Buttons", "del"),
                                      '</a>').compile(),
        refreshLink : new Ext.Template('<a id="{filterId}_refresh" href="javascript:{jsref}.refreshList()">',
        							   '<b>',LC.getLabel("Filter", "refresh"),'</b>',
        							   '</a>').compile()
    }
}

ListViewport.prototype.refreshList = function() {
    this.grid.getSelectionModel().clearAllSelections();
    this.refreshLink.style.backgroundColor = "";
    this.getListData({page: this.paginator.currentPage, rolodexIndex: this.rolodexIndex});
}

ListViewport.prototype.getListData = function(args) {
	this.resetTimer();
	this.loading.show();
    if (this.xhr) {
    	this.xhr.onreadystatechange = function() {};
    	this.xhr.abort();
    }
	
	var args = args || {};

	var post = {action : args["action"] || "filter",
				filterId : args["listid"] || (this.filter ? this.filter.id : this.id),
				filterType : this.filter ? this.filter.type : this.type,
				page : args["page"] || 1,
				rowsPerPage : (args["rowsPerPage"] != null) ? args["rowsPerPage"] : "",
				sort : (args["sort"] != null) ? args["sort"] : "",
				rolodexIndex : (args["rolodexIndex"] != null) ? args["rolodexIndex"] : -1
				};
				
	if (post.action == "newfilter") {
		this.filterLinks.innerHTML = "&nbsp;";
		this.buttons.innerHTML = "";
		this.rolodex.style.visibility = "hidden";
	}
    
	var self = this;
	this.xhr = XBrowser.postHttpResponse(this.url, function(response) {self.xhrHandler(response.responseText);}, XBrowser.buildPost(post));	
	this.timepoint("AJAX request issued");
	this.dumpObject(post);
}

ListViewport.prototype.xhrHandler = function(responseText) {
	this.timepoint("AJAX request returned");
	var ldata = Util.evalAjaxServletOutput(responseText);
	if (ldata.exTitle && ldata.exDesc) {
		this.handleException(ldata);
		return;
	}
	
    if (ldata.filter && ldata.inlineEditData) {
        this.loadFilter(ldata.filter, ldata.inlineEditData);
        this.timepoint("inline edit data loaded");
    }
	this.drawListData(ldata.listData, ldata.columnWidths);	

    this.updateFilterLinks();
    this.timepoint("updated filter links");
    this.updateButtons(ldata.buttons);
    this.timepoint("updated buttons");
    this.updatePrintLink(ldata.retURL);
    this.timepoint("updated print link");
    this.updateSortState(ldata.sortState);
    this.timepoint("updated sort state");
    this.updateRolodex(ldata.rolodexIndex, ldata.sortState);
    this.timepoint("updated rolodex");
    this.updatePaginator(ldata);
    this.timepoint("updated paginator");
	this.updateStateFields();
    this.timepoint("updated state fields");
	this.retURL = ldata.retURL;
	this.resize();	
	this.exception.style.display = "";
	this.loading.hide();
	this.xhr = null;
	this.timepoint("handling complete");
	this.outputTimes();
}

ListViewport.prototype.handleException = function(ldata) {
	var html = [];
	html.push("<div class='title'>");
	html.push(ldata.exTitle);
	html.push("</div>");
	html.push("<br/>");
	html.push(ldata.exDesc);
	this.exception.innerHTML = html.join('');
	this.exception.style.display = "block";

    this.filterLinks.style.display = "none";
	this.buttons.style.display = "none";
	if (this.printLink) {
		this.printLink.style.visibility = "hidden";
	}
    if (this.rolodex.style.visibility != "hidden") {
        this.rolodex.style.visibility = "hidden";
    }
	if (!this.paginator) {
		this.updatePaginator(ldata);
	}
	this.paginator.draw(true);
	this.loading.hide();
}

ListViewport.prototype.updateButtons = function(buttons) {
	this.buttons.innerHTML = buttons.join('');
	Util.evalScriptsUnderElement(this.buttons);
	this.buttons.style.display = "";
}

ListViewport.prototype.updatePrintLink = function(retURL) {
	if (!this.printLink) {
		return;
	}
	
	var pieces = retURL.split("?");
	var url = [];
	url.push("javascript:printWin('");
	url.push(pieces[0]);
	url.push("/x?");
	url.push(pieces[1]);
	url.push("')");
	
	this.printLink.href = url.join('');
	this.printLink.style.visibility = "";
}

ListViewport.prototype.updateStateFields = function() {
	this.pageState.value = this.paginator.currentPage;
	this.rolodexState.value = this.rolodexIndex;
}

ListViewport.prototype.updateFilterLinks = function() {
    var links = [];
    
    var p = {
        filterType: this.filter.type,
        entityType: this.filter.entityType,
        filterId:   this.filter.id,
        jsref:		"ListViewport.instances['"+this.id+"']"
    };

    if (this.filter.isCreateNewDisplayed) {
        links.push(this.linkTemplates.newLink.apply(p));
    }
    if (this.filter.editable) {
        links.push(this.linkTemplates.editLink.apply(p));
        links.push(this.linkTemplates.deleteLink.apply(p));
    }
    links.push(this.linkTemplates.refreshLink.apply(p));
    
    this.filterLinks.innerHTML = links.join(" | ");
    this.filterLinks.style.display = "";
    
    this.refreshLink = document.getElementById(this.filter.id + "_refresh");
}

ListViewport.prototype.updateSortState = function(state) {
   	var view = this.grid.getView();    
	view.sortState = state;
	var colIndex = this.grid.getColumnModel().findColumnIndex(state.field);
	if (colIndex != -1) {
        view.updateSortIcon(colIndex, state.dir);
	}
}

ListViewport.prototype.updateRolodex = function(index, state) {
    this.rolodexIndex = index;
    var entries = this.rolodex.childNodes;

    var cm = this.grid.getColumnModel();
    // should be able to get the column by dataIndex...
    var colIndex = cm.findColumnIndex(state.field);
    if (colIndex != -1 && cm.getColumnById(cm.getColumnId(colIndex)).useRolodex) {
        if (this.rolodex.style.visibility == "hidden") {
            this.rolodex.style.visibility = "";
        }
    } else {
        if (this.rolodex.style.visibility != "hidden") {
            this.rolodex.style.visibility = "hidden";
        }
    }
    
    for (var i=0; i < entries.length; i++) {
        if (i==index || (index==-1 && i==entries.length-1)) { // "All" is -1
            entries[i].firstChild.className = "listItemSelected";
        } else {
            entries[i].firstChild.className = "listItemPad";
        }
    }
}

ListViewport.prototype.updatePaginator = function(ldata) {
  	// update Paginator state
	if (!this.paginator) {
		// this must be our initial call to the first page
		var self = this;
		
		this.paginator = new ListPaginator({'listId': this.id,
											'containerIds':[this.id + '_bottomNav'],
											'recordsPerPage':ldata.rowsPerPage,
											'totalRecords':ldata.totalRowCount,
											'capped':ldata.capped,
											'currentPage':ldata.page,
											'handler': function(pageNum) {
															self.getListData({
																	'page': pageNum,
																	'rolodexIndex': self.rolodexIndex
																})
													   }
										   });
	} else {
		this.paginator.setState({'currentPage': ldata.page,
								 'recordsPerPage': ldata.rowsPerPage,
								 'totalRecords': ldata.totalRowCount,
								 'capped': ldata.capped
								});
	}
}

ListViewport.prototype.xhrErrorHandler = function(responseText) {
	// TODO
	// might not be necessary.  handle errors from the XHR
}

ListViewport.prototype.loadFilter = function(filter, inlineEditData) {
	this.filter = filter;
	inlineEditData.viewport = this;
	inlineEditData.shownColumns = filter.shownColumns;
	this.inlineEditData = new ListInlineEditData(inlineEditData);
}

ListViewport.prototype.drawListData = function(listData, columnWidths) {
	// take the list data and draw it.
	// "myX" are things that Ext eats.
    var idColumn = listData[ListView.ID_COLUMN];
    var actionColumn = listData[ListView.ACTION_COLUMN];
    var numRows = idColumn.length;

    var hasActions = false;

    // build datastore
    var myData = new Array(numRows);
    var cols = this.filter.shownColumns;
    for( var row = 0; row < myData.length; row++) {
        myData[row] = [];
        myData[row].push(idColumn[row]);
        if (actionColumn[row] != null) { hasActions = true; }
        myData[row].push(actionColumn[row]);
        for (var col = 0; col < cols.length; col++) {
        	myData[row].push(listData[cols[col].columnName][row]);
        }
    }
    this.timepoint("datastore prepared");

    // build fields and columns
    var hasCheckbox = this.filter.showCheckBox || this.inlineEditData.isMassEditable;
    var sm = hasCheckbox ? new Sfdc.grid.CheckboxSelectionModel({menuDisabled: true}) : new Sfdc.grid.RowSelectionModel({menuDisabled: true});
    var myFields = [];
    var myColumns = [];
    if (hasCheckbox) {
        myColumns.push(sm);
    }
    
    myFields.push({name: ListView.ID_COLUMN});
    myColumns.push({
        header: 'ID',
        hidden: true,
        dataIndex: ListView.ID_COLUMN,
        id: ListView.ID_COLUMN
    });
    
    myFields.push({name: ListView.ACTION_COLUMN});
    myColumns.push({
        header: LC.getLabel("Global", "action"),
        dataIndex: ListView.ACTION_COLUMN,
        id: ListView.ACTION_COLUMN,
        width: 1,
        hidden: !hasActions,
        menuDisabled: true,
        fixed: true,
        css: "font-weight: bold;",
        renderer: function(val) {return val ? val.join(" | ") : "";}
    });

    var colWidths = columnWidths || [];
    
    for (var i = 0; i < cols.length; i++) {
    	if (!colWidths[i]) colWidths[i] = ListViewport.DEFAULT_COLUMN_WIDTH;
    	// if there is a ListFilterColumn use it to get the id, otherwise just use the name
        var lfc = this.inlineEditData.getColumnById(cols[i].columnName);
        var id = lfc ? lfc.getFieldId() : cols[i].columnName;
    	myFields.push({name: cols[i].columnName});
    	myColumns.push({
    	    header: cols[i].label,
    	    width: colWidths[i],
    	    dataIndex: cols[i].columnName,
    	    id: id,
            menuDisabled: true,
    	    isSortable: cols[i].isSortable,
    	    useRolodex: cols[i].useRolodex,
    	    renderer: function(val) {return typeof val == "object" ? val[0] : val;}
    	});
    }
   	this.timepoint("fields and columns prepared");

	if (!this.grid) {
	    // initial page load
        var listeners = {};
        listeners.columnmove = { fn: this.extHandler.columnMove, scope: this};
        listeners.columnresize = { fn: this.extHandler.columnResize, scope: this};
        listeners.headerclick = { fn: this.extHandler.headerClick, scope: this};
        listeners.celldblclick = { fn: this.extHandler.cellDblClick, scope: this}
        listeners.cellmouseover = { fn: this.extHandler.cellMouseOver, scope: this}
        listeners.cellmouseout = { fn: this.extHandler.cellMouseOut, scope: this}

		this.grid = new Ext.grid.GridPanel({
            viewport: this, // maintaining a convenience reference to the viewport
            id: this.filter.id + '_grid',
            cm: new Ext.grid.ColumnModel(myColumns),
            sm: sm,
            store: new Ext.data.SimpleStore({
            	id: 0,
            	fields: myFields
            }),
            view: new Sfdc.grid.GridView({
                emptyText: LC.getLabel("List","none"),
                sortClasses: ["ASC", "DESC"]
            }),
	    	listeners: listeners,
	    	width: this.listBody.offsetWidth
	    });
        this.grid.addEvents("cellMouseOver", "cellMouseOut");
        this.timepoint("grid initialized");
	} else if ((this.filter.id + '_grid') != this.grid.id) {
	    // loading a new filter
	    this.grid.getSelectionModel().clearAllSelections();
	    
	    var store = new Ext.data.SimpleStore({
	        	id: 0,
				fields: myFields
	    	});
	    var columnModel = new Ext.grid.ColumnModel(myColumns);
	    this.grid.reconfigure(store, columnModel);
	    this.grid.id = this.filter.id + "_grid";
	    this.timepoint("grid reconfigured");
	}
	var view = this.grid.getView();
	
	this.grid.render(this.listBody.id);
	this.timepoint("grid rendered");
	this.grid.getStore().loadData(myData);
	this.timepoint("data loaded into grid");
	
	var cm = this.grid.getColumnModel();
    var actionIndex = cm.getIndexById(ListView.ACTION_COLUMN);
    this.grid.view.sizeColumnToContent(actionIndex);
    this.timepoint("action column sized");

	var cmTotalWidth = cm.getTotalWidth();
	this.timepoint("cm total width got");
	var gridInnerWidth = this.grid.getInnerWidth();
	this.timepoint("grid inner width got");

    if ((cmTotalWidth < gridInnerWidth) && !columnWidths) {
    	this.grid.view.fitColumns();
    	this.timepoint("columns fit");
    }

	// add cellmouseover, cellmouseout listeners
	this.grid.body.on("mouseover", function(e) {
	    this.grid.processEvent("mouseover", e);
	}, this);
	this.grid.body.on("mouseout", function(e) {
	    this.grid.processEvent("mouseout", e);
	}, this);
    this.timepoint("cell listeners added");
    
    if (numRows == 0) {
        // TODO: size the empty data grid to the column header so you can scroll to see the columns (bug #173195)
    }
}

ListViewport.prototype.resize = function() {
	var offProps =[];
	
	// NEW WIDTH
	var windowWidth = document.documentElement.clientWidth;	
	// take into account all horizontally relevant CSS properties
	offProps = [[document.getElementById('bodyCell'), 'paddingRight'],
				[this.listViewport, 'borderLeftWidth'],
				[this.listViewport, 'borderRightWidth']];
	var wOffset = 0;
	wOffset += getObjX(this.listViewport);
	for (var i=0; i<offProps.length; i++) {
		wOffset += parseInt(XBrowser.getCurrentStyle(offProps[i][0], offProps[i][1]));
	}
	var wNew = windowWidth - wOffset;

	// NEW HEIGHT
	var windowHeight = document.documentElement.clientHeight;
	// and also the vertically relevant CSS properties
	offProps = [[this.listBody, 'borderTopWidth'],
			   	[this.listViewport, 'borderBottomWidth']];
	var hOffset = 0;
	hOffset += getObjY(this.listBody);
	hOffset += this.bottomNav.offsetHeight;
	for (var i=0; i<offProps.length; i++) {
		hOffset += parseInt(XBrowser.getCurrentStyle(offProps[i][0], offProps[i][1]));
	}
	// Add a bottom buffer.  10px looks nice.
	hOffset += 10;
	var hNew = windowHeight - hOffset;

	var hNewVal = hNew + "px";
	this.timepoint("resize overhead");
	this.listBody.style.height = hNewVal;
	this.timepoint("listBody resized");
	this.exception.style.height = hNewVal;
	this.timepoint("exception resized");
	if (this.loading.transparantElement) {
		this.loading.transparantElement.style.height = hNewVal;
		this.timepoint("loading resized");
	}
	if (this.grid) {
	    this.grid.suspendEvents();
	    this.timepoint("suspended events");
		this.grid.setHeight(hNew);
		this.timepoint("grid height resized");
		this.grid.setWidth(wNew);
		this.timepoint("grid width resized");
	    this.grid.resumeEvents();
	    this.timepoint("resumed events");
	}
}

ListViewport.prototype.redefineSidebarPin = function() {
	var self = this;

	Sidebar.prototype.theSidebar.pin = function() {
		Sidebar.prototype.pin.apply(Sidebar.prototype.theSidebar);
		self.resize();
	};
}

ListViewport.prototype.beforeSave = function() {
    this.saving.show();
}

ListViewport.prototype.afterSave = function(saved, column) {
    if (saved && saved.length > 0) {
		this.refreshLink.style.backgroundColor = "#FFE324";

        var value = column.getDisplayValue();
        if (value === "") {
            value = "&nbsp;";
        }
        var fieldId = column.getFieldId();
        var composite = new Ext.CompositeElement();
        for (var i = 0; i < saved.length; i++) {
            var id = saved[i];
            var cell = Ext.get(saved[i] + "_" + fieldId);
            if (cell) {
                composite.add(cell.parent())
                cell.update(value);
            }
        }
        var color = this.grid.getSelectionModel().getCount() > 0 ? "#dfe8f6" : "#ffffff";
        composite.highlight("#ffffcc", {
            endColor: color,
            duration: 2.5,
            concurrent: true
        });
    }
    this.saving.hide();
}

// gets the columns in order, ignoring checkbox, id, and action columns
ListViewport.prototype.getFilterColumns = function() {
	return this.grid.getColumnModel().getColumnsBy(function(c,i) {return (c.id != "checkbox" && c.id != ListView.ID_COLUMN && c.id != ListView.ACTION_COLUMN)});
}
ListViewport.prototype.extHandler = {
	columnMove : function (oldIndex, newIndex) {
	    if (this.filter.id !== Udd.EMPTY_KEY) {
    		var colObjs = this.getFilterColumns();
    		var cols = [];
    		
    		for (var i=0; i < colObjs.length; i++) {		    
    		    cols.push(colObjs[i].dataIndex);
    		}
    		
    		var post = {action: "reorderColumns",
    					filterId : this.filter.id,
    					cols : cols};
    							
    		XBrowser.postHttpResponse(this.url, function(response) {}, XBrowser.buildPost(post));	
	    }
		var view = this.grid.getView();
		view.updateSortIcon(this.grid.getColumnModel().findColumnIndex(view.sortState.field), view.sortState.dir);
	},

	columnResize : function (colIndex, newsize) {
	    if (this.filter.id !== Udd.EMPTY_KEY) {
            var colObjs = this.getFilterColumns();
            var widths = []
            for (var i=0; i < colObjs.length; i++) {		    
                widths.push(colObjs[i].width);
            }
            
            var post = {action: "setColumnWidths",
            			filterId : this.filter.id,
            			widths: widths};
            
            XBrowser.postHttpResponse(this.url, function(response){}, XBrowser.buildPost(post));
	    }
	},

    cellDblClick : function (grid, rowIndex, columnIndex, event) {
        if (this.inlineEditData.isEditable) {
            var colId = grid.getColumnModel().getDataIndex(columnIndex);
            var column = this.inlineEditData.getColumnById(colId);
            if (column && column.state == InlineEditState.EDIT) {
                var sm = this.grid.getSelectionModel();
                if (sm.getCount() == 0 || sm.selectRow(rowIndex, this.inlineEditData.isMassEditable)) {
                    var row = this.grid.getStore().getAt(rowIndex);
                    var rowId = row.get(ListView.ID_COLUMN);
                    var initialValue = row.get(column.columnName);
                    this.inlineEditData.openColumn(rowId, colId, typeof initialValue == "object" ? initialValue[1] : null);
                }
            }
        }
	},

    cellMouseOver : function (grid, rowIndex, columnIndex, event) {
        if (this.inlineEditData.isEditable) {
            var column = this.inlineEditData.getColumnById(grid.getColumnModel().getDataIndex(columnIndex));
            if (column) {
                var css = column.state.cssClass;
                Ext.fly(this.grid.getView().getCell(rowIndex, columnIndex)).replaceClass(css, css + "On");
            }
        }
    },

    cellMouseOut : function (grid, rowIndex, columnIndex, event) {
        if (this.inlineEditData.isEditable) {
            var column = this.inlineEditData.getColumnById(grid.getColumnModel().getDataIndex(columnIndex));
            if (column) {
                var css = column.state.cssClass; 
                Ext.fly(this.grid.getView().getCell(rowIndex, columnIndex)).replaceClass(css + "On", css);
            }
        }
    },

	headerClick : function (grid, columnIndex) {
        var cm = grid.getColumnModel();
	    var column = cm.getColumnById(cm.getColumnId(columnIndex));
	    var view = grid.getView();	    
	    if (!column.isSortable || view.headersDisabled) {
	        return;
	    }
	    
        var field = column.dataIndex;	    

        if (field) {
            if (view.sortState.field == field && view.sortState.dir == "ASC") {
                this.getListData({
                	sort: "-"+field,
                	page: this.paginator.currentPage,
                	rolodexIndex: this.rolodexIndex
                });
                view.updateSortIcon(columnIndex, "DESC");
                view.sortState.dir = "DESC";
            } else {
                this.getListData({
                	sort: field,
                	page: this.paginator.currentPage,
                	rolodexIndex: (view.sortState.field == field) ? this.rolodexIndex : -1
                });
                view.updateSortIcon(columnIndex, "ASC");
                view.sortState = {field: field, dir: "ASC"};
            }
        }
	}
}

ListViewport.prototype.verify = function(errorMessage) {
    if (this.grid.getSelectionModel().selections.length > 0) {
        return true;
    } else {
        alert(errorMessage);
        return false;
    }
}

ListViewport.instances = {};

ListViewport.addListViewport = function(what) {
	ListViewport.instances[what.id] = what;
}

//#depend common.page.DetailPage
/*
 * @author mpolcari, agusev
 * @since 142.ml, 146
 * Paging for search components
 *
 */


// how long to pause between update requests
SearchHistory.TIMEOUT = 1000;
// how many request are needed to increase timeout between requests
SearchHistory.TIMEOUT_STEP = 5;

function SearchPage() {
    this.openComponent = null;
    this.dhtmlHistory = null;
    this.historyCounter = 0;
    this.historyPrefix = 'hst';
    // map for all history objects
    this.historyStorage = new Object();
    this.actionIdStorage = new Object();
    this.duelingBoxRef = {};

    var self = this;

    this.closeOpenedComponent = function (e) {
        if(self.openComponent){
            var element = document.getElementById(self.openComponent);
            if(element){
                element.style.display = 'none';
                self.openComponent = null;
            }
        }
    }
}

SearchPage.prototype = new DetailPage();

SearchPage.prototype.wrapDhtmlWaitingRequest = function (actionUrl, currentUrl, listUrl, listQS, listId, description, addAdditionalParams){
    var identifier = this.createIdentifier();
    if(!this.hook_shouldProceedWithAction()){
        return;
    }
    this.processAction(listId, description, identifier);
    listUrl = this.addActionIdentifier(listUrl, identifier);
    if(addAdditionalParams) {
        listUrl = this.addAdditionalParams(listUrl);
    }
    this.callRelatedListActionAndSaveHistory(actionUrl, currentUrl, listUrl, listQS, listId);
}

SearchPage.prototype.hook_shouldProceedWithAction = function(){
    return true;
}

/**
 * allows to specify additional params
 */
SearchPage.prototype.addAdditionalParams = function (listUrl) {
    return listUrl;
}

SearchPage.prototype.addActionIdentifier = function(listUrl, identifier) {
    if(listUrl){
        var parts = listUrl.split('?');
        var qs = (parts.length>1) ? parts[1] : "";
        var listQs = new QueryString(qs, true);
        // since we are using multiple param mode we have to remove exising identifier
        listQs.remove(SearchRelatedList.SEARCH_ACTION_IDENTIFIER_PARAM);
        listQs.add(SearchRelatedList.SEARCH_ACTION_IDENTIFIER_PARAM, identifier);
        var newListQs = listQs.toString();
        return parts[0] + newListQs;
    }
    return listUrl;
}

SearchPage.prototype.createIdentifier = function(){
    return "_" + new Date().getTime();
}

SearchPage.prototype.checkActionCanceled = function(doc, listId) {
    var retVal = false;
    var identifierElement = getElementByIdCSWithDoc(doc,SearchRelatedList.SEARCH_ACTION_IDENTIFIER_PARAM + listId);
    if(identifierElement){
        var identifier = identifierElement.innerHTML;
        retVal = identifier in this.actionIdStorage;
        if(retVal){
            delete this.actionIdStorage[identifier];
        }
    }
    this.clearVariablesOnActionLoad();
    return retVal;

}

SearchPage.prototype.clearVariablesOnActionLoad = function () {
}

SearchPage.prototype.registerOpenComponent = function (idOfComponent){
    this.openComponent = idOfComponent;
}

SearchPage.prototype.searchEntity = function(isAll,searchEntity) {
    var elems = document.getElementsByName(searchEntity);
    if(!elems) return;
    for (i=0; i < elems.length; ++i) {
        elems[i].checked = isAll;
    }
}

SearchPage.prototype.checkEntitySelection = function(formElement,searchEntity) {
    var elems = document.getElementsByName(searchEntity);
    if(!elems) return;
    var checkedArrayValues = new Array();
    var counterUnchecked = 0;
    for (i=0; i < elems.length; i++) {
        // make sure we are using valid element
        if(!elems[i].type || elems[i].type != 'checkbox' || !elems[i].value){
            continue;
        }

        if(elems[i].checked){
            checkedArrayValues.push(elems[i].value);
        } else {
            counterUnchecked++;
        }
    }

    // if no entities are selected selet all
    if(checkedArrayValues.length == 0){
        for (i=0; i < elems.length; i++) {
            elems[i].checked = true;
        }
    }

    // now change the target of the form
    if (checkedArrayValues.length == 0 || counterUnchecked == 0){
        var inputElement = document.createElement('input');
        inputElement.type = 'hidden';
        inputElement.name = searchEntity;
        inputElement.value = SearchRelatedList.pENTITY_ALL;
        formElement.appendChild(inputElement);
    } else {
        for (i=0; i < checkedArrayValues.length; i++) {
            var inputElement = document.createElement('input');
            inputElement.type = 'hidden';
            inputElement.name = searchEntity;
            inputElement.value = checkedArrayValues[i];
            formElement.appendChild(inputElement);
        }
    }
}

// this is used to capture enter events for BooleanInputElements
// and thus does not need to handle Japanese Hiragana input sequences
SearchPage.prototype.submitSearchForm = function (event, formId){
    if(formId){
        var form = document.getElementById(formId);
        if(form){
            var keynum = this.getKeyNumForEvent(event);
            if(keynum && keynum ==  KEY_ENTER){
                if(form.onsubmit) {
                    form.onsubmit();
                }
                form.submit();
            }
        }
    }
}


SearchPage.prototype.getKeyNumForEvent = function (event){
    var evt = getEvent(event);
    if(!evt){
        return;
    }
    var keynum;

    // IE
    if(window.event) {
        keynum = evt.keyCode;
    }

    // Firefox
    else if(evt.which) {
        keynum = evt.which;
    }
    return keynum;
}


/**
 * Set the dueling list reference for the given related list
 */
SearchPage.prototype.setDlbeRef = function (relList, dlbeRef) {
    if (dlbeRef) {
        this.duelingBoxRef[relList] = dlbeRef;
    }
}

SearchPage.prototype.toggleSearchElement = function (idOfComponent, listId, shouldRegister, displayType){

    var self = this;
    function handleKeyUp (e){
        var keynum = self.getKeyNumForEvent(e);
        if(keynum && keynum ==  KEY_ESC && shouldRegister){
            self.closeOpenedComponent();
            if (self.duelingBoxRef) {
                if (self.duelingBoxRef[listId]) {
                    self.duelingBoxRef[listId].resetSelection();
                    self.duelingBoxRef[listId].quickUnwarn();
                }
            }
        }
    }

    // default to block display type
    if(!displayType) {
        displayType = "block";
    }

    var element = document.getElementById(idOfComponent);

    if (element) {
        if(element.onkeyup == null){
            element.onkeyup = handleKeyUp;
        }
        if(idOfComponent != this.openComponent){
            this.closeOpenedComponent();
        }
        if (element.style.display == 'none') {
            element.style.display = displayType;
            var focusObjects = element.getElementsByTagName('input');
            if(focusObjects && focusObjects.length > 0){
                focusObjects[0].focus();
            }
            if(shouldRegister){
                this.registerOpenComponent(idOfComponent);
            }
        } else {
            element.style.display = 'none';
        }
    }

    // window. this reference is used for
    if (this.duelingBoxRef) {
        if (this.duelingBoxRef[listId]) {
            this.duelingBoxRef[listId].resetSelection();
            this.duelingBoxRef[listId].quickUnwarn();
        }
    }
}

SearchPage.prototype.processAction = function(listId, description, identifier, notCancelable){

    var listSection = document.getElementById(listId);

    if (!listSection) {
        return;
    }

    var dataSection = getElementsByClassName("pbBody", listSection, "div");
    var headerSection = this.getControlHeadersForCover(listSection);

    if(!(dataSection && dataSection[0] && headerSection)){
        return
    }
    dataSection[0].style.position = "relative";
    for (i=0; i < headerSection.length; ++i) {
        if(headerSection[i]) {
            headerSection[i].style.position = "relative";
        }
    }

    var opacityElement = this.createLoadingElement(dataSection[0]);
    opacityElement.className = 'waitingSearchDiv waitingSearchDivOpacity';
    var clearElement = this.createLoadingElement(dataSection[0]);
    clearElement.className = 'waitingSearchDiv';
    if(!description) {
        description = LC.getLabel("Page_SearchResult", "dhtmlLoading");
    }

    // add control covering element
    var controlCover = new Array();
    for (i=0; i < headerSection.length; ++i) {
        if (headerSection[i]) {
            controlCover[i] = document.createElement('div');
            headerSection[i].appendChild(controlCover[i]);
            controlCover[i].style.height = headerSection[i].clientHeight + "px";
            controlCover[i].style.width = headerSection[i].clientWidth + "px";
            controlCover[i].className = 'waitingHeaderSearchDiv';
        }
    }

    var waitingInformationElement = this.addLoadingDescription(description, clearElement);


    // always create cancel call to allow for canceling in case of error
    var storageVariable = this.actionIdStorage;
    var cancelCall = function() {
        for (i=0; i < headerSection.length; ++i) {
            if (headerSection[i]) {
                headerSection[i].removeChild(controlCover[i]);
            }
        }
        dataSection[0].removeChild(opacityElement);
        dataSection[0].removeChild(clearElement);
        if(identifier){
            storageVariable[identifier] = identifier;
        }
    }

    // add cancel button
    if(!notCancelable) {
        var cancelButton = document.createElement('input');

        cancelButton.title = LC.getLabel("Global","cancel");
        cancelButton.className = 'waitingCancel';
        cancelButton.type = "button";
        waitingInformationElement.appendChild(cancelButton);
        // register canceled event and remove div

        cancelButton.onclick = cancelCall;
        // fixes IE memory leak
        cancelButton = null;
    }
    this.hook_saveCancelCall(listId, cancelCall);
}

// allows subclasses to process canelc function
SearchPage.prototype.hook_saveCancelCall = function(listId, cancelCall) {

}

SearchPage.prototype.getControlHeadersForCover = function(listSection) {
    return getElementsByClassName("pbHeader", listSection, "div");
}

SearchPage.prototype.createLoadingElement = function(dataElement){

        // create loading element
        var loadingElement = document.createElement('div');
        dataElement.appendChild(loadingElement);
        var height = this.getHeightForLoadingElement(dataElement);
        loadingElement.style.width = this.getWidthForLoadingElement(dataElement);
        loadingElement.style.height = height;

        return loadingElement;
}

SearchPage.prototype.isTagBrowser = function (dataElement){
    // tag browser body id on search page starts with TAG_RESULTS_BODY_ID
    return dataElement.id && dataElement.id.indexOf(TagConstants.TAG_RESULTS_BODY_ID) == 0;
}


SearchPage.prototype.getHeightForLoadingElement = function (dataElement) {
    if(this.isTagBrowser(dataElement)) {
        return this.getHeightForLoadingElementTag(dataElement);
    } else {
        return this.getHeightForLoadingElementNonTag(dataElement);
    }
}

SearchPage.prototype.getWidthForLoadingElement = function (dataElement){
    if(this.isTagBrowser(dataElement)) {
        return this.getWidthForLoadingElementTag(dataElement);
    } else {
        return this.getWidthForLoadingElementNonTag(dataElement);
    }
}

SearchPage.prototype.getHeightForLoadingElementTag = function (dataElement){
    var borderOffset = -4;
    return dataElement.scrollHeight + borderOffset + "px";
}

SearchPage.prototype.getWidthForLoadingElementTag = function (dataElement){
    var borderOffset = -4;
    return dataElement.scrollWidth  + borderOffset + "px";
}


SearchPage.prototype.getHeightForLoadingElementNonTag = function (dataElement){
    var height = dataElement.offsetHeight + 5;
    if(XBrowser.userAgent.isIE){
        height = dataElement.offsetHeight;
    }
    return height + "px";
}

SearchPage.prototype.getWidthForLoadingElementNonTag = function (dataElement){
    return dataElement.offsetWidth + "px";
}



SearchPage.prototype.addLoadingDescription = function(description, element){

    var newWaitingHolder = document.createElement('span');
    element.appendChild(newWaitingHolder);
    newWaitingHolder.className = 'waitingSearchHolder';
    var limitedOffset = (element.offsetHeight)/5;
    if (limitedOffset > 100){
        limitedOffset = 100;
    }
    newWaitingHolder.style.top =  limitedOffset + "px";

    var newWaitingImage = document.createElement('img');
    newWaitingHolder.appendChild(newWaitingImage);
    newWaitingImage.src = '/img/loading.gif';
    newWaitingImage.className  = 'waitingImage';

    var newWaitingDescription = document.createElement('span');
    newWaitingHolder.appendChild(newWaitingDescription);
    newWaitingDescription.innerHTML =  description;
    newWaitingDescription.className  = 'waitingDescription';

    return newWaitingHolder;
}

SearchPage.prototype.savePerEntityEnum = function(entityParam, valueParam){
        var url = "/setup/search/" + SearchRelatedList.SearchFilterInfoServletName + "?timeStamp=" + new Date().getTime();
        var queryString = new QueryString("");
        // if entity is null we'll update user preference for all entities
        if (entityParam){
            queryString.add(SearchRelatedList.ENTITY_PARAMETER , entityParam);
        }
        queryString.add(SearchRelatedList.PER_ENTITY_VALUE , valueParam);
        var queryString = queryString.toString();
        XBrowser.postHttpResponse(url, handler, queryString.substring(1, queryString.length));
        function handler(reponseText) { }
}

SearchPage.prototype.saveSearchColumnSelection = function (idOfSelectedColumns, entityName, layoutType, actionUrl, currentUrl, listUrl, listQS, listId){
        if(!this.hook_shouldProceedWithAction()){
            return;
        }
        var identifier = this.createIdentifier();
        this.processAction(listId, LC.getLabel("Page_SearchResult","dhtmlCustomizing"), identifier);

        var selectElement = document.getElementById(idOfSelectedColumns);
        if(!selectElement){
            return;
        }
        var selectedElements = "";
        for(var ind = 0; ind<selectElement.options.length;ind++){
                selectedElements = selectedElements + selectElement.options[ind].value + ",";
        }
        var url = "/setup/search/" + SearchRelatedList.SearchUserLayoutServletName + "?timeStamp=" + new Date().getTime();
        var queryString = new QueryString("");
        queryString.add(SearchRelatedList.COLUMN_PARAMETER , selectedElements);
        queryString.add(SearchRelatedList.ENTITY_PARAMETER , entityName);
        queryString.add(SearchRelatedList.LIST_LAYOUT_TYPE_PARAMETER , layoutType);
        queryString = queryString.toString();
        XBrowser.postHttpResponse(url, handler, queryString.substring(1, queryString.length));
        listUrl = this.addActionIdentifier(listUrl, identifier);
        function handler(reponseText){
            callRelatedListAction(actionUrl, listUrl, listQS, listId, true);
        }
}

SearchPage.prototype.filterResults = function (fieldNames, actionUrl, currentUrl, listUrl, listQS, listId) {
        if(!this.hook_shouldProceedWithAction()){
            return;
        }
        var identifier = this.createIdentifier();
        this.processAction(listId,LC.getLabel("Page_SearchResult","dhtmlFiltering"), identifier);
        var allFields = fieldNames.split(',');
        var selectedElements = "";
        var fieldList = "";
        for(var i = 0; i<allFields.length;i++){
            var field = allFields[i];
            if(field==""){
                continue;
            }
            var fieldElement = document.getElementById(field);
            if(!fieldElement){
                continue;
            }
            var value = fieldElement.value;
            if (value && value != ""){
                selectedElements = selectedElements + "&" + field + "=" + this.encodeForSearch(value);
                fieldList = fieldList + field + ",";
            }
        }
        var newUrl = listUrl;
          if (selectedElements != ""){
               newUrl = newUrl + selectedElements + "&" + SearchRelatedList.FILTER_FIELDS_PARAM + "=" + fieldList;
               newUrl = newUrl + "&" + SearchRelatedList.ShouldNotLookUp + "=" + true;
           }
          newUrl = this.addActionIdentifier(newUrl, identifier);
          this.callRelatedListActionAndSaveHistory(actionUrl, currentUrl, newUrl, listQS, listId);
}

SearchPage.prototype.encodeForSearch = function(initialString){
    var encodedValue;
    if(window.encodeURIComponent){
        encodedValue = encodeURIComponent(initialString);
    }else{
        encodedValue = escape(initialString);
    }
    return encodedValue;
}

SearchPage.prototype.decodeForSearch = function(encodedString) {
    if(!encodedString){
        return encodedString;
    }

    var decodedValue;
    if(window.encodeURIComponent){
        decodedValue = decodeURIComponent(encodedString);
    }else{
        decodedValue = unescape(encodedString);
    }
    return decodedValue;
}

SearchPage.prototype.toggleAllFilterInfoElement = function(elementClass){
    // this is little slow but should be only called once per user
    var elements = getElementsByClassName(elementClass, document.body, "div");

    if(!elements){
        return;
    }
    for(var i = 0; i<elements.length;i++){
        elements[i].style.display = "none";
    }
    if (Sidebar.prototype.theSidebar) {
        // since we may hide significant number of filter field infos we should resize the sidebar
        Sidebar.prototype.theSidebar.sizeToBody();
        Sidebar.prototype.theSidebar.sizeBodyToSidebarNoCheck();
    }
}

SearchPage.prototype.callRelatedListActionAndSaveHistory = function(actionUrl, currentUrl, newUrl, listQS, listId) {


    var self = this;
    function onSuccessCallback() {
        // initialize lazily
        if(!self.dhtmlHistory) {
            self.dhtmlHistory = new DhtmlHistory(self.historyStorage, self.historyChange, self);
        }

        // if this is first paging request or we're switching related list more than one object needs to be stored
        var optionalStorageHash;
        var currentHash = self.dhtmlHistory.getCurrentLocation();
        if(currentHash){
            var currentData = self.historyStorage[currentHash];
            // we're switching related list requests
            if(currentData && currentData.listId != listId){
                optionalStorageHash = self.historyPrefix + self.historyCounter;
                self.historyCounter = self.historyCounter + 1;
            }
        }

        // if we haven't assigned optionalStorageHash yet, check the first load case
        if(self.historyCounter == 0 && !optionalStorageHash){
            optionalStorageHash = self.historyPrefix + self.historyCounter;
            self.historyCounter = self.historyCounter + 1;
        }

        // store current state if this is first request or previous request was on different related list
        // if request was on different related list we're actually going to replace current hash with new data object
        if(optionalStorageHash){
            var dataObject = new SearchHistory();
            dataObject.setActionUrl(actionUrl);
            dataObject.setListUrl(currentUrl);
            dataObject.setListQs(listQS);
            dataObject.setListId(listId);
            self.dhtmlHistory.add(optionalStorageHash, dataObject);
            self.saveStateToInput(optionalStorageHash, dataObject);
        }

        var dataObject = new SearchHistory();
        dataObject.setActionUrl(actionUrl);
        dataObject.setListUrl(newUrl);
        dataObject.setListQs(listQS);
        dataObject.setListId(listId);

        self.dhtmlHistory.add(self.historyPrefix + self.historyCounter, dataObject);
        self.saveStateToInput(self.historyPrefix + self.historyCounter, dataObject);
        self.updateLastListState(actionUrl, newUrl, listQS, listId);
        self.historyCounter = self.historyCounter + 1;
    }

    callRelatedListAction(actionUrl, newUrl, listQS, listId, true, onSuccessCallback);
}

/*
 * This will be called to populate entire history state when pahe loads
 * the population occurs from input field which should have no information
 * unless the state has been saved and navigated to using the back button
 */
SearchPage.prototype.loadStateFromInput = function() {
    // most browsers don't respect hash history so load this only fot firefox
    if(!XBrowser.userAgent.isFirefox) { return; }
    this.allHistoryStorage = document.getElementById(SearchRelatedList.ALL_STATES_PREFIX + this.currentSearchId)
    if(!this.allHistoryStorage){ return; }
    var input = this.allHistoryStorage.value;
    if(!input || input.length == 0) { return; }

    var qs = new QueryString(input);
    for (var loc in qs.params) {
        var dataObject = new SearchHistory();
        dataObject.readFromQs(new QueryString(SearchPage.prototype.decodeForSearch(qs.get(loc))));
          this.historyStorage[loc] =  dataObject;
          // we need to increment counter for every new location processed
          this.historyCounter = this.historyCounter + 1;
    }
    // initialize lazily only when we have loaded content
    if(this.historyCounter > 0 && !this.dhtmlHistory) {
        this.dhtmlHistory = new DhtmlHistory(this.historyStorage, this.historyChange, this);
    }
}

/*
 * Encodes the state in js memory to input field
 */
SearchPage.prototype.saveStateToInput = function(loc, object) {
    if(!XBrowser.userAgent.isFirefox || !this.allHistoryStorage || !object || !loc){
        return;
    }

    var qs = new QueryString("");
      qs.add(loc, SearchPage.prototype.encodeForSearch(object.toString()));

    var queryString = qs.toString();

    this.allHistoryStorage.value  = this.allHistoryStorage.value + queryString.substring(1, queryString.length);
}

SearchPage.prototype.historyChange = function(oldLocation, newLocation) {
    if(!this.hook_shouldProceedWithAction()){
        return;
    }

    if(newLocation && this.historyStorage[newLocation]) {
        var historyData =  this.historyStorage[newLocation];

        // first determine if we're switching related list and we need to do one extra action
        if(oldLocation && this.historyStorage[oldLocation]) {
            // make those numbers instead of strings
            if(!window.parseInt) { return; }
            var oldNumber = parseInt(oldLocation.substring(3, oldLocation.length));
            var newNumber = parseInt(newLocation.substring(3, oldLocation.length));
            var oldRelatedListId = this.historyStorage[oldLocation].getListId();
            var newRelatedListId = historyData.getListId();
            // when we take extra action we just exit the method and let caller catch event and enter this function again
            if(oldRelatedListId != newRelatedListId) {
                if(oldNumber > newNumber){
                    window.history.go(-1);
                    return;
                } else if (oldNumber < newNumber){
                    window.history.go(1);
                    return;
                }
            }
        }
        // if old location is null we are moving from initial state to 0th state so there is no need to reload
        // as these states should be the same
        if (oldLocation) {
            // now dispatch rl to new page
            var identifier = this.createIdentifier();
            this.processAction(historyData.listId, null, identifier);
            var listUrl = this.addActionIdentifier(historyData.getListUrl(), identifier);
            var self = this;
             function onSuccessCallback() {
                 self.updateLastListState(historyData.getActionUrl(), listUrl, historyData.getListQs(), historyData.getListId());
             }
             callRelatedListAction(historyData.getActionUrl(), listUrl, historyData.getListQs(), historyData.getListId(), true, onSuccessCallback);
        }


    }
    // else we're on the initial load page
}

/**
 * This will be called on navigation back event from
 * another page - it can be used to update state variables based on listUrl
 */
SearchPage.prototype.hook_updatedStateOnLoad = function(listUrl, listId) {}

SearchPage.prototype.setCookieFormState = function(listId, entityName, prefName){
    var currentCookie = getCookie(prefName);
    var tempQs;
    if(currentCookie){
        tempQs = new QueryString(currentCookie);
    }else{
        tempQs = new QueryString("");
    }

    var filterForm = document.getElementById(SearchRelatedList.FILTER_FIELDS_PREFIX + listId);
    if(filterForm){
        // since this is called before the filter form changes its state we set the bit
        // to be the opposite of what it currently is
        if (filterForm.style.display == "none") {
            tempQs.add(entityName, "1");
        } else {
            tempQs.add(entityName, "0");
        }
    }
    var now = new Date();
    // 120 minutes
    now.setTime(now.getTime() + (120*60*1000));
    var qsString = tempQs.toString();
    setCookie(prefName, qsString.substring(1, qsString.length), now, null);
}


SearchPage.prototype.onLoadUpdateState = function() {

    // try initializing search state
    var sIdElement = document.getElementById(SearchRelatedList.SEARCH_IDENTIFIER_PARAM);
    this.currentSearchId = sIdElement ? sIdElement.innerHTML: null;
    // we can not use saved history without specific search id
    if(!this.currentSearchId){
        return;
    }

    // initialize existing history
    this.loadStateFromInput();

    // get registry
    var registryInput = document.getElementById(this.currentSearchId);

    var allStates;
    // parse registry cookie
    if (registryInput && registryInput.value) {
        allStates  = this.decodeForSearch(registryInput.value).split(',');
    } else {
        return;
    }

    // go through existing states and make calls to update the state
    var requestTimeout = 0;
    var actualTimeout = SearchHistory.TIMEOUT;
    // look at the states from the end of array since newest updates are stored there
    var counter = 0;
    for(var i = allStates.length - 1; i >= 0; i--) {
        var stateListId = allStates[i];
        if(!stateListId || stateListId==""){
            continue;
        }
        var list = document.getElementById(stateListId);
        if(!list){
            // if list doesn't exist there is nothing to update
            continue;
        }
        // now get the list state from cookie
        var listStateInput = document.getElementById(this.currentSearchId + stateListId);

        if(listStateInput && listStateInput.value) {
            // parse the state
            var dataObject = new SearchHistory();
            dataObject.readFromQs(new QueryString(listStateInput.value));
            if(dataObject.getListUrl()) {
                var identifier = this.createIdentifier();
                var listUrl = this.addActionIdentifier(dataObject.getListUrl(), identifier);
                // use url and id to update state variables on the page
                this.hook_updatedStateOnLoad(listUrl, dataObject.getListId());
                // don't need to add browser history for these calls
                var callString = "callRelatedListAction(" + this.buildParam(dataObject.getActionUrl())
                                + this.buildParam(listUrl) + this.buildParam(dataObject.getListQs())
                                + this.buildParam(dataObject.getListId()) + "true);";
                // add timeouts between requests
                window.setTimeout(callString, requestTimeout);
                counter++;
                // for every SearchHistory.TIMEOUT_STEP request add standard timeout to actual timeout
                if(counter > 0 && counter % SearchHistory.TIMEOUT_STEP == 0){
                    actualTimeout+= SearchHistory.TIMEOUT;
                }
                requestTimeout+= actualTimeout;
                this.processAction(dataObject.getListId(), null, identifier);
            }

        }
    }
}

SearchPage.prototype.buildParam = function(parameter, isLast) {
    var retVal;
    if (parameter){
        retVal = "'" + parameter + "'";
    } else {
        retVal =  "null";
    }
    retVal+= ","
    return retVal;
}

SearchPage.prototype.updateLastListState = function(actionUrl, newUrl, listQS, listId) {

    // we can not used saved history without specific search id
    if(!this.currentSearchId){ return;}

    // get registry
    var registryInput = document.getElementById(this.currentSearchId);
    if(!registryInput) { return;}

    // get current state
    var listStateInput = document.getElementById(this.currentSearchId + listId);
    if(!listStateInput) { return;}

    var allStates;
    if (registryInput.value) {
        allStates  = this.decodeForSearch(registryInput.value).split(',');
    } else {
        allStates = new Array();
    }

    // assemble registry string
    var newListOfStates = "";
    // add existing states
    for(var i = 0; i < allStates.length; i++){
            var stateListId = allStates[i];
            if(!stateListId || stateListId == "" || listId == stateListId) {
                continue;
            }
            newListOfStates = newListOfStates + stateListId + ",";
    }
    // add new state
    newListOfStates = newListOfStates + listId;
    registryInput.value = this.encodeForSearch(newListOfStates);

    // now actually write new state for list
    var dataObject = new SearchHistory();
    if (actionUrl) {
        dataObject.setActionUrl(actionUrl);
    }
    if (newUrl) {
        dataObject.setListUrl(newUrl);
    }
    if (listQS) {
        dataObject.setListQs(listQS);
    }
    if (listId) {
        dataObject.setListId(listId);
    }
    listStateInput.value = dataObject.toString();
}

/**
 * Initializes JS behavior for the given related list.
 *
 * @param String rellistId DOM id of the related list
 */
SearchPage.prototype.addCloser = function(rellistId) {
    // Add event to the customize button to close column selection overlay
    var customizediv = document.getElementById(SearchRelatedList.COMBO_BUTTON_ID+rellistId);
    if (customizediv) {
        addEvent(customizediv, 'click', this.closeOpenedComponent, false);
    }
};

SearchPage.prototype.addUnloadClearState = function() {
    if (XBrowser.userAgent.isIE) {
        if (this.dhtmlHistory) {
            this.dhtmlHistory.iframe = null;
            this.dhtmlHistory.parentObject = null;
            this.dhtmlHistory.listener = null;
            this.dhtmlHistory.historyStorage = null;
        }
        this.dhtmlHistory = null;

        this.openComponent = null;
        this.historyCounter = null;
        this.historyPrefix = null;
        this.historyStorage = null;
        this.actionIdStorage = null;
        this.duelingBoxRef = null;
    }
}
//#depend DetailPage
/*
* @author mpolcari
* @since 144
*/
function PrintableViewPage() {}

PrintableViewPage.prototype = new DetailPage();

PrintableViewPage.prototype.getEntityId = function() {
  var href = window.location.href;
  var paths = href.split('?')[0].split('/');
  return paths[paths.length-2];
}

//#depend TagAutoComplete
//  Classes to support the tag header in detail pages.
//

var TagHeader = function() {}

// STATIC CONSTANTS
TagHeader.MAX_TAG_LIST_CHARS = 80;
TagHeader.LINE_HEIGHT = 1.3;
TagHeader.LINE_HEIGHT_UNITS = 'em';

TagHeader.init = function(id, desktopParam) {
    this.id = id;
    this.desktopParam = desktopParam;

    // The edit text changes from add to edit and clickable to unclickable
    this.editTagsText = document.getElementById(TagConstants.TAG_EDIT_TEXT_ID);

    // If the dom elements didn't get properly set up by the server, we'll
    // gack and give up processing tags
    if (this.editTagsText == null) {
        Gack.logJSError('Tag header dom elements did not get properly set up by the server.');
        return;
    }

    // These are used for showing the drop down and handling its functionality
    this.dropDown = document.getElementById(TagConstants.TAG_DROP_DOWN_ID);
    this.dropDownContents = document.getElementById(TagConstants.TAG_DROP_DOWN_CONTENTS_ID);
    this.tagEditArea = document.getElementById(TagMode.PERSONAL + TagConstants.EDIT_AREA_ID);
    this.pubTagEditArea = document.getElementById(TagMode.PUBLIC + TagConstants.EDIT_AREA_ID);
    this.tagDisplayList = document.getElementById(TagMode.PERSONAL + TagConstants.TAG_DISPLAY_LIST);
    this.pubTagDisplayList = document.getElementById(TagMode.PUBLIC + TagConstants.TAG_DISPLAY_LIST);
    this.tagEditList = document.getElementById(TagMode.PERSONAL + TagConstants.TAG_EDIT_LIST);
    this.pubTagEditList = document.getElementById(TagMode.PUBLIC + TagConstants.TAG_EDIT_LIST);

    this.hiddenTagList = document.getElementById(TagMode.PERSONAL + TagConstants.HIDDEN_TAG_LIST);
    this.hiddenTagIdList = document.getElementById(TagMode.PERSONAL + TagConstants.HIDDEN_TAG_ID_LIST);
    this.hiddenPubTagList = document.getElementById(TagMode.PUBLIC + TagConstants.HIDDEN_TAG_LIST);
    this.hiddenPubTagIdList = document.getElementById(TagMode.PUBLIC + TagConstants.HIDDEN_TAG_ID_LIST);

    // The hidden list will contain the tag state that was last set on this page.
    // Either via initial rendering or subsequent editing.
    this.tags = this.getTags(this.hiddenTagList);
    this.tagIds = this.getTags(this.hiddenTagIdList);
    this.pubTags = this.getTags(this.hiddenPubTagList);
    this.pubTagIds = this.getTags(this.hiddenPubTagIdList);

    this.display();

    // Tag header is hidden when the page is first loaded.
    this.tagHeader = document.getElementById(TagConstants.TAG_HEADER);
    this.tagHeader.style.display = "block";

    this.loading = new LoadingScreen(this.dropDown, LC.getLabel("TagHeader", "saving"));

    // For auto-resize
    if (this.tagEditArea) this.tagEditArea.textLines = 1;
    if (this.pubTagEditArea) this.pubTagEditArea.textLines = 1;

    // Now set up the clickable areas
    this.editTags = document.getElementById(TagConstants.TAG_EDIT_ID);
    this.tagSaveBtn = document.getElementById(TagConstants.TAG_SAVE_ID);
    this.tagCancelBtn = document.getElementById(TagConstants.TAG_CANCEL_ID);

    var self = this;
    addEvent(this.editTags, 'click', function() {self.openDropDown()}, false);
    addEvent(this.tagSaveBtn, 'click', function() {self.save()}, false);
    addEvent(this.tagCancelBtn, 'click', function() {self.cancel()}, false);
    if (this.tagEditArea != null) {
        this.autoCompleter = new TagAutoComplete(this.tagEditArea, TagMode.PERSONAL, function(e) {self.keyPress(e)});
        this.autoCompleter.setResizer(function() { return self.checkAndResize(self.tagEditArea); });
    }
    if (this.pubTagEditArea != null) {
        this.pubAutoCompleter = new TagAutoComplete(this.pubTagEditArea, TagMode.PUBLIC, function(e) {self.keyPress(e)});
        this.pubAutoCompleter.setResizer(function() { return self.checkAndResize(self.pubTagEditArea); });
    }
}

TagHeader.display = function() {
    var charCount = 0;
    charCount = this.setupDisplayList(this.tagDisplayList, this.tags, this.tagIds, TagMode.PERSONAL, charCount);
    this.setupDisplayList(this.pubTagDisplayList, this.pubTags, this.pubTagIds, TagMode.PUBLIC, charCount);

    if (this.tags.length == 0 && this.pubTags.length == 0) {
        this.editTagsText.innerHTML = LC.getLabel('TagHeader', 'add_tags');
        this.editTagsText.setAttribute("title", LC.getLabel('TagHeader', 'add_tags'));
    }
    else {
        this.editTagsText.innerHTML = LC.getLabel('TagHeader', 'edit_tags');
        this.editTagsText.setAttribute("title", LC.getLabel('TagHeader', 'edit_tags'));
    }
}

// Set up the display of the current tags in the sub-header of the page
TagHeader.setupDisplayList = function(displayList, tags, tagIds, tagMode, charCount) {
    if (displayList == null)
        return charCount;

    // Remove the existing display
    displayList.innerHTML = '';

    // If there aren't any tags, use the label to indicate that there are no tags
    if (tags.length == 0) {
        document.getElementById(tagMode + TagConstants.TAG_DISPLAY_CONTAINER).style.display = 'none';
    }
    else {
        document.getElementById(tagMode + TagConstants.TAG_DISPLAY_CONTAINER).style.display = 'inline';
        var tagsLeft = tags.length;
        // Otherwise, go through the tags and add links for each one
        // TODO create elements on a temporary element node before adding to the document.
        for (var i = 0; i < tags.length; i++) {
            // only add tags tht don't bring us over length limit
            if ((charCount + tags[i].length) > TagHeader.MAX_TAG_LIST_CHARS)
                continue;

            if (tagsLeft < tags.length) {
                displayList.appendChild(document.createTextNode(', '));
            }

            TagHeader.addTagLink(displayList, tags[i], tagIds[i], tagMode);
            charCount += tags[i].length;
            tagsLeft--;
        }

        if (tagsLeft == tags.length) { // if all tags longer than max len, display first tag
            TagHeader.addTagLink(displayList, tags[0], tagIds[0], tagMode);
            tagsLeft--;
        }

        if (tagsLeft > 0) {
            var node = document.createElement('span');
            node.innerHTML = ' ' + LC.getLabel('TagHeader', 'tag_list_more', tagsLeft);
            node.title = tags.slice(tags.length - tagsLeft, tags.length).join(', ');
            displayList.appendChild(node);
        }
    }
    return charCount;
}

/**
 * Append a tag link element to the given element.
 * @param element DOMElement
 * @param tag String
 * @return created element
 */
TagHeader.addTagLink = function(element, tag, tagId, tagMode) {
    var tagLink = document.createElement('a');
    var qs = new QueryString("");
    qs.add(TagConstants.TAG_ID_LIST, tagId);
    if (tag && tag.length > 1) {
      qs.add(TagConstants.TAG_SEARCH_FIELD, tag);
      qs.add("lsc", TagConstants.ROLODEX_SEARCH_VALUE);
    }
    var url = TagConstants.TAG_SEARCH_RESULTS_URL + qs.toString();
    if (this.desktopParam) {
        url = 'javascript:srcUp(\'' + url + this.desktopParam + '\');';
    }
    tagLink.href = url;
    tagLink.setAttribute("title", LC.getLabel('TagHeader', 'tag_list_tag_tip', tag));
    tagLink.innerHTML = tag;
    element.appendChild(tagLink);
    return tagLink;
}

// Open the drop-down to allow editing the tags on the entity
TagHeader.openDropDown = function() {
    var self = this;

    this.newTags = new Array().concat(this.tags);
    this.newPublicTags = new Array().concat(this.pubTags);
    this.updateEditArea();
    this.dropDownStartHeight = XBrowser.getActualHeight(self.tagHeader);

    self.tagHeader.style.display="none";
    self.dropDown.style.display='block';
    self.resetAndResize();
    Animation.animateResizeHeight(self.dropDown, self.dropDownStartHeight, -1,
        function() {
            self.dropDownContents.style.visibility='visible';
            if (self.autoCompleter) self.autoCompleter.updateBoxLocation();
            if (self.pubAutoCompleter) self.pubAutoCompleter.updateBoxLocation();
            var editArea = self.tagEditArea ? self.tagEditArea : self.pubTagEditArea;
            editArea.focus();
            TagHeader.moveCursorToEndIE(editArea);
        } );
    // Since we're dropping down the body, we have to resize the sidebar
    if (Sidebar.prototype.theSidebar) {
        Sidebar.prototype.theSidebar.sizeToBody();
        Sidebar.prototype.theSidebar.sizeBodyToSidebarNoCheck();
    }
}

// Hide the drop down, but don't do anything with the tags (done in save/cancel)
TagHeader.hideDropDown = function() {
    var self = this;
    self.dropDownContents.style.visibility='hidden';

    Animation.animateResizeHeight(self.dropDown, XBrowser.getActualHeight(self.dropDown), self.dropDownStartHeight,
        function() {
            self.tagHeader.style.display='block';
            self.dropDown.style.display='none';
            self.removeError();
        });
    // Since we're raising the body, we have to resize the sidebar
    if (Sidebar.prototype.theSidebar) {
        Sidebar.prototype.theSidebar.sizeToBody();
        Sidebar.prototype.theSidebar.sizeBodyToSidebarNoCheck();
    }
}

// Hide the drop down and revert the textarea to its initial value
TagHeader.cancel = function() {
    this.hideDropDown();
    this.setTags();
}

// Save the tags that are in the textarea and update the display area
TagHeader.save = function() {
    if (this.tagEditArea) var userTags = this.newTags.concat(this.getTags(this.tagEditArea));
    if (this.pubTagEditArea) var publicTags = this.newPublicTags.concat(this.getTags(this.pubTagEditArea));

    var loc = TagConstants.SAVE_TAGS_PAGE;
    var self = this;
    var handleResponse = function(request) {
        var xmlDoc = request.responseXML;
        // ensure that xml document returned
        if(!xmlDoc || (XBrowser.userAgent.isIE && !xmlDoc.xml)) {
            // handles the case of logout
            if(request.status == 200) {
                window.location = window.location;
            } else {
                // otherwise displays an error
                self.loading.hide();
                self.displayError(self.generateError(LC.getLabel("TagHeader", "unknown_error")));
                return;
            }
        }
        var ok = xmlDoc.getElementsByTagName("ok")[0];
        if (ok) {
            if (XBrowser.userAgent.isFirefox) {
                xmlDoc.normalize(); // Fixes a Firefox limitation of 4096 on the size of a text node
            }
            // read tag names
            var tagNames = ok.getElementsByTagName(TagConstants.TAG_NAMES_ELEM)[0];
            var newTags = (tagNames.firstChild && tagNames.firstChild.nodeValue) ? tagNames.firstChild.nodeValue : '';
            self.tags = eval('new Array(' + newTags + ')');

            // read tag ids
            var tagIds = ok.getElementsByTagName(TagConstants.TAG_IDS_ELEM)[0];
            var newTagIds = (tagIds.firstChild && tagIds.firstChild.nodeValue) ? tagIds.firstChild.nodeValue : '';
            self.tagIds = eval('new Array(' + newTagIds + ')');

            // read public tag names
            var tagNames = ok.getElementsByTagName(TagConstants.PUBLIC_TAG_NAMES_ELEM)[0];
            var newTags = (tagNames.firstChild && tagNames.firstChild.nodeValue) ? tagNames.firstChild.nodeValue : '';
            self.pubTags = eval('new Array(' + newTags + ')');

            // read public tag ids
            var tagIds = ok.getElementsByTagName(TagConstants.PUBLIC_TAG_IDS_ELEM)[0];
            var newTagIds = (tagIds.firstChild && tagIds.firstChild.nodeValue) ? tagIds.firstChild.nodeValue : '';
            self.pubTagIds = eval('new Array(' + newTagIds + ')');

            self.setTags();
            self.display();
            self.hideDropDown();
            self.loading.hide();
            TagMenuButton.flushCache();
        }
        else {
            var errors = xmlDoc.getElementsByTagName("saveerror");
            if (errors) {
                for (var i = 0; i < errors.length; i++) {
                    var error = errors[i];
                    var mode = error.getElementsByTagName("tagmode");
                    mode = mode && mode[0] ? mode[0].firstChild.nodeValue : '';
                    var errorMessage = error.getElementsByTagName("errormessage")[0];
                    errorMessage = errorMessage ? errorMessage.firstChild.nodeValue : self.generateError(LC.getLabel("TagHeader", "unknown_error"));
                    self.displayError(errorMessage, mode);
                }
            }
            else {
                self.displayError(self.generateError(LC.getLabel("TagHeader", "unknown_error")));
            }
            self.loading.hide();

        }
    };

    var handleError = function(err) {
        self.loading.hide();
        self.displayError(self.generateError(LC.getLabel("TagHeader", "server_error")));
    };
    this.removeError();
    this.loading.show();

    var qs = new QueryString("");
    qs.add('id', this.id);
    if (userTags) qs.add('tags', userTags.join(', '));
    if (publicTags) qs.add('pTags', publicTags.join(', '));
    var queryString = qs.toString();
    XBrowser.postHttpResponse(loc, handleResponse, queryString.substring(1, queryString.length), handleError);
}

TagHeader.displayError = function(error, mode) {
    if (this.tagEditArea && mode == TagMode.PERSONAL) this.tagEditArea.className = EditElement.ERROR_CLASS;
    else if (this.pubTagEditArea && mode == TagMode.PUBLIC) this.pubTagEditArea.className = EditElement.ERROR_CLASS;
    var tagEditError = document.getElementById(mode + TagConstants.TAG_EDIT_ERROR_ID);
    tagEditError.innerHTML = error;
    tagEditError.style.display = mode ? 'inline' : 'block';
}

TagHeader.removeError = function() {
    if (this.tagEditArea) this.tagEditArea.className = '';
    if (this.pubTagEditArea) this.pubTagEditArea.className = '';
    this.removeErrorMessage('');
    this.removeErrorMessage(TagMode.PERSONAL);
    this.removeErrorMessage(TagMode.PUBLIC);
}

TagHeader.removeErrorMessage = function(mode) {
    var tagEditError = document.getElementById(mode + TagConstants.TAG_EDIT_ERROR_ID);
    if (tagEditError) {
        tagEditError.innerHTML = '';
        tagEditError.style.display = 'none';
    }
}

// This is also done in ErrorTextElement, but we need to generate the error in JavaScript.
TagHeader.generateError = function(msg) {
    return LC.getLabel("Global", "colonSeparatedWords", LC.getLabel("Global", "error"), msg);
}

TagHeader.keyPress = function(e) {
    e = (e) ? e : ((event) ? event : null);
    if (e) {
        if (e.keyCode == KEY_ENTER) {
            this.save();
            TagAutoComplete.stopBubble(e);
        } else if (e.keyCode == KEY_ESC) {
            this.cancel();
            TagAutoComplete.stopBubble(e);
        }
    }
}

/**
 * Reset the textarea to a single line, and resize it as necessary.
 */
TagHeader.resetAndResize= function() {
    if (this.tagEditArea != null) {
        this.tagEditArea.style.height = TagHeader.LINE_HEIGHT + TagHeader.LINE_HEIGHT_UNITS;
        this.tagEditArea.textLines = 1;
        this.checkAndResize(this.tagEditArea);
    }
    if (this.pubTagEditArea != null) {
        this.pubTagEditArea.style.height = TagHeader.LINE_HEIGHT + TagHeader.LINE_HEIGHT_UNITS;
        this.pubTagEditArea.textLines = 1;
        this.checkAndResize(this.pubTagEditArea);
    }
}

/**
 * Expand text area so that contained text fits vertically.
 * Returns true if text area was resized.
 */
TagHeader.checkAndResize = function(editArea) {
    var ret = false;
    while (editArea.scrollHeight > editArea.clientHeight) {
        editArea.textLines++;
        editArea.style.height = (editArea.textLines * TagHeader.LINE_HEIGHT) + TagHeader.LINE_HEIGHT_UNITS;
        editArea.rows = editArea.textLines;
        ret = true;
    }
    return ret;
}

// Setup for the given tags
TagHeader.setTags = function() {
    this.updateHiddenTags(this.tags, this.hiddenTagList);
    this.updateHiddenTags(this.tagIds, this.hiddenTagIdList);
    this.updateHiddenTags(this.pubTags, this.hiddenPubTagList);
    this.updateHiddenTags(this.pubTagIds, this.hiddenPubTagIdList);
}

TagHeader.remove = function(mode, tag) {
    if (mode == TagMode.PERSONAL) this.newTags[tag] = null;
    else if (mode == TagMode.PUBLIC) this.newPublicTags[tag] = null;
    this.updateEditArea(true);
}

TagHeader.updateEditArea = function(keepEdits) {
    if (this.tagEditArea != null) {
        this.updateEditAreaItems(this.newTags, TagMode.PERSONAL, this.tagEditList);
        if (!keepEdits) this.tagEditArea.value = '';
    }

    if (this.pubTagEditArea != null) {
        this.updateEditAreaItems(this.newPublicTags, TagMode.PUBLIC, this.pubTagEditList);
        if (!keepEdits) this.pubTagEditArea.value = '';
    }
}

TagHeader.updateEditAreaItems = function(tags, mode, editList) {
    if (tags.length == 0) {
        editList.innerHTML = LC.getLabel('TagHeader', 'no_tags');
    }
    else {
        var content = '';
        for (i in tags) {
            if (tags[i]) {
                if (content.length > 0) content += ', ';
                content += '<span class=\'tag\'>' + tags[i] + ' [ <span class=\'tagRemove\' onclick=\'javascript:TagHeader.remove("'
                    + mode + '", ' + i + ')\' title=\'' + LC.getLabel("TagHeader", "remove_tag", tags[i]) + '\'>X</span> ]</span>';
            }
        }
        editList.innerHTML = content;
    }
}

TagHeader.updateHiddenTags = function(tags, element) {
    if (element != null) {
        var content = tags.join(', ');
        element.value = content;
    }
}

// Get the tags that the user has typed into the textarea
TagHeader.getTags = function(element) {
    if (element != null) {
        var tagList = element.value.split(',');
        var trimmedList = [];
        for (var i=0; i<tagList.length;i++) {
            var t = trim(tagList[i]);
            if (t.length > 0) {
                trimmedList.push(t);
            }
        }
        return trimmedList;
    }
    else {
        return new Array();
    }
}

/**
 * Move cursor to the end of given text input element
 * @param text input element
 */
TagHeader.moveCursorToEndIE = function(element) {
    if (XBrowser.userAgent.isIE) {
        // duplicating selection better behaved than creating new TextRange straight from document
        var tr = document.selection.createRange().duplicate();
        tr.moveToElementText(element);
        tr.setEndPoint("StartToEnd", tr);
        tr.select();
    }
}

//#depend Objects
/**
 * CRT Object selection UI
 *
 * @author tkim
 * @since 148
 */

CrtObjectNode.STATE_HIDDEN = 'h';
CrtObjectNode.STATE_GHOST0 = '0';
CrtObjectNode.STATE_GHOST1 = '1';
CrtObjectNode.STATE_ESTABLISHED = 'e';

CrtObjectsUi.CRT_IMG_BASE = "/crt_rel_";

function CrtObjectNode(state, iNode, modelPick) {
    this.state = state;
    this.ghostElbow = CrtObjectsUi.getElement(iNode, CrtObjectElement.GHOST_ELBOW);
    this.elbowInner = CrtObjectsUi.getElement(iNode, CrtObjectElement.ELBOW_INNER);
    this.elbowOuter = CrtObjectsUi.getElement(iNode, CrtObjectElement.ELBOW_OUTER);
    this.ghost0 = CrtObjectsUi.getElement(iNode, CrtObjectElement.GHOST0);
    this.ghost1 = CrtObjectsUi.getElement(iNode, CrtObjectElement.GHOST1);
    this.modelPick = modelPick;
    this.endWarning = CrtObjectsUi.getElement(iNode, CrtObjectElement.TERMINAL_OBJECT_WARNING);
    this.warning = CrtObjectsUi.getElement(iNode, CrtObjectElement.MAX_OBJECTS_WARNING);
}

CrtObjectsUi.init = function(objects, formName, imageRoot, urlRoot, crtJoinImages) {
    //preload crt join images so they get saved in cache
    CrtObjectsUi.preLoadCrtJoinImages(urlRoot, crtJoinImages);

    var nodes = new Array();

    var needGhost0 = true;
    for(var iNode = 0; iNode < CrtConstants.MAX_OBJECTS; iNode++) {
        var modelPick = objects.getPicklist(iNode); // TODO: rename to modelPick

        // determine the initial state of nodes
        var state = CrtObjectNode.STATE_HIDDEN;
        var objectValue = objects.getValue(iNode);
        if (objectValue != '') {
            state = CrtObjectNode.STATE_ESTABLISHED;
        } else if (needGhost0) {
            // we only need ghost0 for the first non-established node
            //only show ghost0 if we have any options to show
            if (modelPick.options.length == 1) {
                state = CrtObjectNode.STATE_HIDDEN;
            } else {
                state = CrtObjectNode.STATE_GHOST0;
            }
            needGhost0 = false;
        } else {
            state = CrtObjectNode.STATE_HIDDEN;
        }

        nodes[iNode] = new CrtObjectNode(state, iNode, modelPick);
    }
    return new CrtObjectsUi(nodes, objects, formName, imageRoot, urlRoot);
}

CrtObjectsUi.getElement = function(iNode, name) {
    return document.getElementById(CrtObjectElement.LEVEL + iNode + '_' + name);
}

/*
 There are 4 nodes corresponding to the 4 potential objects.  The nodes
 are identified by its index iNode = 0..3.

 Each node is in some state.  A state is given primarily by its value
 (hidden, ghost0, ghost1, established).

 objects is an instance of the CrtObjects class which keeps track of some
 underlying picklists
 */
function CrtObjectsUi(nodes, objects, formName, imageRoot, urlRoot) {
    this.nodes = nodes;
    this.objects = objects;
    this.formName = formName;
    this.imageRoot = imageRoot;
    this.urlRoot = urlRoot;
	this.clickedDelete = false;

    var self = this;

    // map from state -> rendering function
    this.renders = new Array();
    this.renders[CrtObjectNode.STATE_HIDDEN] = function(iNode) { self.render_hidden(iNode) };
    this.renders[CrtObjectNode.STATE_GHOST0] = function(iNode) { self.render_ghost0(iNode) };
    this.renders[CrtObjectNode.STATE_GHOST1] = function(iNode) { self.render_ghost1(iNode) };
    this.renders[CrtObjectNode.STATE_ESTABLISHED] = function(iNode) { self.render_established(iNode) };

    for(var iNode = 0; iNode < nodes.length; iNode++) {
       // attach events
       this.attachEvents(iNode);
    }

    // render initial state
    for(var iNode = 0; iNode < nodes.length; iNode++) {
        this.renders[this.nodes[iNode].state](iNode);
    }


    //display the image for this join type
    //need to render join image for the first time
    this.updateImage();
}

CrtObjectsUi.preLoadCrtJoinImages = function(urlRoot, allImages) {
    //NAR: this code makes me cringe.  I hope we can change this soon
    for (var i = 0; i < allImages.length; i++) {
       allImages[i] = urlRoot + CrtObjectsUi.CRT_IMG_BASE + allImages[i] + ".gif";
    }

    CrtObjectsUi.preLoadImages(allImages);
}

CrtObjectsUi.preLoadImages = function(allImages) {
    var cachedImages = new Array(allImages.length);

    for (var i = 0; i < allImages.length; i++) {
       cachedImages[i] = new Image();
       cachedImages[i].src = allImages[i];
    }
}

CrtObjectsUi.prototype.attachEvents = function(iNode) {
    var self = this;
    var node = this.nodes[iNode];

    // transition from ghost0 to ghost1 for node i
    // attach to the entire ghost0 block
    addEvent(node.ghost0, 'click', function() { self.handle_ghost0_click(iNode); }, false);
}

CrtObjectsUi.prototype.handle_ghost0_click = function(iNode) {
    this.do_transition(iNode - 1, CrtObjectNode.STATE_ESTABLISHED);
    this.do_transition(iNode, CrtObjectNode.STATE_GHOST1);
}

CrtObjectsUi.prototype.do_transition = function(iNode, newState) {
    this.nodes[iNode].state = newState;
    this.renders[newState](iNode);

    //display the image for this join type
    this.updateImage();
}

CrtObjectsUi.prototype.waitAndEnableDeleteLink = function(time) {
	setTimeout('CrtObjectsUi.instance.clickedDelete = false;', time);
}

CrtObjectsUi.prototype.remove_object = function(iNode) {
    var selectedValue = this.objects.getValue(iNode);
    //if we have an ID_SEPARATOR, this is an existing object, so open confirm popup
    if (selectedValue.indexOf(CrtObjects.ID_SEPARATOR) > -1) {
       if (!this.clickedDelete) {
	       this.clickedDelete = true;
	       this.waitAndEnableDeleteLink(2000);
	       openPopup('','objectDeletion',600,350,"width=600,height=350,resizable=no,scrollbars=no,status=yes",true);
	       var html = '';
	       var apiVersion = "10.0";
	       curPopupWindow.document.write('<html><head>');
	       //DynamicCss.writeCss closes the document stream making it impossible to close the header tag and write more things...solution recreate it here without closing the doc
	        for (var i = 0; i < DynamicCss.instance.cssLinks.length; i++) {
	            curPopupWindow.document.write(DynamicCss.instance.cssLinks[i].getLink(apiVersion));
	        }
	       html += '</head>';
	       html += '<body style="background-color: #EEEEEE;">';
	       html += '<div style="float: left; padding: 3px;">' + CrtObjects.ALERT_IMG + '</div>';
	       html += '<div style="padding: 15px 0px;"><H2>'+LC.getLabel("ObjectsUi","objectRemovalAlert_Header")+'</H2></div>';
	       html += '<div style="padding: 20px 55px;">' + unescapeHTML(LC.getLabel("ObjectsUi","objectRemovalAlert_Body")) + '</div>';
	       html += '<div style="text-align: center;"><input class="btn" type="button" value="'+ LC.getLabel("ObjectsUi","yesDelete") +'" onclick="window.opener.CrtObjectsUi.instance.do_transition('+ iNode +',window.opener.CrtObjectNode.STATE_GHOST0); window.opener.CrtObjectsUi.instance.clickedDelete=false; window.close();">';
	       html += '<input class="btn" type="button" value="'+ LC.getLabel("ObjectsUi","noDelete") +'" onclick="window.opener.CrtObjectsUi.instance.clickedDelete=false; window.close();"></div>';
	       html += '</div>';
	       html += '</body></html>';
	       curPopupWindow.document.write(html);
	       curPopupWindow.document.close();
       }
    } else {
        this.do_transition(iNode,CrtObjectNode.STATE_GHOST0);
    }
}
// for rendering purposes we only come into play during state transitions
// and we only ever render states in their "new" form, i.e. with dropdowns
// and other input values set to null

CrtObjectsUi.prototype.render_hidden = function(iNode) {
    var node = this.nodes[iNode];
    node.ghost0.style.display = 'none';
    node.ghost1.style.display = 'none';
    node.elbowInner.style.display = 'none';
    node.elbowOuter.style.display = 'none';
    node.ghostElbow.style.display = 'none';
    node.endWarning.style.display = 'none';
    node.warning.style.display = 'none';
}

CrtObjectsUi.prototype.render_ghost0 = function(iNode) {
    var node = this.nodes[iNode];
    node.ghost0.style.display = 'block';
    node.ghostElbow.style.display = 'block';

    node.ghost1.style.display = 'none';
    node.elbowInner.style.display = 'none';
    node.elbowOuter.style.display = 'none';
    node.endWarning.style.display = 'none';
    node.warning.style.display = 'none';

    // remove link:  going from established to ghost0
    node.modelPick.selectedIndex = 0; // select the --None-- option
    this.objects.updatePicklists(iNode);

    // remove link
    if (iNode < (this.nodes.length - 1)) {
        // if this is a remove then this node goes to ghost0 and nextNode goes to hidden
        //ZZ: Hackish - do_transition is called from the remove link which in turns calls renders, but this in turn calls do_transition
        //which might lead to infinite loops; in this case, we are just transitioning to STATE_HIDDEN (a dead-end state) so nothing happens
        var tempNode = iNode+1;
        for (tempNode; tempNode < this.nodes.length; tempNode++) {
            this.do_transition(tempNode, CrtObjectNode.STATE_HIDDEN);
        }
    }

    // show the remove link on the node above, but not for the root node!
    /*if (iNode > 1) {
        CrtObjectsUi.getElement(iNode - 1, CrtObjectElement.REMOVE_OBJECT_LINK).style.visibility = 'visible';
    }*/
}

CrtObjectsUi.prototype.render_ghost1 = function(iNode) {
    var node = this.nodes[iNode];
    // we're assuming we came from ghost0
    node.ghost0.style.display = 'none';
    node.ghost1.style.display = 'block';

    // Default the UI state:  inner join is checked by default
    var radios = this.getJoinRadio(iNode);
    if (radios != null) {
        radios[0].checked = true;
        this.render_inner_join_option(iNode, this.isOuterJoin(iNode - 1));
    }

    this.render_elbow(iNode);

    var objectLabel = CrtObjectsUi.getElement(iNode, CrtObjectElement.EST_OBJECT_LABEL);
    objectLabel.style.display = 'none';

    var select = CrtObjectsUi.getElement(iNode, CrtObjectElement.INNER_JOIN_SELECT);
    select.style.display = 'block';
    this.copySelect(this.nodes[iNode].modelPick, select);
    select.selectedIndex = 0; // choose the --None-- option
}

/** name is either 'inner_select' or 'outer_select' indicating which radio button you picked */
CrtObjectsUi.prototype.handle_radio = function(iNode, selectName) {
    var f = true;
    if (selectName == 'outer_select') {
        if (this.check_forced_outer_join(iNode)) {
            this.popup_forced_outer_join(iNode);
            f = false; // suppress the actual switch to the radio button
        } else {
            this.apply_outer_join(iNode);
        }
    } else if (selectName == 'inner_select') {
        for(var i = iNode + 1; i < this.nodes.length; i++) {
            this.render_inner_join_option(i, this.isOuterJoin(i - 1)); // show the inner join option in all children
        }
        this.updateImage();
    }
    this.render_elbow(iNode);
    return f;
}

CrtObjectsUi.prototype.check_forced_outer_join = function(iNode) {
    var forced = false;
    for(var i = iNode + 1; i < this.nodes.length; i++) {
        if (this.nodes[i].state == CrtObjectNode.STATE_GHOST1 || this.nodes[i].state == CrtObjectNode.STATE_ESTABLISHED) {
            if (!this.isOuterJoin(i)) {
                forced = true;
                break;
            }
        } else {
            break;
        }
    }
    return forced;
}

CrtObjectsUi.prototype.apply_outer_join = function(iNode) {
    var radios = this.getJoinRadio(iNode);
    radios[0].checked = false;
    radios[1].checked = true;
    for(var i = iNode + 1; i < this.nodes.length; i++) {
        this.render_inner_join_option(i, true); // hide the inner join option in all children
        if (this.nodes[i].state == CrtObjectNode.STATE_GHOST1 || this.nodes[i].state == CrtObjectNode.STATE_ESTABLISHED) {
            this.render_elbow(i); // because render_inner_join_option may have forced the child's radio button
        }
    }
    this.updateImage();
}

CrtObjectsUi.prototype.revert_outer_join = function(iNode) {
    var radios = this.getJoinRadio(iNode);
    radios[0].checked = true;
    radios[1].checked = false;
}

CrtObjectsUi.prototype.popup_forced_outer_join = function(iNode) {
    var selectedValue = this.objects.getValue(iNode);
    openPopup('','objectDeletion',600,350,"width=300,height=200,resizable=no,scrollbars=no,status=yes",true);
    var html = '';
    var apiVersion = "10.0";
    curPopupWindow.document.write('<html><head>');
    //DynamicCss.writeCss closes the document stream making it impossible to close the header tag and write more things...solution recreate it here without closing the doc
     for (var i = 0; i < DynamicCss.instance.cssLinks.length; i++) {
         curPopupWindow.document.write(DynamicCss.instance.cssLinks[i].getLink(apiVersion));
     }
    html += '</head>';
    html += '<body style="background-color: #EEEEEE;">';
    html += '<div style="float: left; padding: 3px;">' + CrtObjects.ALERT_IMG + '</div>';
    html += '<div style="padding: 15px 0px;"><H2>'+LC.getLabel("ObjectsUi","ForcedOuterJoin_Title")+'</H2></div>';
    html += '<div style="padding: 20px 55px;">' + unescapeHTML(LC.getLabel("ObjectsUi","ForcedOuterJoin_Body")) + '</div>';
    html += '<div style="text-align: center;"><input class="btn" type="button" value="'+ LC.getLabel("Buttons","ok") +'" onclick="window.opener.CrtObjectsUi.instance.apply_outer_join('+ iNode +'); window.close();">';
    html += '<input class="btn" type="button" value="'+ LC.getLabel("Buttons","cancel") +'" onclick="window.opener.CrtObjectsUi.instance.revert_outer_join('+ iNode +');window.close();"></div>';
    html += '</div>';
    html += '</body></html>';
    curPopupWindow.document.write(html);
    curPopupWindow.document.close();
}


CrtObjectsUi.prototype.render_inner_join_option = function(iNode, isHide) {
    var innerJoinOption = CrtObjectsUi.getElement(iNode, CrtObjectElement.INNER_JOIN_OPTION);
    var radios = this.getJoinRadio(iNode);
    if (isHide) {
        innerJoinOption.style.display = 'none';
        radios[1].style.display = 'none';
        radios[1].checked = true;
    } else {
        innerJoinOption.style.display = 'block';
        radios[1].style.display = ''; // it's inline
    }
}

CrtObjectsUi.prototype.render_elbow = function(iNode) {
    var node = this.nodes[iNode];
    if (iNode == 0) {
        node.elbowInner.style.display = 'none';
        node.elbowOuter.style.display = 'none';
    } else if (this.isOuterJoin(iNode)) {
        node.ghostElbow.style.display = 'none';
        node.elbowInner.style.display = 'none';
        node.elbowOuter.style.display = 'inline';
    } else {
        node.ghostElbow.style.display = 'none';
        node.elbowInner.style.display = 'inline';
        node.elbowOuter.style.display = 'none';
    }
}

CrtObjectsUi.prototype.handle_select = function(iNode, select) {
    // TODO: move these two lines to objects.setValue(iNode, value)
    this.nodes[iNode].modelPick.selectedIndex = select.selectedIndex;
    this.objects.updatePicklists(iNode);

    //if we have more possible objects to select (object limits not reached) do transition
    if (!this.render_warning(iNode)) {
        this.do_transition(iNode + 1, CrtObjectNode.STATE_GHOST0);
    } else if (iNode + 1 < this.nodes.length) {
        this.do_transition(iNode + 1, CrtObjectNode.STATE_HIDDEN);
    }
}

CrtObjectsUi.prototype.render_warning = function(iNode) {
    var f;
    var iNextNode = iNode + 1;
    if (iNextNode == CrtConstants.MAX_OBJECTS) {
        this.nodes[iNode].warning.style.display = 'block';
        f = true;
    } else if (this.nodes[iNextNode].modelPick.options.length == 1) {
        this.nodes[iNode].endWarning.style.display = 'block';
        f = true;
    } else {
        this.nodes[iNode].endWarning.style.display = 'none';
        this.nodes[iNode].warning.style.display = 'none';
        f = false;
    }

    return f;
}

CrtObjectsUi.prototype.copySelect = function(src, dest) {
    var srcOptions = src.options;
    var destOptions = dest.options;
    destOptions.length = 0;

    for(var i = 0; i < srcOptions.length; i++) {
        var srcOption = srcOptions[i];
        var destOption = new Option(srcOption.text, srcOption.value);
        destOptions[i] = destOption;
    }
}

CrtObjectsUi.prototype.render_established = function(iNode) {
    var node = this.nodes[iNode];
    node.ghost1.style.display = 'block';
    var select = CrtObjectsUi.getElement(iNode, CrtObjectElement.INNER_JOIN_SELECT);
    select.style.display = 'none';

    var objectLabel = CrtObjectsUi.getElement(iNode, CrtObjectElement.EST_OBJECT_LABEL);
    objectLabel.style.display = 'block';
    objectLabel.innerHTML = node.modelPick.options[node.modelPick.selectedIndex].innerHTML;

    /*if (iNode > 1) {
        // hide the remove link for the node above
        CrtObjectsUi.getElement(iNode - 1, CrtObjectElement.REMOVE_OBJECT_LINK).style.visibility = 'hidden';
    }*/

    var radios = this.getJoinRadio(iNode);
    if (radios != null) {
        this.render_inner_join_option(iNode, this.isOuterJoin(iNode - 1));
    }

    this.render_elbow(iNode);

    //show the warning message
    this.render_warning(iNode);

    node.ghost0.style.display = 'none';
    node.ghostElbow.style.display = 'none';
}

// @return null iff org only has inner joins available
CrtObjectsUi.prototype.getJoinRadio = function(iNode) {
    var radioName = CrtObjectElement.LEVEL + iNode + '_' + CrtObjectElement.JOIN_RADIO;
    var radio = document.getElementById(this.formName)[radioName];
    return radio;
}

CrtObjectsUi.prototype.updateImage = function() {
    document.getElementById("joinImage").firstChild.src = this.getJoinImageForCurrentLevel();
}

CrtObjectsUi.prototype.getJoinImageForCurrentLevel = function() {
    var image = this.urlRoot + CrtObjectsUi.CRT_IMG_BASE + "A";

    for (var i = 1; i < this.nodes.length && (this.nodes[i].state == CrtObjectNode.STATE_GHOST1 || this.nodes[i].state == CrtObjectNode.STATE_ESTABLISHED); i++) {
        if(this.isOuterJoin(i)) {
            image += "wwo" + String.fromCharCode("A".charCodeAt(0) + i);
        } else {
            image += "w" + String.fromCharCode("A".charCodeAt(0) + i);
        }
    }

    return image + ".gif";
}

CrtObjectsUi.prototype.isOuterJoin = function(iNode) {
    var radio = this.getJoinRadio(iNode);
    if (radio == null) return false;
    return radio[0].checked ? false : radio[1].checked ? true : null;
}


//#depend common.util.XBrowser
/*
* @author mpolcari
* @since 142.ml
*/

function Gack() {}

//someday this could be integrated into error reporting
//Perhaps an industrious individual could create a custom app that handled 'gacks' from this.
// then the custom app could be shared over the appexchange...
Gack.sendGack = function(message) {
  if (window.devMode) {
//    debugger;
    alert("Gack: " + message);
  } else {
    window.status = message;
  }
}

Gack.handleException = function(ex) {
  var errMsg = ex.sfdcDesc + " - " + ex.name + " - " + ex.description;
  Gack.sendGack(errMsg);
}
/* @author brehani
 * @since 146
 * */
Gack.MaxJSErrors = 1; //Currently one only error is logged per page. This may be increased later.

Gack.hideJSErrorFromUser = false; //false does not hide the JS error from user (recommended)

Gack.logJSError = function (jsgack){
 	
	try{
		var subject = "JS Error: " + jsgack.substr(0,100); //add the first 100 characters to the gack subject
		var entityBody = XBrowser.buildPost({ "subject" : subject, "msg" : jsgack });
		
		if((entityBody != null) && (entityBody.indexOf("JS%20Error%3A") != -1)){
			XBrowser.postHttpResponse("/servlet/servlet.GackSender", function(response) {}, entityBody);
		}
	}
	catch(e){}
}

Gack.defineErrorHandling = function (){
	var count = 0;
	window.onerror = function(msg , url, line){
		if(count < Gack.MaxJSErrors){
		 Gack.logJSError(msg + " URL: " + url + " Line: " + line + " " + navigator.userAgent);
		 count++;
		}
		 return Gack.hideJSErrorFromUser;
	}
}

/*if (XBrowser.userAgent.isIE || XBrowser.userAgent.isFirefox) //restricting to supported browsers
	Gack.defineErrorHandling();*/


//#depend common.udd.InlineEditField

/**
 * Base field object for complex fields which can open in an overlay
 * 
 * @author jmooney
 * @since 150
 */
InlineEditField.CompoundField = function() {
    this.compound = true;
    this.overlay = null;
    this.width = 0;
    this.editElements = [];
    this.elementToFocus = null;
}

InlineEditField.CompoundField.prototype = new InlineEditField();


/**
 * open this field for editing
 */
InlineEditField.CompoundField.prototype.openField = function() {
    if (!this.created) {
        this.createEditDiv();
    }
    this.showEdit();
}

/**
 * Create the edit container and elements inside of the table cell
 */
InlineEditField.CompoundField.prototype.createEditDiv = function() {
    var title = this.getFieldLabel();
    this.overlay = InlineEditField.overlay;
    this.editDiv = document.createElement("div");
    this.editDiv.className = "inlineEditCompoundDiv";
    this.editDiv.id = this.id + InlineEditConstants.INNER_ID + "edit";
    this.overlay.addField(this.id, this.editDiv, title);
    this.createEditElements();
    this.createUndoButton();
    this.created = true;
}

/**
 * resets this field back to its initial value
 */
InlineEditField.CompoundField.prototype.reset = function() {
    this.currentValue = this.initialValue;
    delStyleClass(this.readDiv, "inlineEditModified");
    this.changed = false;
    this.undoButton.style.display = "none";
    this.editDiv.appendChild(this.undoButton);
    this.readDiv.innerHTML = this.initialHTML;
    if (sfdcPage.inlineEditData.isCurrentField(this)) {
        this.hideEdit();
        sfdcPage.inlineEditData.currentField = null;
    }
    this.clearError();
    this.updateEditElement();
}

/**
 * show the overlay
 */
InlineEditField.CompoundField.prototype.showEdit = function() {
    this.overlay.setActiveField(this.id);
    this.overlay.setMaxWidth(this.width);
    this.overlay.show();
    if (this.elementToFocus) {
        this.elementToFocus.focus();
        if (this.elementToFocus.type == "text") {
            this.elementToFocus.select();
        }
    }
}

/**
 * hide the edit element, show the data element
 */
InlineEditField.CompoundField.prototype.hideEdit = function() {
    this.overlay.hide();
    if (this.changed) {
        if (this.undoButton.parentNode != this.readDiv) {
            this.readDiv.appendChild(this.undoButton);
        }
        this.undoButton.style.display = "inline";
    } else {
        this.undoButton.style.display = "none";
    }
}

/**
 * close this field
 */
InlineEditField.CompoundField.prototype.closeField = function() {
    var newValue = this.getValueFromEdit();
    if (this.isDifferentValue(newValue)) {
        if (!this.changed) {
            this.changed = true;
            addStyleClass(this.readDiv, "inlineEditModified");
        }
        this.currentValue = newValue;
        this.updateReadElement();
    }
    this.hideEdit();
}

InlineEditField.CompoundField.prototype.updateReadElement = function() {
    this.readDiv.innerHTML = this.formatValue();
}

/**
 * format the components of this field into 1 simple value
 */
InlineEditField.CompoundField.prototype.formatValue = function() { }


/** ----- COMPOUND FIELDS ----- */

/**
 * person name fields consist of first name, last name, and salutation which is a dynamic picklist
 * ordering depends on locale
 * 
 * @author jmooney
 * @since 150
 */
function PersonNameField(id, state, required, isColumn, initialValue, extraData) {
    this.init(id, state, required, isColumn, initialValue);
    this.hasSalutation = extraData["hasSalutation"];
    this.salutationPid = extraData["picklistId"];
    this.reverse = extraData["reverse"];
    this.labels = extraData["labels"];
    this.waitForLoad = true;
    this.initialIndex = 0;
    this.currentIndex = 0;
    this.width = 360;
}

// shortcuts to component indices
PersonNameField.S = ColumnTypeConstants.PERSONNAME_SALUTATION_OFFSET;
PersonNameField.F = ColumnTypeConstants.PERSONNAME_FIRSTNAME_OFFSET;
PersonNameField.L = ColumnTypeConstants.PERSONNAME_LASTNAME_OFFSET;

PersonNameField.prototype = new InlineEditField.CompoundField();

PersonNameField.prototype.getComponentId = function(which) {
    var prefix;
    switch (which) {
        case PersonNameField.S:
            prefix = EditElement.FIELD_NAME_SALUTATION;
            break;
        case PersonNameField.F:
            prefix = EditElement.FIELD_NAME_FIRST;
            break;
        case PersonNameField.L:
            prefix = EditElement.FIELD_NAME_LAST;
            break;
    }
    return prefix + this.id;
}


PersonNameField.prototype.createEditElements = function() {
    var html = [];
    html.push("<table border=0>")
    if (this.reverse) {
        this.createLastNameElement(html);
        this.createFirstNameElement(html);
    } else {
        this.createFirstNameElement(html);
        this.createLastNameElement(html);
    }
    html.push("</table>");
    this.editDiv.innerHTML = html.join('');
    this.editElements[PersonNameField.F] = getElementByIdCS(this.getComponentId(PersonNameField.F));
    this.editElements[PersonNameField.L] = getElementByIdCS(this.getComponentId(PersonNameField.L));
    if (this.hasSalutation) {
        var salId = this.getComponentId(PersonNameField.S);
        //initialize the picklist, no controller, not required, and always valid
        var att = " id=\"" + salId + "\" title=\"" + this.labels[PersonNameField.S] + "\"";
        var p = new picklist(salId, this.salutationPid, null, this.initialValue[PersonNameField.S], att, true, true);
        p.onLoad();
        this.editElements[PersonNameField.S] = getElementByIdCS(salId);
        this.initialIndex = this.editElements[PersonNameField.S].selectedIndex;
        this.currentIndex = this.initialIndex;
    }
    this.elementToFocus = this.editElements[PersonNameField.L];
}

PersonNameField.prototype.createFirstNameElement = function(html) {
    html.push("<tr><td class='labelCol'>");
    html.push(this.labels[PersonNameField.F]);
    html.push("</td><td>");
    if (this.hasSalutation && !this.reverse) {
        this.createSalutationElement(html);
    }
    html.push("<input type='text' id='");
    html.push(this.getComponentId(PersonNameField.F));
    html.push("' value=\"");
    html.push(this.cleanValue(this.currentValue[PersonNameField.F]));
    html.push("\" size='12' maxLength='");
    html.push(ColumnTypeConstants.DEFAULT_FIRSTNAME_LENGTH);
    html.push("'>");
    if (this.hasSalutation && this.reverse) {
        this.createSalutationElement(html);
    }
    html.push("</td></tr>");
}

PersonNameField.prototype.createSalutationElement = function(html) {
    html.push("<span><select id='");
    html.push(this.getComponentId(PersonNameField.S));
    html.push("' title='");
    html.push(this.labels[PersonNameField.S]);
    html.push("'><option selected value=\"");
    html.push(this.cleanValue(this.currentValue[PersonNameField.S][1]));
    html.push("\">");
    html.push(this.cleanValue(this.currentValue[PersonNameField.S][0]));
    html.push("</select></span>");
}

PersonNameField.prototype.createLastNameElement = function(html) {
    html.push("<tr><td class='labelCol'>");
    html.push(this.labels[PersonNameField.L]);
    html.push("</td><td>");
    html.push("<span class='inlineEditRequiredMark'>*</span><input type='text' id='");
    html.push(this.getComponentId(PersonNameField.L));
    html.push("' value=\"");
    html.push(this.cleanValue(this.currentValue[PersonNameField.L]));
    html.push("\" size='20' maxLength='");
    html.push(ColumnTypeConstants.DEFAULT_LASTNAME_LENGTH);
    html.push("'>");
    html.push("</td></tr>");
}

PersonNameField.prototype.formatValue = function() {
    var str = this.currentValue;
    var value;
    if (this.reverse) {
        value = str[PersonNameField.L] + " " + str[PersonNameField.F];
    } else {
        value = this.hasSalutation && str[PersonNameField.S][0] != LC.getLabel("SelectElement", "Required") ? str[PersonNameField.S][0] + " " : "";
        value += str[PersonNameField.F] + " " + str[PersonNameField.L];
    }
    return this.cleanValue(value);
}

PersonNameField.prototype.isDifferentValue = function(newValue) {
    return this.currentValue[PersonNameField.L] != newValue[PersonNameField.L] ||
           this.currentValue[PersonNameField.F] != newValue[PersonNameField.F] ||
           (this.hasSalutation && this.currentValue[PersonNameField.S][1] != newValue[PersonNameField.S][1]);
}

PersonNameField.prototype.getValueFromEdit = function() { 
    if (this.hasSalutation) {
        this.currentIndex = this.editElements[PersonNameField.S].selectedIndex;
        var sel = this.editElements[PersonNameField.S].options[this.currentIndex];
        return [[sel.text, sel.value],
                this.editElements[PersonNameField.F].value,
                this.editElements[PersonNameField.L].value];
    } else {
        return [null,
                this.editElements[PersonNameField.F].value,
                this.editElements[PersonNameField.L].value];
    }
}

PersonNameField.prototype.updateEditElement = function() {
    this.currentIndex = this.initialIndex;
    if (this.hasSalutation) {
        this.editElements[PersonNameField.S].selectedIndex = this.currentIndex;
    }
    this.editElements[PersonNameField.F].value = this.cleanValue(this.currentValue[PersonNameField.F]);
    this.editElements[PersonNameField.L].value = this.cleanValue(this.currentValue[PersonNameField.L]);
}

PersonNameField.prototype.addSaveData = function(saveData) {
    if (this.hasSalutation) {
        saveData[this.getComponentId(PersonNameField.S)] = this.currentValue[PersonNameField.S][1];
    }
    saveData[this.getComponentId(PersonNameField.F)] = this.currentValue[PersonNameField.F];
    saveData[this.getComponentId(PersonNameField.L)] = this.currentValue[PersonNameField.L];
}



/**
 * address fields change ordering and display based on locale
 * @author jmooney
 * @since 150
 */
function AddressField(id, state, required, isColumn, initialValue, extraData) {
    this.init(id, state, required, isColumn, initialValue);
    this.showState = extraData["showState"] || this.currentValue[AddressField.STATE];
    this.labels = extraData["labels"];
    this.width = 400;
}

// shortcuts to component indices
AddressField.STREET = ColumnTypeConstants.ADDRESS_STREET_OFFSET;
AddressField.CITY = ColumnTypeConstants.ADDRESS_CITY_OFFSET;
AddressField.STATE = ColumnTypeConstants.ADDRESS_STATE_OFFSET;
AddressField.ZIP = ColumnTypeConstants.ADDRESS_POSTAL_CODE_OFFSET;
AddressField.COUNTRY = ColumnTypeConstants.ADDRESS_COUNTRY_OFFSET;

AddressField.prototype = new InlineEditField.CompoundField();

AddressField.prototype.getComponentId = function(which) {
    var suffix;
    switch (which) {
        case AddressField.STREET:
            suffix = EditElement.FIELD_NAME_STREET;
            break;
        case AddressField.CITY:
            suffix = EditElement.FIELD_NAME_CITY;
            break;
        case AddressField.STATE:
            suffix = EditElement.FIELD_NAME_STATE;
            break;
        case AddressField.ZIP:
            suffix = EditElement.FIELD_NAME_ZIP;
            break;
        case AddressField.COUNTRY:
            suffix = EditElement.FIELD_NAME_COUNTRY;
            break;
    }
    return this.id + suffix;
}

AddressField.prototype.getMaxLengthOfComponent = function(which) {
    switch (which) {
        case AddressField.STREET:
            return ColumnTypeConstants.DEFAULT_STREET_LENGTH;
        case AddressField.CITY:
            return ColumnTypeConstants.DEFAULT_CITY_LENGTH;
        case AddressField.STATE:
            return ColumnTypeConstants.DEFAULT_STATE_LENGTH;
        case AddressField.ZIP:
            return ColumnTypeConstants.DEFAULT_ZIP_LENGTH;
        case AddressField.COUNTRY:
            return ColumnTypeConstants.DEFAULT_COUNTRY_LENGTH;
    }
    return 255;
}

AddressField.prototype.createEditElements = function() {
    var html = [];
    html.push("<table border=0>")
    
    //Logic taken from AddressInputElement.calculateDisplayForLocale()
    //Asian
    if (UserContext.locale.indexOf('ja') == 0 ||
        UserContext.locale.indexOf('zh') == 0 ||
        UserContext.locale.indexOf('ko') == 0) {
    	this.createInputElement(html, AddressField.COUNTRY);
    	this.createInputElement(html, AddressField.ZIP);
    	if (this.showState) {
	        this.createInputElement(html, AddressField.STATE);
	    }
	    this.createInputElement(html, AddressField.CITY);
	    this.createStreetElement(html);
    //German
    } else if (UserContext.locale.indexOf('de') == 0) {
		this.createStreetElement(html);
		this.createInputElement(html, AddressField.ZIP);
		this.createInputElement(html, AddressField.CITY);
		if (this.showState) {
	        this.createInputElement(html, AddressField.STATE);
	    }
    	this.createInputElement(html, AddressField.COUNTRY);
	//Non-German Swiss
	} else if (UserContext.locale.indexOf('CH') != -1) {
		this.createStreetElement(html);
		this.createInputElement(html, AddressField.CITY);
    	this.createInputElement(html, AddressField.COUNTRY);
    	if (this.showState) {
	        this.createInputElement(html, AddressField.STATE);
	    }
    	this.createInputElement(html, AddressField.ZIP);
	}
	//US English (default)
	else {
        this.createStreetElement(html);
	    this.createInputElement(html, AddressField.CITY);
	    if (this.showState) {
	        this.createInputElement(html, AddressField.STATE);
	    }
	    this.createInputElement(html, AddressField.ZIP);
	    this.createInputElement(html, AddressField.COUNTRY);
	}
    
    html.push("</table>");
    this.editDiv.innerHTML = html.join('');
    if (this.showState) {
        this.editElements[AddressField.STATE] = getElementByIdCS(this.getComponentId(AddressField.STATE));
    }
    this.editElements[AddressField.STREET] = getElementByIdCS(this.getComponentId(AddressField.STREET));
    this.editElements[AddressField.CITY] = getElementByIdCS(this.getComponentId(AddressField.CITY));
    this.editElements[AddressField.ZIP] = getElementByIdCS(this.getComponentId(AddressField.ZIP));
    this.editElements[AddressField.COUNTRY] = getElementByIdCS(this.getComponentId(AddressField.COUNTRY));
    this.elementToFocus = this.editElements[AddressField.STREET];
}

AddressField.prototype.createStreetElement = function(html) {
    html.push("<tr><td class='labelCol'>");
    html.push(this.labels[AddressField.STREET]);
    html.push("</td><td>");
    html.push("<textarea wrap='soft' type='text' id='");
    html.push(this.getComponentId(AddressField.STREET));
    html.push("' rows='");
    html.push(EditElement.STREET_NUM_ROWS);
    html.push("' cols='");
    html.push(EditElement.STREET_NUM_COLS);
    html.push("' maxlength='");
    html.push(this.getMaxLengthOfComponent(AddressField.STREET));
    html.push("'>")
    html.push(this.cleanValueNoBR(this.currentValue[AddressField.STREET]));
    html.push("</textarea>");
    html.push("</td></tr>");
}

AddressField.prototype.createInputElement = function(html, which) {
    html.push("<tr><td class='labelCol'>");
    html.push(this.labels[which]);
    html.push("</td><td>");
    html.push("<input type='text' id='");
    html.push(this.getComponentId(which));
    html.push("' value=\"");
    html.push(this.cleanValue(this.currentValue[which]));
    html.push("\" size='20' maxLength='");
    html.push(this.getMaxLengthOfComponent(which));
    html.push("'>");
    html.push("</td></tr>");
}

AddressField.prototype.formatValue = function() {
    var add = [];
    
    //Logic taken from AddressElement.format()
    //Asian
    if (UserContext.locale.indexOf('ja') == 0 ||
        UserContext.locale.indexOf('zh') == 0 ||
        UserContext.locale.indexOf('ko') == 0) {
		if (this.cleanValue(this.currentValue[AddressField.COUNTRY]) != "") {
	    	add.push(this.cleanValue(this.currentValue[AddressField.COUNTRY]));
	    	add.push("<br>");
		}
  	    add.push(this.cleanValue(this.currentValue[AddressField.ZIP]));
  	    add.push("&nbsp;");
  	    if (this.showState) {
    	    add.push(this.cleanValue(this.currentValue[AddressField.STATE]));
    	    add.push("&nbsp;");
	    }
	    add.push(this.cleanValue(this.currentValue[AddressField.CITY]));
	    add.push("<br>");
	    add.push(this.cleanValue(this.currentValue[AddressField.STREET]));
	//Scandinavian
	} else if (this.cleanValue(this.currentValue[AddressField.STATE]) == "" &&
			  (UserContext.locale.indexOf('sv') == 0 ||
			   UserContext.locale.indexOf('da') == 0 ||
			   UserContext.locale.indexOf('fi') == 0 ||
			   UserContext.locale.indexOf('no') == 0)) {
    	add.push(this.cleanValueNoBR(this.currentValue[AddressField.STREET]));
    	add.push("<br>");
	    add.push(this.cleanValue(this.currentValue[AddressField.ZIP]));
		if (this.cleanValue(this.currentValue[AddressField.ZIP]) != "" &&
	     	this.cleanValue(this.currentValue[AddressField.CITY])!= "") {
	  	    add.push("&nbsp;");	
		}
  	    add.push(this.cleanValue(this.currentValue[AddressField.CITY]));
	    if (this.cleanValue(this.currentValue[AddressField.COUNTRY]) != "") {
		    add.push("<br>");
		    add.push(this.cleanValue(this.currentValue[AddressField.COUNTRY]));
	    }
    //German
    } else if (UserContext.locale.indexOf('de') == 0) {
    	add.push(this.cleanValue(this.currentValue[AddressField.STREET]));
    	add.push("<br>");
	    add.push(this.cleanValue(this.currentValue[AddressField.ZIP]));
		if (this.cleanValue(this.currentValue[AddressField.ZIP]) != "" &&
	     	this.cleanValue(this.currentValue[AddressField.CITY])!= "") {
	  	    add.push("&nbsp;");	
		}
  	    add.push(this.cleanValue(this.currentValue[AddressField.CITY]));
  	    if (this.cleanValue(this.currentValue[AddressField.COUNTRY]) != "" ||
  	        this.cleanValue(this.currentValue[AddressField.STATE]) != "") {
		    add.push("<br>");
		    if (this.showState) {
	    	    add.push(this.cleanValue(this.currentValue[AddressField.STATE]));
	    	    add.push("&nbsp;");
		    }
		    add.push(this.cleanValue(this.currentValue[AddressField.COUNTRY]));
  	    }
    //Non-German Swiss
    } else if (UserContext.locale.indexOf('CH') != -1) {
		add.push(this.cleanValue(this.currentValue[AddressField.STREET]));
		if (this.cleanValue(this.currentValue[AddressField.STREET]) != "" &&
	     	this.cleanValue(this.currentValue[AddressField.CITY])!= "") {
	  	    add.push("<br>");	
		}
		add.push(this.cleanValue(this.currentValue[AddressField.CITY]));
        if (this.cleanValue(this.currentValue[AddressField.COUNTRY]) != "" ||
  	        this.cleanValue(this.currentValue[AddressField.STATE]) != "" ||
  	        this.cleanValue(this.currentValue[AddressField.ZIP]) != "") {
		    add.push("<br>");
		    if (this.cleanValue(this.currentValue[AddressField.COUNTRY]) != "") {
		    	add.push(this.cleanValue(this.currentValue[AddressField.COUNTRY]));
		    	add.push("&nbsp;-&nbsp;");
		    }
		    if (this.cleanValue(this.currentValue[AddressField.STATE]) != "" && this.showState) {
		    	add.push(this.cleanValue(this.currentValue[AddressField.STATE]));
		    	add.push("&nbsp;")
		    }
		    add.push(this.cleanValue(this.currentValue[AddressField.ZIP]));
        }
	//US English (default)
    } else {
	    add.push(this.cleanValue(this.currentValue[AddressField.STREET]));
	    add.push("<br>");
	    add.push(this.cleanValue(this.currentValue[AddressField.CITY]));
		if(this.cleanValue(this.currentValue[AddressField.CITY]) != "" &&
		   (this.cleanValue(this.currentValue[AddressField.STATE]) != "" ||
		    this.cleanValue(this.currentValue[AddressField.ZIP]) != "" ||
		    this.cleanValue(this.currentValue[AddressField.COUNTRY]) != "")) {
		    add.push(",&nbsp;")
		}
	    if (this.showState) {
	        add.push(this.cleanValue(this.currentValue[AddressField.STATE]));
	        add.push("&nbsp;")
	    }
	    add.push(this.cleanValue(this.currentValue[AddressField.ZIP]));
	    if (this.cleanValue(this.currentValue[AddressField.COUNTRY]) != "") {
	    	add.push("<br>");
		    add.push(this.cleanValue(this.currentValue[AddressField.COUNTRY]));
	    }
	}

    return add.join("");
}

AddressField.prototype.isDifferentValue = function(newValue) {
    return this.currentValue[AddressField.STREET] != newValue[AddressField.STREET] ||
           this.currentValue[AddressField.CITY] != newValue[AddressField.CITY] ||
           this.currentValue[AddressField.ZIP] != newValue[AddressField.ZIP] ||
           this.currentValue[AddressField.COUNTRY] != newValue[AddressField.COUNTRY] ||
           (this.showState && this.currentValue[AddressField.STATE] != newValue[AddressField.STATE]);
}

AddressField.prototype.getValueFromEdit = function() {
    var newValue = [];
    if (this.showState) {
        newValue[AddressField.STATE] = this.editElements[AddressField.STATE].value;
    }
    newValue[AddressField.STREET] = this.editElements[AddressField.STREET].value;
    newValue[AddressField.CITY] = this.editElements[AddressField.CITY].value;
    newValue[AddressField.ZIP] = this.editElements[AddressField.ZIP].value;
    newValue[AddressField.COUNTRY] = this.editElements[AddressField.COUNTRY].value;
    return newValue;
}

AddressField.prototype.updateEditElement = function() {
    if (this.showState) {
        this.editElements[AddressField.STATE].value = this.cleanValueNoBR(this.currentValue[AddressField.STATE]);
    }
    this.editElements[AddressField.STREET].value = this.cleanValueNoBR(this.currentValue[AddressField.STREET]);
    this.editElements[AddressField.CITY].value = this.cleanValueNoBR(this.currentValue[AddressField.CITY]);
    this.editElements[AddressField.ZIP].value = this.cleanValueNoBR(this.currentValue[AddressField.ZIP]);
    this.editElements[AddressField.COUNTRY].value = this.cleanValueNoBR(this.currentValue[AddressField.COUNTRY]);
}

AddressField.prototype.addSaveData = function(saveData) {
    if (this.showState) {
        saveData[this.getComponentId(AddressField.STATE)] = this.currentValue[AddressField.STATE];
    }
    saveData[this.getComponentId(AddressField.STREET)] = this.currentValue[AddressField.STREET];
    saveData[this.getComponentId(AddressField.CITY)] = this.currentValue[AddressField.CITY];
    saveData[this.getComponentId(AddressField.ZIP)] = this.currentValue[AddressField.ZIP];
    saveData[this.getComponentId(AddressField.COUNTRY)] = this.currentValue[AddressField.COUNTRY];
}



/**
 * MultiEnum's are special since they can be part of a dependency, in which case the group takes care
 * of rendering them. Otherwise they render like other compound fields but don't have separate components
 * and require dynamic loading.
 * 
 * @author jmooney
 * @since 150
 */
function MultiEnumField(id, state, required, isColumn, initialValue, extraData) {
    this.init(id, state, required, isColumn, initialValue);
    this.width = 400;
    this.picklistId = extraData["picklistId"];
    this.controllerId = extraData["controller"];
    this.controllerLabel = extraData["controllerLabel"];
    this.height = extraData["height"];
    this.waitForLoad = true;
    this.initialSelections = [];
}

MultiEnumField.H = 0; // hidden vals
MultiEnumField.U = 1; // unselected vals
MultiEnumField.S = 2; // selected vals

MultiEnumField.prototype = new InlineEditField.CompoundField();

MultiEnumField.prototype.getComponentId = function(which) {
    var suffix;
    switch (which) {
        case MultiEnumField.H:
            suffix = "";
            break;
        case MultiEnumField.U:
            suffix = EditElement.UNSELECTED_ID_SUFFIX;
            break;
        case MultiEnumField.S:
            suffix = EditElement.SELECTED_ID_SUFFIX;
            break;
    }
    return this.id + suffix;
}

MultiEnumField.prototype.createEditElements = function() {
    var attributes = [];
    attributes.push(" style='display: none;' onchange='MultiSelectPicklist.handleMSPChange(this);' size='");
    attributes.push(this.height);
    attributes.push("' multiple='multiple' id='");
    attributes.push(this.getComponentId(MultiEnumField.H));
    attributes.push("'");
    attributes = attributes.join('');
    var html = [];
    html.push("<span><select");
    html.push(attributes);
    html.push("></select></span><table border='0' cellspacing='0' cellpadding='0' class='multiSelectPicklistTable'><tr class='multiSelectPicklistRow'>");
    html.push("<td><span><select multiple='multiple' id='")
    html.push(this.getComponentId(MultiEnumField.U));
    html.push("' size='");
    html.push(this.height);
    html.push("'></select></span></td><td class='multiSelectPicklistCell'>");
    html.push("<img style='width: 17px; height: 17px; cursor: pointer;' onclick='MultiSelectPicklist.handleMSPSelect(\"");
    html.push(this.getComponentId(MultiEnumField.H));
    html.push("\");' src='/img/arrow2_picklist_right.gif'><br><br><img onclick='MultiSelectPicklist.handleMSPUnSelect(\"");
    html.push(this.getComponentId(MultiEnumField.H));
    html.push("\");' src='/img/arrow2_picklist_left.gif' style='width: 17px; height: 17px; cursor: pointer;'></td><td>");
    html.push("<span><select multiple='multiple' id='")
    html.push(this.getComponentId(MultiEnumField.S));
    html.push("' size='");
    html.push(this.height);
    html.push("'></select></span></td>");
    if (this.controllerId) {
        html.push("<td><div onmouseover='addMouseOver(this)' class='mouseOverInfoOuter'><img class='infoIcon' src='/s.gif'><div style='display: none;' class='mouseOverInfo'>");
        html.push(LC.getLabel("DependentElement", "dependsOn", this.controllerLabel));
        html.push("</div></div></td>");
    }
    html.push("</tr></table>");
    this.editDiv.innerHTML = html.join('');
    new multiPicklist(this.getComponentId(MultiEnumField.H), this.picklistId, this.controllerId, Util.convertOptionsForPicklistData(this.initialValue),
                      attributes, this.height, !this.required, false, -1);
    MultiSelectPicklist.loadMSP(this.id);
    if (!this.group) {
        this.load();
    }
}

// dependency code recreates select elements when a controlling value changes, so we have to reset them
MultiEnumField.prototype.retrieveFields = function() {
    this.editElements[MultiEnumField.H] = getElementByIdCS(this.getComponentId(MultiEnumField.H));
    this.editElements[MultiEnumField.U] = getElementByIdCS(this.getComponentId(MultiEnumField.U));
    this.editElements[MultiEnumField.S] = getElementByIdCS(this.getComponentId(MultiEnumField.S));
}

MultiEnumField.prototype.load = function() {
    picklist.picklists[this.getComponentId(MultiEnumField.H)].onLoad();
    this.retrieveFields();
    var all = this.editElements[MultiEnumField.H].options;
    for (var i = 0; i < all.length; i++) {
        this.initialSelections[i] = all[i].selected;
    }
}

MultiEnumField.prototype.showEdit = function() {
    this.retrieveFields();
    this.overlay.setActiveField(this.id);
    this.overlay.show();
    MultiSelectPicklist.resizeMSP(this.editElements[MultiEnumField.S], this.editElements[MultiEnumField.U]);
    this.width = this.editDiv.childNodes[1].offsetWidth + 50;
    this.overlay.setMaxWidth(this.width);
    this.overlay.position();
}

MultiEnumField.prototype.formatValue = function() {
    var str = [];
    for (var i = 0; i < this.currentValue.length; i++) {
        str.push(this.cleanValue(this.currentValue[i][0]));
        if (i + 1 != this.currentValue.length) {
            str.push("; ");
        }
    }
    if (str.length == 0) {
        return this.getDeletedValue();
    }
    return str.join('');
}

MultiEnumField.prototype.isDifferentValue = function(newValue) {
    if (newValue.length != this.initialValue.length) {
        return true;
    }
    for (var i = 0; i < this.initialValue.length; i++) {
        if (newValue[i][0] != this.initialValue[i][0] ||
            newValue[i][1] != this.initialValue[i][1]) {
            return true;
        }
    }
    return false;
}

MultiEnumField.prototype.getValueFromEdit = function() {
    this.retrieveFields();
    var newValue = [];
    var all = this.editElements[MultiEnumField.H].options;
    for (var i = 0; i < all.length; i++) {
        if (all[i].selected) {
            newValue.push([all[i].text, all[i].value]);
        }
    }
    return newValue;
}

MultiEnumField.prototype.updateEditElement = function() {
    this.retrieveFields();
    var options = this.editElements[MultiEnumField.H].options;
    for (var i = 0; i < options.length; i++) {
        options[i].selected = this.initialSelections[i];
    }
    this.editElements[MultiEnumField.H].onchange();
}

MultiEnumField.prototype.addSaveData = function(saveData) {
    var values = [];
    if (!this.created && this.required && this.controllerId && !this.initialValue) {
        values.push(picklistNAMarker);
    } else {
        var vals = this.created ? this.getValueFromEdit() : this.currentValue;
        for (var i = 0; i < vals.length; i++) {
            values.push(vals[i][1]);
        }
    }
    saveData[this.id] = values;
}



/**
 * text area field
 * 
 * @author jmooney
 * @since 150
 */
function MultiLineTextField(id, state, required, isColumn, initialValue, extraData) {
    // hack to disable html fields
    if (extraData["isHtml"]) {
        state = InlineEditState.NONE;
    }
    this.init(id, state, required, isColumn, initialValue);
    this.maxLength = extraData["maxLength"];
    if (window.ActiveXObject) {
        this.width = 380;
    } else {
        this.width = 500;
    }
}

MultiLineTextField.prototype = new InlineEditField.CompoundField();

MultiLineTextField.prototype.createEditElements = function() {
    var html =[];
    html.push("<textarea type='text' wrap='soft' maxlength='");
    html.push(this.maxLength);
    html.push("'");
    html.push(" rows='6'");
    html.push(" cols='60'");
    html.push(" id='");
    html.push(this.id);
    html.push("'>");
    html.push(this.cleanValueNoBR(this.currentValue));
    html.push("</textarea>");
    
    html.push("<div class='textCounterMiddle'>");
    html.push("<div class='textCounter'");
    html.push(" id='");
    html.push(this.id)
    html.push("_counter'>")
    html.push("</div>");
    html.push("</div>");
    this.editDiv.innerHTML = html.join('');
    this.editElement = getElementByIdCS(this.id);
    this.elementToFocus = this.editElement;
    
    this.attachCountHandler();
}

MultiLineTextField.prototype.attachCountHandler = function() {
	var hid = this.id;
	var hmaxlength = this.maxLength;
	var remaining = LC.getLabel("Edit", "CharactersRemaining");
	var over = LC.getLabel("Edit", "CharactersOver");
	var handler = function () {
		handleTextAreaElementChange(hid, hmaxlength, remaining, over);
	};
	
	var attrs = window.ActiveXObject ? ["propertychange", "focus"] : ["keydown", "keyup", "change", "click", "mousedown", "focus"];
	for (var i in attrs) {
    	addEvent(this.editElement, attrs[i], handler, true);
    }
}

MultiLineTextField.prototype.addSaveData = function(saveData) {
    saveData[this.id] = this.currentValue;
}

MultiLineTextField.prototype.isDifferentValue = function(newValue) {
    return this.initialValue != newValue;
}

/**
 * retrieve the current value from the edit element
 */
MultiLineTextField.prototype.getValueFromEdit = function() {
    return this.editElement.value;
}

MultiLineTextField.prototype.formatValue = function() {
    if (this.currentValue === "" && this.initialValue !== "") {
        return this.getDeletedValue();
    } else {
        return this.cleanValue(this.currentValue);
    }
}

MultiLineTextField.prototype.updateEditElement = function() {
    this.editElement.value = this.currentValue;
}



//#depend common.udd.InlineEditField

/**
 * Base field object for simple fields which open inside the detail table
 * 
 * @author jmooney
 * @since 150
 */
InlineEditField.SimpleField = function() {
    this.editElement = null;
    this.group = null;
    this.saveOnEnter = true;
}

InlineEditField.SimpleField.prototype = new InlineEditField();

/**
 * add data needed for save to post map
 */
InlineEditField.SimpleField.prototype.addSaveData = function(saveData) {
    saveData[this.id] = this.currentValue;
}

/**
 * open this field for editing
 */
InlineEditField.SimpleField.prototype.openField = function() {
    if (!this.created) {
        this.createEditDiv();
    }
    this.showEdit();
}

/**
 * Create the edit container and elements inside of the table cell
 */
InlineEditField.SimpleField.prototype.createEditDiv = function() {
    this.editDiv = document.createElement("div");
    if (this.required) {
        this.editDiv.className = "inlineEditRequiredDiv";
    } else {
        this.editDiv.className = "inlineEditDiv";
    }
    
    if (this.group) {
    	this.editDiv.className = this.editDiv.className + " inlineEditGroup"
    }
    
    this.editDiv.id = this.id + InlineEditConstants.INNER_ID + "edit";
    if (this.errorDiv) {
        this.tableCell.insertBefore(this.editDiv, this.errorDiv);
    } else {
        this.tableCell.appendChild(this.editDiv);
    }
    this.createEditElements();
    if (this.error && !this.group) {
        this.editElement.className = EditElement.ERROR_CLASS;
    }
    this.createUndoButton();
    if (!this.group) {
        var self = this;
        addEvent(this.editElement, "keypress", function(e) { self.handleKeyPress(e); }, true);
    }
    this.created = true;
}

/**
 * handles keyboard events on the individual edit elements
 */
InlineEditField.SimpleField.prototype.handleKeyPress = function(e) {
    e = getEvent(e);
    var key = e.keyCode;
    
    if (key == KEY_ESC) {
        this.reset();
        eventCancelBubble(e);
    } else if (key == KEY_ENTER && this.saveOnEnter) {
        this.closeField();
        sfdcPage.inlineEditData.currentField = null;
        eventCancelBubble(e);
        setTimeout(function() { sfdcPage.focusOnSave(); }, 10);
    }
}

/**
 * hide the data element, show the edit element
 */
InlineEditField.SimpleField.prototype.showEdit = function() {
    this.readDiv.style.display = "none";
    if (this.undoButton.parentNode != this.editDiv) {
        this.editDiv.appendChild(this.undoButton);
    }
    this.undoButton.style.display = "inline";
    this.editDiv.style.display = "block";
    this.editElement.focus();
    if (this.editElement.type == "text") {
        this.editElement.select();
    }
}

/**
 * hide the edit element, show the data element
 */
InlineEditField.SimpleField.prototype.hideEdit = function() {
    this.editElement.blur();
    this.editDiv.style.display = "none";
    if (this.changed) {
        this.readDiv.appendChild(this.undoButton);
    }
    this.readDiv.style.display = "block";
}

/**
 * close this field
 */
InlineEditField.SimpleField.prototype.closeField = function() {
    var newValue = this.getValueFromEdit();
    if (this.isDifferentValue(newValue)) {
        if (!this.changed) {
            this.changed = true;
            addStyleClass(this.readDiv, "inlineEditModified");
        }
        this.currentValue = newValue;
        this.updateReadElement();
    } else if (this.changed) {
        this.reset();
        return;
    }
    if (!this.group) {
        this.hideEdit();
    }
}

InlineEditField.SimpleField.prototype.isDifferentValue = function(newValue) {
    return this.initialValue != newValue;
}

/**
 * resets this field back to its initial value
 */
InlineEditField.SimpleField.prototype.reset = function() {
    this.currentValue = this.initialValue;
    delStyleClass(this.readDiv, "inlineEditModified");
    this.changed = false;
    this.undoButton.style.display = "none";
    this.editDiv.appendChild(this.undoButton);
    this.readDiv.innerHTML = this.initialHTML;
    if (sfdcPage.inlineEditData.isCurrentField(this)) {
        this.hideEdit();
        sfdcPage.inlineEditData.currentField = null;
    }
    this.clearError();
    this.updateEditElement();
}

/**
 * retrieve the current value from the edit element
 */
InlineEditField.SimpleField.prototype.getValueFromEdit = function() {
    return this.editElement.value;
}

/**
 * upadte the data element with the current value
 */
InlineEditField.SimpleField.prototype.updateReadElement = function() {
    this.readDiv.innerHTML = this.formatValue();
}

/**
 * gets the display value for this field based on its current value, html included.
 * this is almost always used by updateReadElement
 */
InlineEditField.SimpleField.prototype.formatValue = function() {
    if (this.currentValue === "" && this.initialValue !== "") {
        return this.getDeletedValue();
    } else {
        return this.cleanValue(this.currentValue);
    }
}

/**
 * update the edit element with the current value
 */
InlineEditField.SimpleField.prototype.updateEditElement = function() {
    this.editElement.value = this.currentValue;
}

/**
 * sets a validation error on this field
 */
InlineEditField.SimpleField.prototype.setError = function(message) {
    InlineEditField.prototype.setError.call(this, message);
    if (this.editElement) {
        this.editElement.className = EditElement.ERROR_CLASS;
    }
}

/**
 * clears any validation errors on this field
 */
InlineEditField.SimpleField.prototype.clearError = function() {
    InlineEditField.prototype.clearError.call(this);
    if (this.editElement) {
        this.editElement.className = "";
    }
}

/** ----- SIMPLE FIELDS ----- */


/**
 * a checkbox for boolean values. can be part of a group as a controller field
 * 
 * @author jmooney
 * @since 150
 */
function BooleanField(id, state, required, isColumn, initialValue, extraData) {
    this.init(id, state, required, isColumn, initialValue);
    // get the existing image, it already has a unique id based on the field's id
    this.checkboxImage = getElementByIdCS(this.id + EditElement.CHECKBOX_SUFFIX);
    this.checkLabel = LC.getLabel("Images", "checkbox_checked");
    this.uncheckLabel = LC.getLabel("Images", "checkbox_unchecked");
}

BooleanField.prototype = new InlineEditField.SimpleField();

BooleanField.prototype.createEditElements = function() {
    var html = [];
    html.push("<input type='checkbox' id='");
    html.push(this.id);
    html.push("'");
    if (this.currentValue) html.push(" checked='checked'");
    html.push(">");
    this.editDiv.innerHTML = html.join('');
    this.editElement = getElementByIdCS(this.id);
}

BooleanField.prototype.createDummy = function() {
    var dummy = document.createElement("input");
    dummy.type = "hidden";
    dummy.id = this.id;
    dummy.value = this.currentValue ? "1" : "0";
    this.tableCell.appendChild(dummy);
    this.created = true;
}

BooleanField.prototype.getValueFromEdit = function() {
    return this.editElement.checked;
}

// just updates the img src instead of replacing the html entirely
BooleanField.prototype.updateReadElement = function() {
    this.checkboxImage.src = this.currentValue ? "/img/checkbox_checked.gif" : "/img/checkbox_unchecked.gif";
}

BooleanField.prototype.formatValue = function() {
    var html = [];
    html.push('<img src="');
    html.push(this.currentValue ? '/img/checkbox_checked.gif' : '/img/checkbox_unchecked.gif');
    html.push('" width="21" height="16" alt="');
    html.push(this.currentValue ? this.checkLabel : this.uncheckLabel);
    html.push('" class="checkImg">');
    return html.join('');
}

BooleanField.prototype.updateEditElement = function() {
    this.editElement.checked = this.currentValue;
    // if its part of a dependency group then it should fire onclick
    if (this.editElement.onclick) {
        this.editElement.onclick();
    }
}

// have to always post the value of booleans or they default to false
BooleanField.prototype.addSaveData = function(saveData) {
    saveData[this.id] = this.currentValue ? "1" : "0";
}

// don't need to replace the entire read div in this case, just update the img src
BooleanField.prototype.reset = function() {
    this.currentValue = this.initialValue;
    delStyleClass(this.readDiv, "inlineEditModified");
    this.changed = false;
    this.updateReadElement();
    if (!this.group) {
        if (sfdcPage.inlineEditData.isCurrentField(this)) {
            this.hideEdit();
            sfdcPage.inlineEditData.currentField = null;
        }
    }
    this.undoButton.style.display = "none";
    this.clearError();
    this.updateEditElement();
}


/**
 * Simple text field
 * 
 * @author jmooney
 * @since 150
 */
function TextField(id, state, required, isColumn, initialValue, extraData) {
    this.init(id, state, required, isColumn, initialValue);
    if (extraData["maxLength"]) {
        this.maxLength = extraData["maxLength"];
    } else {
        this.maxLength = 255;
    }
}

TextField.prototype = new InlineEditField.SimpleField();

TextField.prototype.createEditElements = function() {
    var html = [];
    html.push("<input type='text' id='");
    html.push(this.id);
    html.push("' value=\"");
    html.push(this.cleanValue(this.currentValue));
    html.push("\" size='20' maxLength='");
    html.push(this.maxLength);
    html.push("'>");
    this.editDiv.innerHTML = html.join('');
    this.editElement = getElementByIdCS(this.id);
}


/**
 * Simple number field rendered with a text input element
 * 
 * @author jmooney
 * @since 150
 */
function NumberField(id, state, required, isColumn, initialValue, extraData) {
    this.init(id, state, required, isColumn, initialValue);
}

NumberField.prototype = new InlineEditField.SimpleField();

NumberField.prototype.createEditElements = function() {
    var html = [];
    html.push("<input type='text' id='");
    html.push(this.id);
    html.push("' value=\"");
    html.push(this.cleanValue(this.currentValue));
    html.push("\">");
    this.editDiv.innerHTML = html.join('');
    this.editElement = getElementByIdCS(this.id);
}


/**
 * Date fields with or without time, using the new date picker
 * 
 * @author jmooney
 * @since 150
 */
function DateField(id, state, required, isColumn, initialValue, extraData) {
    this.init(id, state, required, isColumn, initialValue);
    this.hasTime = extraData["hasTime"];
}

DateField.prototype = new InlineEditField.SimpleField();

DateField.prototype.createEditElements = function() {
    var html = [];
    html.push("<input type='text' id='");
    html.push(this.id);
    html.push("' value=\"");
    html.push(this.cleanValue(this.currentValue));
    html.push("\" onFocus=\"DatePicker.pickDate(true, '");
    html.push(this.id);
    html.push("', ");
    html.push(this.hasTime);
    html.push(");\">");
    this.editDiv.innerHTML = html.join('');
    this.editElement = getElementByIdCS(this.id);
}

DateField.prototype.hideEdit = function() {
    InlineEditField.SimpleField.prototype.hideEdit.apply(this);
    DatePicker.datePicker.hide();
}


/**
 * Simple text field with an onblur handler to format phone numbers
 * 
 * @author jmooney
 * @since 150
 */
function PhoneField(id, state, required, isColumn, initialValue, extraData) {
    this.init(id, state, required, isColumn, initialValue);
    this.formatPhone = extraData["formatPhone"];
}

PhoneField.prototype = new InlineEditField.SimpleField();

PhoneField.prototype.createEditElements = function() {
    var html = [];
    html.push("<input type='text' id='");
    html.push(this.id);
    html.push("' value='");
    html.push(this.currentValue);
    html.push("'");
    if (this.formatPhone) {
        html.push(" onblur='formatPhone(this);'");
        html.push(" onkeydown='formatPhoneOnEnter(this, event);'");
    }
    html.push(">");
    this.editDiv.innerHTML = html.join('');
    this.editElement = getElementByIdCS(this.id);
}


/**
 * Lookup fields, works with mutli lookups (multiple domains)
 * 
 * @author jmooney
 * @since 150
 */
function ForeignKeyField(id, state, required, isColumn, initialValue, extraData) {
    this.init(id, state, required, isColumn, initialValue);
    this.domains = extraData["domain"];
    this.useNewLookups = extraData["useNewLookups"];
    this.idElement = null;
    this.oldElement = null;
    this.domainElement = null;
    this.initialDomain = 0;
}

ForeignKeyField.prototype = new InlineEditField.SimpleField();

ForeignKeyField.ID = 0;
ForeignKeyField.OLD = 1;
ForeignKeyField.DOMAIN = 2;

/**
 * borrowing this from compound fields since lookups have so many components
 */
ForeignKeyField.prototype.getComponentId = function(which) {
    var suffix;
    switch (which) {
        case ForeignKeyField.ID:
            suffix = EditElement.pID_SUFFIX;
            break;
        case ForeignKeyField.OLD:
            suffix = EditElement.pOLD_NAME_SUFFIX;
            break;
        case ForeignKeyField.DOMAIN:
            suffix = EditElement.pTYPE_SUFFIX;
            break;
    }
    return this.id + suffix;
}

ForeignKeyField.prototype.createEditElements = function() {
    // these fields need to have names since lookupPick is terrible
    var alt = this.getFieldLabel() + " " + LC.getLabel("Icons", "lookup");
    var html = [];
    html.push("<span class='lookupInput'>");
    if (this.domains.length > 1) {
        var change = 'getElementByIdCS("' + this.getComponentId(ForeignKeyField.ID) + '").value = "";getElementByIdCS("' + this.id + '").value = "";';
        html.push(Util.createDynamicSelect({id: this.getComponentId(ForeignKeyField.DOMAIN), onchange: change }, this.domains, false));
    }
    html.push("<input type='hidden' id='");
    html.push(this.getComponentId(ForeignKeyField.ID));
    html.push("' name='");
    html.push(this.getComponentId(ForeignKeyField.ID));
    html.push("' value='");
    html.push(this.currentValue[1]);
    html.push("'><input type='hidden' id='");
    html.push(this.getComponentId(ForeignKeyField.OLD));
    html.push("' name='");
    html.push(this.getComponentId(ForeignKeyField.OLD));
    html.push("' value=\"");
    html.push(this.cleanValue(this.currentValue[0]));
    html.push("\"><input type='text' size='20' maxlength='255' id='");
    html.push(this.id);
    html.push("' name='");
    html.push(this.id);
    html.push("' value=\"");
    html.push(this.cleanValue(this.currentValue[0]));
    html.push("\"><a href='' id='");
    html.push(this.id);
    html.push("Icon' title='");
    html.push(alt);
    html.push("'><img onmouseover=\"this.className='lookupIconOn';\" alt='");
    html.push(alt);
    html.push("' onmouseout=\"this.className='lookupIcon';\" class='lookupIcon' src='/s.gif'></a></span>");
    this.editDiv.innerHTML = html.join('');
    var self = this;
    var handler = function(e) {
        setLastMousePosition(e);
        self.openLookup();
        if (e.preventDefault) {
            e.preventDefault();
        } else {
            e.returnValue = false;
        }
    };
    addEvent(getElementByIdCS(this.id + "Icon"), "click", handler, false);
    this.editElement = getElementByIdCS(this.id);
    this.idElement = getElementByIdCS(this.getComponentId(ForeignKeyField.ID));
    this.oldElement = getElementByIdCS(this.getComponentId(ForeignKeyField.OLD));
    if (this.domains.length > 1) {
        this.domainElement = getElementByIdCS(this.getComponentId(ForeignKeyField.DOMAIN));
        // find the domain of the initial value
        for (var i = 0; i < this.domains.length; i++) {
            if (this.initialValue[1].indexOf(this.domains[i][1]) == 0) {
                this.initialDomain = i;
                break;
            }
        }
        this.domainElement.selectedIndex = this.initialDomain;
    }
}

ForeignKeyField.prototype.openLookup = function() {
    var mod = this.editElement.value !== this.initialValue[0] ? "1" : "0";
    var domain;
    if (this.domains.length > 1) {
        domain = this.domainElement.options[this.domainElement.selectedIndex].value;
    } else {
        domain = this.domains[0][1];
    }
    
    if (this.useNewLookups) {
        if(!window.lookupElement){
            window.lookupElement = new LookupElement();
        }
        window.lookupElement.openLookup("/_ui/common/data/LookupPage?lknm=" + this.id + "&lktp=" + domain, 670, mod, '&lksrch=' + escapeUTF(this.editElement.value));
    } else {
        openLookup("/_ui/common/data/LookupPage?lknm=" + this.id + "&lktp=" + domain, 670, mod, '&lksrch=' + escapeUTF(this.editElement.value));
    }
}

ForeignKeyField.prototype.getValueFromEdit = function() {
    return [this.editElement.value, this.idElement.value];
}

ForeignKeyField.prototype.isDifferentValue = function(newValue) {
    return this.initialValue[0] != newValue[0] || this.initialValue[1] != newValue[1];
}

ForeignKeyField.prototype.formatValue = function() {
    if (this.currentValue[0] === "" && this.initialValue[1] !== Udd.EMPTY_KEY) {
        return this.getDeletedValue();
    } else {
        return this.cleanValue(this.currentValue[0]);
    }
}

ForeignKeyField.prototype.updateEditElement = function() {
    if (this.domains.length > 1) {
        this.domainElement.selectedIndex = this.initialDomain;
    }
    this.editElement.value = this.currentValue[0];
    this.oldElement.value = this.currentValue[0];
    this.idElement.value = this.currentValue[1];
}

ForeignKeyField.prototype.addSaveData = function(saveData) {
    saveData[this.id] = this.currentValue[0];
    saveData[this.getComponentId(ForeignKeyField.ID)] = this.currentValue[1];
    if (this.created) {
        saveData[this.getComponentId(ForeignKeyField.OLD)] = this.oldElement.value;
    } else {
        saveData[this.getComponentId(ForeignKeyField.OLD)] = this.currentValue[0];
    }
}


/**
 * Simple picklist where all value are known beforehand
 * 
 * @author jmooney
 * @since 150
 */
function StaticEnumField(id, state, required, isColumn, initialValue, extraData) {
    this.init(id, state, required, isColumn, initialValue);
    this.picklistData = extraData["picklistData"].slice();
    this.initialIndex = -1;
    this.currentIndex = -1;
    this.showNone = !required;
    for (var i = 0; i < this.picklistData.length; i++) {
        if (this.picklistData[i][0] == this.initialValue) {
            this.initialIndex = i;
            this.currentIndex = i;
            break;
        }
    }
    if (this.initialIndex == -1) {
        this.showNone = true;
    }
    if (this.showNone) {
        this.picklistData.unshift([LC.getLabel("SelectElement", "Required"), '']);
        this.initialIndex++;
        this.currentIndex++;
    }
}

StaticEnumField.prototype = new InlineEditField.SimpleField();

StaticEnumField.prototype.createEditElements = function() {
    this.editDiv.innerHTML = Util.createDynamicSelect({ id: this.id}, this.picklistData, false);
    this.editElement = getElementByIdCS(this.id);
    this.editElement.selectedIndex = this.initialIndex;
}

StaticEnumField.prototype.getValueFromEdit = function() {
    this.currentIndex = this.editElement.selectedIndex;
    return this.currentIndex;
}

StaticEnumField.prototype.formatValue = function() {
    var text = this.editElement.options[this.currentIndex].text;
    if (text == LC.getLabel("SelectElement", "Required")) {
        return this.getDeletedValue();
    } else {
        return this.cleanValue(text);
    }
}

StaticEnumField.prototype.isDifferentValue = function(newValue) {
    return this.initialIndex != newValue;
}

StaticEnumField.prototype.updateEditElement = function() {
    this.currentIndex = this.initialIndex;
    this.editElement.selectedIndex = this.currentIndex;
}

StaticEnumField.prototype.addSaveData = function(saveData) {
    if (this.created) {
        saveData[this.id] = this.editElement.options[this.currentIndex].value;
    } else {
        saveData[this.id] = this.picklistData[this.currentIndex][1];
    }
}


/**
 * Dynamic picklists rendered with a select element, can be part of a dependency group.
 * Require retrieving extra data from the picklist servlet
 * 
 * @author jmooney
 * @since 150
 */
function DynamicEnumField(id, state, required, isColumn, initialValue, extraData) {
    this.init(id, state, required, isColumn, initialValue);
    // separate the filter from the initial value
    this.initialValue = [initialValue[0], initialValue[1]];
    this.currentValue = this.initialValue;
    this.filterValue = initialValue[2];
    this.picklistId = extraData["picklistId"];
    this.controllerId = extraData["controller"];
    this.controllerLabel = extraData["controllerLabel"];
    this.waitForLoad = true;
    this.initialIndex = 0;
    this.currentIndex = 0;
}

DynamicEnumField.prototype = new InlineEditField.SimpleField();

DynamicEnumField.prototype.isDifferentValue = function(newValue) {
    return this.initialValue[1] != newValue;
}

DynamicEnumField.prototype.createEditElements = function() {
    // dyanmic enums are special, use the actual fieldId, and not the ile edit element id so they match the dependency mappings
    var html = [];
    if (this.controllerId) {
        html.push("<span style='white-space: nowrap;'>");
    }
    html.push("<span><select id='");
    html.push(this.id);
    html.push("'><option selected value=\"");
    html.push(this.cleanValue(this.currentValue[1]));
    html.push("\">");
    html.push(this.cleanValue(this.currentValue[0]));
    html.push("</select></span>");
    if (this.controllerId) {
        html.push("<div onmouseover='addMouseOver(this)' class='mouseOverInfoOuter'><img class='infoIcon' src='/s.gif'><div style='display: none;' class='mouseOverInfo'>");
        html.push(LC.getLabel("DependentElement", "dependsOn", this.controllerLabel));
        html.push("</div></div>");
    }
    this.editDiv.innerHTML = html.join('');
    //initialize the picklist, initially valid
    var att = " id=\"" + this.id + "\"";
    //create picklists map now so that picklist setup doesn't mess with onload
    if (!picklist.picklists) {
        picklist.picklists = {};
    }
    new picklist(this.id, this.picklistId, this.controllerId, Util.convertOptionsForPicklistData([this.initialValue]), att, !this.required, true, this.filterValue);
    // if we aren't in a dependency, then load, dependent picklists have to load as a group
    if (!this.group) {
        this.load();
    }
}

DynamicEnumField.prototype.createDummy = function() {
    var dummy = document.createElement("input");
    dummy.type = "hidden";
    dummy.id = this.id;
    dummy.value = this.currentValue[1];
    this.tableCell.appendChild(dummy);
    this.created = true;
}

DynamicEnumField.prototype.load = function() {
    picklist.picklists[this.id].onLoad();
    this.editElement = getElementByIdCS(this.id);
    this.initialIndex = this.editElement.selectedIndex;
    this.currentIndex = this.initialIndex;
}

DynamicEnumField.prototype.getValueFromEdit = function() {
    this.editElement = getElementByIdCS(this.id);
    this.currentIndex = this.editElement.selectedIndex;
    return this.editElement.options[this.currentIndex].value;
}

DynamicEnumField.prototype.formatValue = function() {
    this.editElement = getElementByIdCS(this.id);
    var text = this.editElement.options[this.currentIndex].text;
    if (text == LC.getLabel("SelectElement", "Required")) {
        if (this.initialValue[1] === "") {
            return "";
        } else {
            return this.getDeletedValue();
        }
    } else {
        return this.cleanValue(text);
    }
}

DynamicEnumField.prototype.reset = function() {
    if (this.group) {
        this.currentValue = this.initialValue;
        delStyleClass(this.readDiv, "inlineEditModified");
        this.changed = false;
        this.readDiv.innerHTML = this.initialHTML;
        this.undoButton.style.display = "none";
        this.clearError();
        this.updateEditElement();
    } else {
        InlineEditField.SimpleField.prototype.reset.apply(this);
    }
}

DynamicEnumField.prototype.updateEditElement = function() {
    this.editElement = getElementByIdCS(this.id);
    this.currentIndex = this.initialIndex;
    this.editElement.selectedIndex = this.currentIndex;
    if (this.editElement.onchange) {
        this.editElement.onchange();
    }
}

DynamicEnumField.prototype.addSaveData = function(saveData) {
    if (!this.created && this.required && this.controllerId && !this.initialValue[1]) {
        saveData[this.id] = picklistNAMarker;
    } else if (typeof this.currentValue == "string") {
        saveData[this.id] = this.currentValue;
    } else {
        saveData[this.id] = this.currentValue[1];
    }
}


/**
 * Simple text element with extra handlers for encrypted fields
 * 
 * @author jmooney
 * @since 150
 */
function EncryptedTextField(id, state, required, isColumn, initialValue, extraData) {
    this.init(id, state, required, isColumn, initialValue);
    this.maxLength = extraData["maxLength"];
    this.masked = extraData["masked"];
    this.encryptedElement = null;
}

EncryptedTextField.prototype = new InlineEditField.SimpleField();

EncryptedTextField.prototype.createEditElements = function() {
    var html = [];
    html.push("<input type='text' id='");
    html.push(this.id);
    html.push("' value=\"");
    html.push(this.cleanValue(this.currentValue));
    html.push("\" size='20' maxLength='");
    if (this.masked) {
        html.push("255");
    } else {
        html.push(this.maxLength);
    }
    html.push("'>");
    this.editDiv.innerHTML = html.join('');
    this.editElement = getElementByIdCS(this.id);
    if (this.masked) {
        this.encryptedElement = new EncryptedTextInputElement(this.editElement.id, this.maxLength, this.masked);
    }
}

EncryptedTextField.prototype.reset = function() {
    InlineEditField.SimpleField.prototype.reset.apply(this);
    if (this.masked && this.encryptedElement) {
        this.encryptedElement.wasCleared = false;
    }
}


//#depend common.html.MenuButton
/*
 * @author agusev
 * @since 154
 * Tag link edit menu button
 *
 */


function TagLinkEditElement(id, useDefaulAction, tagLinkUrl) {
    MenuButton.call(this, id, useDefaulAction);
    this.tagLinkUrl = tagLinkUrl;
}

TagLinkEditElement.prototype = new MenuButton();

TagLinkEditElement.prototype.defaultAction = function() {
   navigateToUrl(this.tagLinkUrl);
}

TagLinkEditElement.prototype.defaultActionCondition = function (xLocation, event) {
    // prevent navigating window on dhtml action call
    var element = event.target? event.target: event.srcElement;
    if (element) {
        var offsetDifference = XBrowser.userAgent.isIE ? 25 : 0;
        return (xLocation < (this.parentDiv.offsetWidth - this.buttonWidth + offsetDifference)) && this.parentDiv.id + MenuButtonElement.BUTTON == element.id;
    } else {
        return (xLocation < this.parentDiv.offsetWidth - this.buttonWidth)
    }
}

TagLinkEditElement.prototype.show_hook = function() {
    if (window.sfdcPage.setMenuButtonOpen) {
        window.sfdcPage.setMenuButtonOpen(this.parentDiv);
    }
}

TagLinkEditElement.prototype.hide_hook = function() {
    if (window.sfdcPage.setMenuButtonClosed) {
        window.sfdcPage.setMenuButtonClosed();
    }
}

TagLinkEditElement.prototype.initAccessibilityMode = function() {}
//#depend common.html.MenuButton

/**
 * Menu button for tag mru in the sidebar. Loads menu items asynchronously.
 */
function TagMenuButton(muttonId, loaderURL) {
    MenuButton.call(this, muttonId, false);
    TagMenuButton.fetched = false;
    TagMenuButton.requesting = false;
    this.loaderURL = loaderURL;
    this.buttonWidth = TagMenuButton.BUTTON_WIDTH;
}

TagMenuButton.prototype = new MenuButton();

TagMenuButton.BUTTON_WIDTH = 33;

TagMenuButton.prototype.show = function() {
    if (!TagMenuButton.fetched) {
        this.getMRUTags(this.muttonId, this.isCached, this.loaderURL);
    }
    MenuButton.prototype.show.apply(this);
}

TagMenuButton.prototype.getMRUTags = function() {
    if (!TagMenuButton.requesting) {
        TagMenuButton.requesting = true;
        this.menuDiv.innerHTML = "";
        this.addOption(LC.getLabel("Page_SearchResult", "dhtmlLoading"), "");
        var self = this;
        XBrowser.postHttpResponse(this.loaderURL, function(response) { self.processMRUdata(response.responseText); }, "");
    }
}

TagMenuButton.prototype.processMRUdata = function(responseText) {
    var response = Util.evalAjaxServletOutput(responseText);
    var mruList = response.mruList;
    TagMenuButton.fetched = true;
    TagMenuButton.requesting = false;
    if (mruList.length == 0) {
        this.menuDiv.innerHTML = LC.getLabel("BrowseTags", "noRecentTags");
    } else {
        this.menuDiv.innerHTML = "";
        for (var i = 0; i < mruList.length; i++) {
            this.addOption(mruList[i].value, mruList[i].href);
        }
    }
    // needed to resize after adding options
    this.position();
}

TagMenuButton.flushCache = function() {
    TagMenuButton.fetched = false;
}

//#depend ListPage
function PrintableListPage() {}

PrintableListPage.prototype = new ListPage();
//#depend common.html.OverlayDialog
/**
 * BouncedEmailAddressDialog
 * Displays overlay for displaying bounced email address reason and date and
 * providing a means to mark the email addrss valid.
 *
 * @author ccopek
 * @since 154
 */

function BouncedEmailAddressDialog(id, saveLocation, linkId) {
    this.id = id;
    this.isModal = true;
    this.formId = "bouncedEmailAddressOverlayInputForm";
    this.errorElementId = "errorMsg";
    this.windowName = "";
    this.width = 400;
    this.linkId = linkId;
    this.emailAddress = document.getElementById(BounceEmailConstants.HIDDEN_EMAIL_ADDRESS).value;
    this.emailBounceReason = document.getElementById(BounceEmailConstants.HIDDEN_BOUNCE_REASON).value;
    this.emailBounceDate = document.getElementById(BounceEmailConstants.HIDDEN_BOUNCE_DATE).value;
    this.saveLocation = saveLocation;
    this.addEvents();
}

BouncedEmailAddressDialog.HEIGHT = 80;
BouncedEmailAddressDialog.prototype = new OverlayDialog();

BouncedEmailAddressDialog.prototype.showBouncedEmail = function(){
    this.setTitle(LC.getLabel("Page_BouncedEmailOverlay","page_title"));
    this.createContent();
    this.show();
    this.focusInOverlay();
}

BouncedEmailAddressDialog.prototype.createContent = function(){
	var content = document.getElementById(this.getContentId());
    var html = [];
    var emailAddressLabel = LC.getLabel("Page_BouncedEmailOverlay","emailAddress");
    html.push('<table border="0">');
    html.push('<tr><td>');
    html.push(emailAddressLabel);
    html.push('</td><td>');
    html.push('<input id="overlayEmailAddress" type="text" size="30" name="emailAddress" title="' + emailAddressLabel + '" value="' + this.emailAddress + '"/>');
    html.push('</td></tr>');
    html.push('<tr><td>');
    html.push(LC.getLabel("Page_BouncedEmailOverlay","bounceReason"));
    html.push('</td><td>');
    html.push(this.emailBounceReason);
    html.push('</td></tr>');
    html.push('<tr><td>');
    html.push(LC.getLabel("Page_BouncedEmailOverlay","bounceDate"));
    html.push('</td><td>');
    html.push(this.emailBounceDate);
    html.push('</td></tr>');
    html.push('</table>');

    html.push("<div class='buttons'>");
    // Make Valid button
    var makeValidLabel = LC.getLabel("Page_BouncedEmailOverlay","makeValidButton");
    html.push("<input class='btn' type='button' value='");
    html.push(makeValidLabel);
    html.push("' title='");
    html.push(makeValidLabel);
    html.push("' onclick=\"");
    html.push("if(sfdcPage.getDialogById('");
    html.push(this.id);
    html.push("').savePage()) { sfdcPage.getDialogById('");
    html.push(this.id);
    html.push("').hide(); }\">");

	// Cancel button
	var cancelLabel = LC.getLabel("Buttons","cancel");
    html.push("<input class='btn' type='button' value='");
    html.push(cancelLabel);
    html.push("' title='");
    html.push(cancelLabel);
    html.push("' onclick=\"");
    html.push("sfdcPage.getDialogById('");
    html.push(this.id);
    html.push("').cancel(); document.getElementById('");
    html.push(this.linkId);
    html.push("').focus();\">");

    html.push("</div>");

    content.innerHTML = html.join("");
}

BouncedEmailAddressDialog.prototype.focusInOverlay = function(){
    document.getElementById('overlayEmailAddress').focus();
}

BouncedEmailAddressDialog.prototype.savePage = function() {
	// Need to add the email address collected on the overlay to the saveLocation
	var emailAddress = document.getElementById('overlayEmailAddress');
	var newSaveLocation = this.saveLocation + '&' + EmailAddrEditConstants.pPASS_IN_EMAIL_ADDRESS + '=' + escape(emailAddress.value);
	// Go to new Location which will execute the save and redisplay the entity detail page.
	window.location = newSaveLocation;
	return true;
}

BouncedEmailAddressDialog.getDialog = function(id, saveLocation, linkId) {
    var dialog = sfdcPage.getDialogById(id);
    if (dialog) {
        return dialog;
    }
    dialog = new BouncedEmailAddressDialog(id, saveLocation, linkId);
    dialog.register();
    return dialog;
}

//#depend common.html.OverlayDialog
/**
 * GoogleDocNameInputDialog
 *
 * @author mpatnaikuni
 * @since 152
 */


function GoogleDocNameInputDialog(id, url, escapeParams, parentId) {
    this.id = id;
    this.url = url;
    this.escapeParams = escapeParams;
    this.parentId = parentId;
    this.isModal = true;
    this.formId = "nameInputForm";
    this.errorElementId = "errorMsg";
    this.windowName = "createDoc";
    this.width = 370;
    this.setupDefaultButtons();
    this.overrideButton(0, LC.getLabel("GoogleDocCreatorPage","pageTitle"), "sfdcPage.getDialogById('" + this.id + "').validate()");
    this.addEvents();
}

GoogleDocNameInputDialog.HEIGHT = 80;
GoogleDocNameInputDialog.prototype = new OverlayDialog();


GoogleDocNameInputDialog.prototype.enter = function() {
    this.validate();
}

GoogleDocNameInputDialog.prototype.setDocTypeAndShow = function(docType, docTypeStr){
    this.docType = docType;
    this.docTypeStr = docTypeStr;
    this.setTitle(LC.getLabel("GoogleDocCreatorPage","nameText", docTypeStr));
    this.createContent();
    this.show();
    this.focusInOverlay();
}

GoogleDocNameInputDialog.prototype.createContent = function(){
    var content = document.getElementById(this.getContentId());
    var html = [];
    html.push('<table><tr><td>');
    html.push(LC.getLabel("MailMergeChoose","EntityName", this.docTypeStr));
    html.push(': </td><td class="inlineEditCompoundDiv"><span class="inlineEditRequiredMark">*</span><input id="' + GoogleDocCreator["DOC_NAME"] + '" type="text" width="64" name="' + GoogleDocCreator["DOC_NAME"] +'"/></td></tr>');
    html.push('<tr><td>&nbsp;</td><td><div class="errorMsg" id="' + this.errorElementId + '" style= "display:none">' + LC.getLabel("GoogleDocCreatorPage","errorMsgNoValue") +'</div></td></tr></table>');
    html.push('<input type="hidden" id="' + GoogleDocCreator["PARENT_ID"] +'" value="' + this.parentId + '"/>');
    html.push('<input type="hidden" id="' + GoogleDocCreator["DOC_TYPE"] + '" value="' + this.docType + '"/>');
    this.createButtons(html);
    content.innerHTML = html.join("");
}

GoogleDocNameInputDialog.prototype.focusInOverlay = function(){
    if (XBrowser.userAgent.isIE6) {
       setTimeout('document.getElementById(GoogleDocCreator["DOC_NAME"]).focus()',100);
  	} else {
       document.getElementById(GoogleDocCreator["DOC_NAME"]).focus();
  	}
}

GoogleDocNameInputDialog.prototype.validate = function(){
    var docName = document.getElementById(GoogleDocCreator["DOC_NAME"]).value;
    if(docName == null || trim(docName) == "") {
        document.getElementById(this.errorElementId).style["display"] = "";
        this.focusInOverlay();
        return false;
    } else {
        this.hide();
        var get = {};
        get[GoogleDocCreator["DOC_NAME"]] = docName;
        get[GoogleDocCreator["PARENT_ID"]] = document.getElementById(GoogleDocCreator["PARENT_ID"]).value;
        get[GoogleDocCreator["DOC_TYPE"]] = document.getElementById(GoogleDocCreator["DOC_TYPE"]).value;
        var qs = "?" + XBrowser.buildPost(get);
        if (this.escapeParams) {
            qs = encodeURIComponent(qs);
        }
        window.open(this.url + qs, this.windowName , "width=900, height=600, location=yes, menubar=yes, status=yes, toolbar=yes, scrollbars=yes, resizable=yes");
        return true;
    }
}

GoogleDocNameInputDialog.getDialog = function(id, url, escapeParams, parentId) {
    var dialog = sfdcPage.getDialogById(id);
    if (dialog) {
        return dialog;
    }
    dialog = new GoogleDocNameInputDialog(id, url, escapeParams, parentId);
    dialog.register();
    return dialog;
}

GoogleDocNameInputDialog.prototype.enter = function() {
    this.validate();
}

//#depend common.html.OverlayDialog
/**
 * FieldSelectDialog.
 *
 * @author ldelascurain
 * @since 150
 */


function FieldSelectDialog(id, isModal, title, selectId, info) {
    this.id = id;
    this.isModal = isModal;
    this.isMovable = true;
    this.buttons = [];
    this.selectId = selectId;
    this.info = info;
    this.width = OverlayDialog.MAX_WIDTH;
    // setup default buttons
    this.buttons[0] = { display: LC.getLabel("Buttons", "close"), action: null };
    this.title = title;
    this.addEvents();
}

FieldSelectDialog.HEIGHT = 193;

FieldSelectDialog.prototype = new OverlayDialog();

FieldSelectDialog.prototype.setFieldTreeController = function(fieldTreeController){
    this.fieldTreeController = fieldTreeController;
    this.fieldTreeController.setScrollDiv(document.getElementById(this.selectId));
}

FieldSelectDialog.prototype.setInnerHeight = function(){
    this.getContentElement().style.height = FieldSelectDialog.HEIGHT + 'px';
}

FieldSelectDialog.prototype.createContent = function(){
    var content = document.getElementById(this.getContentId());

    var html = [];
    if (this.info) {
        html.push("<p id='");
        html.push(this.id);
        html.push("Info'>");
        html.push(this.info);
        html.push("</p>");
    }
    html.push("<div class='fieldSelectorScrollableArea'  id='");
    html.push(this.getInnerId());
    html.push("'></div>");

    this.createButtons(html);
    content.innerHTML = html.join("");

    this.getContentElement().appendChild(document.getElementById(this.selectId));
}

/**
 * returns the content element
 */
FieldSelectDialog.prototype.getContentElement = function() {
    return document.getElementById(this.getInnerId());
}

FieldSelectDialog.prototype.getInnerId = function(){
    return this.id + "Inner";
}

FieldSelectDialog.prototype.show = function(){
    var selectContainer = this.getContentElement().firstChild;
    while (selectContainer.firstChild.nodeName != "TD"){
        selectContainer = selectContainer.firstChild;
    }
    while (selectContainer.lastChild != selectContainer.firstChild) {
        selectContainer.removeChild(selectContainer.lastChild);
    }
    this.fieldTreeController.reset();
    this.fieldTreeController.showSelects();
    OverlayDialog.prototype.show.call(this);
    this.fieldTreeController.focusTop();
}

FieldSelectDialog.prototype.hide = function(){
    OverlayDialog.prototype.hide.call(this);
    this.fieldTreeController.hideSelects();
}
//#depend common.html.OverlayDialog
/**
 * EmailToSalesforceDeactivationDialog
 * Dialogue for displaying Email to Salesforce DeActivation confirmation overlay.
 *
 * @author ccopek
 * @since 152
 */


function EmailToSalesforceDeactivationDialog(id, sendEmailNotificationId, btnId) {
    this.id = id;
    this.isModal = true;
    this.formId = "emailDeactivation";
    this.windowName = "";
    this.width = 480;
    this.btnId = btnId;
    this.sendEmailNotificationId = sendEmailNotificationId;
    this.addEvents();
}

EmailToSalesforceDeactivationDialog.HEIGHT = 80;
EmailToSalesforceDeactivationDialog.prototype = new OverlayDialog();

EmailToSalesforceDeactivationDialog.prototype.showDeActivationNotification = function(){
    this.setTitle(LC.getLabel("GoogleAppsActivationUi","deactivateTitle"));
    this.createContent();
    this.show();
    this.focusInOverlay();
}

EmailToSalesforceDeactivationDialog.prototype.createContent = function(){
	var content = document.getElementById(this.getContentId());
    var html = [];
    html.push('<div>');
    html.push('<table >');
    html.push('<tr><td>');
    html.push('<img src=\"/s.gif\" alt=\"Warning\"  class=\"warningLarge\" style=\'margin-right: 15px\'=\"style=\'margin-right: 15px\'\" title=\"Warning\"/>');
    html.push('<\/td><td>');
    html.push('<span  class=\"deactivateWarningHeader\">');
    html.push(LC.getLabel("GoogleDocsActivationUi","deactivateWarningHeader"));
    html.push('<\/span>');
    html.push('<ul class=\"deactivateWarningUl\">');
    html.push('<li>' + LC.getLabel("Page_EmailToSalesforceOrgSetup","whatDeactivatingWillDo1") + '<\/li>');
    html.push('<li>' + LC.getLabel("Page_EmailToSalesforceOrgSetup","whatDeactivatingWillDo2") + '<\/li>');
    html.push('<\/ul>\n<\/td><\/tr>\n');
    html.push('<\/table><\/div>');

    html.push("<div class='buttons'>");
    // Deactivate button
    var deactivateLabel = LC.getLabel("GoogleAppsActivationUi","deactivateButton");
    html.push("<input class='btn' type='button' id='overlayDeactivateButton' value='");
    html.push(deactivateLabel);
    html.push("' title='");
    html.push(deactivateLabel);
    html.push("' onclick=\"");
    html.push("if(EmailToSalesforceNotificationEmailDialog.prototype.savePage('dontsend','");
    html.push(this.sendEmailNotificationId);
    html.push("','");
    html.push(this.btnId);
    html.push("')) { sfdcPage.getDialogById('");
    html.push(this.id);
    html.push("').hide(); }\">");

	// Cancel button
	var cancelLabel = LC.getLabel("Buttons","cancel");
    html.push("<input class='btn' type='button' value='");
    html.push(cancelLabel);
    html.push("' title='");
    html.push(cancelLabel);
    html.push("' onclick=\"");
    html.push("sfdcPage.getDialogById('");
    html.push(this.id);
    html.push("').cancel(); document.getElementById('");
    html.push(this.btnId);
    html.push("').focus();\">");

    html.push("</div>");

    content.innerHTML = html.join("");
}

EmailToSalesforceDeactivationDialog.prototype.focusInOverlay = function(){
    document.getElementById('overlayDeactivateButton').focus();
}

EmailToSalesforceDeactivationDialog.getDialog = function(id, sendEmailNotificationId, btnId) {
    var dialog = sfdcPage.getDialogById(id);
    if (dialog) {
        return dialog;
    }
    dialog = new EmailToSalesforceDeactivationDialog(id, sendEmailNotificationId, btnId);
    dialog.register();
    return dialog;
}

//#depend common.html.OverlayDialog
/**
 * support javascript for OverlayDialogElement
 *
 * @author pdebaty
 * @since 152
 */

function OverlayDialogElement(id) {
    this.id = id;
    this.windowName = id;
   	this.setupDefaultButtons();
    this.addEvents();
    this.contents="";
    this.buttonContents="";
}

OverlayDialogElement.prototype = new OverlayDialog();

OverlayDialogElement.prototype.createContent = function() {
    var content = document.getElementById(this.getContentId());
    var html = [];
    html.push(this.contents);
    if (this.buttonContents.length == 0) {
	    this.createButtons(html);
    } else {
    	html.push("<div class='buttons'>");
		html.push(this.buttonContents);
	    html.push("</div>");
    }
    content.innerHTML = html.join("");
}

OverlayDialogElement.getDialog = function(id) {
    var dialog = sfdcPage.getDialogById(id);
    if (dialog) {
        return dialog;
    }
    dialog = new OverlayDialogElement(id);
    dialog.register();
    return dialog;
}

//#depend common.html.OverlayDialog
/**
* Model dialog for adding sync set to mobile config
*
 * @author azhulina
 * @since 154
*/

function AddSyncSetDialog() {
    this.id = "AddSyncSetDialog";
    this.isModal = true;
    this.width = 350;
    this.title = LC.getLabel("MobileConfig_Section_SyncSet", "AddDlg_Caption");
    this.addEvents();
    this.objects = null;
}

AddSyncSetDialog.prototype = new OverlayDialog();

AddSyncSetDialog.prototype.createContent = function() {
    var content = document.getElementById(this.getContentId());
    var html = [];
    this.buttons = [];
    if (this.objects && this.objects.length > 0){
    	html.push("<span>");
    	html.push(LC.getLabel("MobileConfig_Section_SyncSet", "AddDlg_Label_SelectFrom"));
    	html.push("</span>");    	
    	this.buttons[0] = { display: LC.getLabel("Buttons", "ok"), action: "MobileConfig.onOkAddDialog()" };
    	this.buttons[1] = { display: LC.getLabel("Buttons", "cancel"), action: "MobileConfig.onCancelAddDialog()" };    	
        this.createButtons(html);          
    	content.innerHTML = html.join("");
    	var select = document.createElement("select");
    	select.name = "dlgAdd_selectObj";
    	select.id = "dlgAdd_selectObj";
    	for (var i=0; i<this.objects.length; i++){
    		var option = document.createElement("option");
    		option.text = this.objects[i].label;
    		option.value = this.objects[i].type;
    		select.options[select.options.length] = option;
    	}
    	content.insertBefore(select, content.lastChild);
    }else{    	
    	this.buttons[0] = { display: LC.getLabel("Buttons", "cancel"), action: "MobileConfig.onCancelAddDialog()" };
    	this.createButtons(html);
    	content.innerHTML = html.join("");
    	var errorDiv = document.createElement("div");
    	errorDiv.innerHTML = LC.getLabel("MobileConfig_Section_SyncSet", "AddDlg_NoMoreObjects");
    	errorDiv.style.display = "";
    	errorDiv.align = "center";
    	content.insertBefore(errorDiv, content.lastChild);    	
    }             
}

/**
* Sets the list of objects that should be available for selection
* object { type: <entity id>, label: <entity name>}
*/
AddSyncSetDialog.prototype.setObjectList = function(objectList){
	this.objects = objectList;
}
//#depend common.html.OverlayDialog
/**
 * EmailToSalesforceNotificationEmailDialog
 * Displays overlay for collecting email subject and body
 * and giving admin ability to choose to send the email notification
 * to all active users in the org when the Email To Salesforce
 * service is activated.
 *
 * @author ccopek
 * @since 152
 */


function EmailToSalesforceNotificationEmailDialog(id, userSetupUrl, adminUserName, emailSubjectId, emailBodyId, sendEmailNotificationId, btnId) {
    this.id = id;
    this.userSetupUrl = userSetupUrl;
    this.adminUserName = adminUserName;
    this.isModal = true;
    this.formId = "emailNotificationInputForm";
    this.errorElementId = "errorMsg";
    this.windowName = "";
    this.width = 600;
    this.emailSubjectId = emailSubjectId;
    this.emailBodyId = emailBodyId;
    this.sendEmailNotificationId = sendEmailNotificationId;
    this.btnId = btnId;
    this.addEvents();
}

EmailToSalesforceNotificationEmailDialog.HEIGHT = 80;
EmailToSalesforceNotificationEmailDialog.prototype = new OverlayDialog();

EmailToSalesforceNotificationEmailDialog.prototype.showEmailNotification = function(){
    this.setTitle(LC.getLabel("Page_EmailToUsers","page_title"));
    this.createContent();
    this.show();
    this.focusInOverlay();
}

EmailToSalesforceNotificationEmailDialog.prototype.createContent = function(){
	var content = document.getElementById(this.getContentId());
	var subjectLabel = LC.getLabel("Page_EmailToUsers","emailSubjectLabel");
	var messageLabel = LC.getLabel("Page_EmailToUsers","emailBodyLabel");
    var html = [];
    html.push('<table>');
    html.push('<tr><td align="right">');
    html.push('<B>' + LC.getLabel("Page_EmailToUsers","to") + '</B>');
    html.push('</td><td>');
    html.push(LC.getLabel("Page_EmailToUsers","allActiveUsers"));
    html.push('</td></tr>');
    html.push('<tr><td align="right">');
    html.push('<B>' + subjectLabel + '</B>');
    html.push('</td><td>');
    html.push('<input id="subject" type="text" size="75" name="subject" title="' + subjectLabel + '" value="' + LC.getLabel("Page_EmailToUsers","emailSubject") + '"/>');
    html.push('</td></tr>');
    html.push('<tr><td>');
    html.push('<B>' + messageLabel + '</B>');
    html.push('</td><td>&nbsp;</td></tr>');
    html.push('</table>');
    html.push('<textarea id="body" name="body" rows="10" cols="100" title="' + messageLabel + '">');
    html.push(LC.getLabel("Page_EmailToUsers","emailBody", this.userSetupUrl, this.adminUserName));
    html.push('</textarea>');

    // Add buttons
    html.push("<div class='buttons'>");
    // Add Send Notification Email button
    var sendNotificationEmailLabel = LC.getLabel("Page_EmailToUsers","sendNotificationEmail");
    html.push("<input class='btn' type='button' value='");
    html.push(sendNotificationEmailLabel);
    html.push("' title='");
    html.push(sendNotificationEmailLabel);
    html.push("' onclick=\"");
    html.push("if(sfdcPage.getDialogById('");
    html.push(this.id);
    html.push("').sendEmail()) { sfdcPage.getDialogById('");
    html.push(this.id);
    html.push("').hide(); }\">");

    if (this.btnId.indexOf('saveBtn') >= 0) {
    	// Save button was clicked.  Display Skip this step button on overlay.
	    var skipThisStepLabel = LC.getLabel("Page_EmailToUsers","skipThisStep");
	    html.push("<input class='btn' type='button' value='");
	    html.push(skipThisStepLabel);
	    html.push("' title='");
	    html.push(skipThisStepLabel);
	    html.push("' onclick=\"");
	    html.push("if(sfdcPage.getDialogById('");
	    html.push(this.id);
	    html.push("').savePage('dontsend','");
	    html.push(this.sendEmailNotificationId);
	    html.push("','");
	    html.push(this.btnId);
	    html.push("')) { sfdcPage.getDialogById('");
	    html.push(this.id);
	    html.push("').hide(); }\">");
	} else {
		// Send Email Notification button must have been clicked.  Display cancel button on the page.
		var cancelLabel = LC.getLabel("Buttons","cancel");
	    html.push("<input class='btn' type='button' value='");
	    html.push(cancelLabel);
	    html.push("' title='");
	    html.push(cancelLabel);
	    html.push("' onclick=\"");
	    html.push("sfdcPage.getDialogById('");
	    html.push(this.id);
	    html.push("').cancel(); document.getElementById('");
	    html.push(this.btnId);
	    html.push("').focus();\">");
	}
    html.push("</div>");

    content.innerHTML = html.join("");
}

EmailToSalesforceNotificationEmailDialog.prototype.focusInOverlay = function(){
    document.getElementById('body').focus();
}

EmailToSalesforceNotificationEmailDialog.prototype.sendEmail = function() {
	// Copy the overlay values to the hidden variables on the main page form.
	var overlaySubject = document.getElementById('subject');
	var overlayBody = document.getElementById('body');
	var hiddenSubject = document.getElementById(this.emailSubjectId);
	var hiddenBody = document.getElementById(this.emailBodyId);
	hiddenSubject.value = overlaySubject.value;
	hiddenBody.value = overlayBody.value;

	return this.savePage('send', this.sendEmailNotificationId, this.btnId);
}

EmailToSalesforceNotificationEmailDialog.prototype.savePage = function(sendEmailNotificationValue, sendEmailNotificationId, btnId) {
	// Set the sendEmailNotification hidden variable value
	var sendEmailNotification = document.getElementById(sendEmailNotificationId);
	sendEmailNotification.value = sendEmailNotificationValue;

	// Get the button and click it.
	var button = document.getElementById(btnId);
	button.click();
	return true;
}

EmailToSalesforceNotificationEmailDialog.getDialog = function(id, userSetupUrl, adminUserName, emailSubjectId, emailBodyId, sendEmailNotificationId, btnId) {
    var dialog = sfdcPage.getDialogById(id);
    if (dialog) {
        return dialog;
    }
    dialog = new EmailToSalesforceNotificationEmailDialog(id, userSetupUrl, adminUserName, emailSubjectId, emailBodyId, sendEmailNotificationId, btnId);
    dialog.register();
    return dialog;
}

//#depend common.html.OverlayDialog

/**
 * modal dialog for displaying compound fields for inline editing
 * 
 * @author jmooney
 * @since 150
 */
function InlineEditDialog() {
    this.id = "InlineEditDialog";
    this.isModal = true;
    this.extraClass = "inlineEditDialog";
    this.width = null;
    this.title = "";
    this.setupButtons();
    this.activeDiv = null;
    this.errorDiv = null;
    this.editDivPool = null;
    this.currentField = null;
    this.displayX = true;
    this.fields = {};
    this.addEvents();
}

InlineEditDialog.prototype = new OverlayDialog();

InlineEditDialog.prototype.setInnerHeight = function() {
    // TODO: set the max height based on active field height/viewport
}

InlineEditDialog.prototype.enter = function() {
    sfdcPage.inlineEditData.closeCurrentField();
}

InlineEditDialog.prototype.setupButtons = function() {
    this.buttons = [];
    this.buttons[0] = { display: LC.getLabel("Buttons", "ok"), action: "sfdcPage.inlineEditData.closeCurrentField()" };
    this.buttons[1] = { display: LC.getLabel("Buttons", "cancel"), action: "sfdcPage.inlineEditData.resetCurrentField()" };
}

InlineEditDialog.prototype.createContent = function() {
    addEvent(this.dialog, "click", function(e) { eventCancelBubble(getEvent(e)); }, false);
    var content = document.getElementById(this.getContentId());
    var html = [];
    this.createButtons(html);
    content.innerHTML = html.join('');
    this.activeDiv = document.createElement("div");
    this.activeDiv.className = "activeField";
    this.errorDiv = document.createElement("div");
    this.editDivPool = document.createElement("div");
    this.editDivPool.style.display = "none";
    content.insertBefore(this.activeDiv, content.lastChild);
    content.insertBefore(this.errorDiv, content.lastChild);
    content.insertBefore(this.editDivPool, content.lastChild);
}

InlineEditDialog.prototype.addField = function(fieldId, editDiv, editLabel) {
    this.fields[fieldId] = { title: editLabel, div: editDiv };
    this.editDivPool.appendChild(editDiv);
}

InlineEditDialog.prototype.setActiveField = function(fieldId) {
    if (this.currentField) {
        if (this.currentField == fieldId) return;
        this.editDivPool.appendChild(this.fields[this.currentField].div);
    }
    var f = this.fields[fieldId];
    this.setTitle(f.title);
    this.currentField = fieldId;
    this.activeDiv.appendChild(f.div);
    // TODO: error messages
}

InlineEditDialog.prototype.setMaxWidth = function(width) {
    if (width > OverlayDialog.MAX_WIDTH) {
        width = OverlayDialog.MAX_WIDTH;
    }
    if (this.dialog.currentStyle) {
        this.dialog.style.width = width + "px";
    } else {
        this.dialog.style.maxWidth = width + "px";
    }
}

InlineEditDialog.prototype.cancel = function() {
    sfdcPage.inlineEditData.resetCurrentField();
    this.hide();
}

//#depend ui.dynamic.IframeShim

/**
 * Handles dynamic client side behavior for the auto-complete input element.
 *
 * @author mpaksoy
 * @since 154
 */

/**
 * Initializes necessary data structures and creates event handlers on given input element.
 * @param elementId DOM id of the input element auto-complete operates on
 * @param servletURI URI where auto-complete suggestions are retreived from (See AbstractAutoCompleteServlet.java)
 * @param minSuggestLen minimum number of characters the user needs to type before auto-completion begins
 * @param requestParams additional parameters to send to the servlet when requesting suggestions
 */
AutoCompleteInputElement = function(elementId, servletURI, minSuggestLen, requestParams) {
    this.id = elementId;
    this.element = document.getElementById(elementId);
    if (!(this.id && this.element)) {
        return;
    }
    AutoCompleteInputElement.instanceRefs[this.id] = this;

    this.servletURI = servletURI;
    if (minSuggestLen >= 0) {
        this.minSuggestLen = minSuggestLen;
    } else {
        this.minSuggestLen = 0;
    }
    this.cache = {};
    this.triedQueries = {};
    this.selected = -1;
    this.requestParams = requestParams;
    this.lastInput = null;

    var self = this;
    addEvent(this.element, 'keyup', function(e) { self.handleInput(e); });
    addEvent(this.element, 'keydown', function(e) { self.handleNav(e); });
    // We delay the blur event to allow clicks to go through when selecting suggesitions
    var blurString = ['AutoCompleteInputElement.blurHandler("', this.id, '");'].join('');
    addEvent(this.element, 'blur', function() { self.focused = false; setTimeout(blurString, 200); });
    addEvent(this.element, 'focus', function() { self.focused = true; });
}

// STATIC CONSTANTS
AutoCompleteInputElement.BOX_ID = "_autoCompleteBoxId";
AutoCompleteInputElement.BOX_CSS_CLASS = 'autoCompleteBoxScrolling';

AutoCompleteInputElement.ROW_ID = '_autoCompleteRowId_';
AutoCompleteInputElement.ROW_CSS_CLASS = 'autoCompleteRow';
AutoCompleteInputElement.ROW_CSS_CLASS_SELECTED = 'autoCompleteSelectedRow';
AutoCompleteInputElement.MORE_ROW_CSS_CLASS = 'autoCompleteMoreRow';

AutoCompleteInputElement.MAX_SUGGESTIONS = 10;
AutoCompleteInputElement.ROW_HEIGHT = 1.5;
AutoCompleteInputElement.ROW_HEIGHT_UNITS = 'em';

// STATIC FIELDS
AutoCompleteInputElement.instanceRefs = {};

// AC BOX
/**
 * Position AC box so it's aligned with input element.
 * @param checkVisible if set to true, only position AC box if AC box is visible (display!='none')
 */
AutoCompleteInputElement.prototype.positionACBox = function(checkVisible) {
    if ((!this.element) || (!this.acBox)) {
        return;
    }
    if (checkVisible && (!this.isACBoxVisible())) {
        return;
    }


    var x = getObjX(this.element);
    var y = getObjY(this.element) + this.element.offsetHeight;
    this.acBox.setStyle('left', x + "px");
    this.acBox.setStyle('top', y + "px");
    var width = this.element.clientWidth - 2; // correct for padding
    this.acBox.setStyle('width', width + "px");
}

AutoCompleteInputElement.prototype.clearACBox = function() {
    if (! this.isACBoxVisible()) {
        return;
    }

    this.acBox.setStyle('display', 'none');
    this.scrolling = false;
    this.acBox.setStyle('height', 'auto');
    this.deselect();
}

AutoCompleteInputElement.prototype.isACBoxVisible = function() {
    return (this.acBox && (this.acBox.getStyle('display') != 'none'));
}

AutoCompleteInputElement.prototype.updateACBox = function(suggestions) {
    if (! this.element) {
        return;
    }

    // no suggestions provided, clear AC box if possible.
    if ((!suggestions) || (suggestions.length == 0)) {
        if (this.acBox) {
            this.clearACBox();
        }
        return;
    }

    if (! this.acBox) {
        this.initACBox();
    } else {
        this.deselect(); // clear selection for new state
    }

    this.positionACBox();
    var html = [];
    html.push("<table width='100%' cellpadding='0' cellspacing='0' border='0'>");
    for (var i = 0; i < suggestions.length; i++) {
        var record = suggestions[i];
        if (!record || (record.length == 0)) {
            continue; this.triedQueries[this.getCacheKey(query)] = true; // We try every query query once.
        }

        html.push("<tr><td>");
        html.push("<div ");
        html.push('onmouseover="');
        html.push("AutoCompleteInputElement.mouseOver('" + this.id + "', " + i + ')"');
        if (this.selected == i) {
            html.push("class='" + AutoCompleteInputElement.ROW_CSS_CLASS_SELECTED + "' ");
        } else {
            html.push("class='" + AutoCompleteInputElement.ROW_CSS_CLASS + "' ");
        }
        html.push("id='" + AutoCompleteInputElement.getRowIdStatic(this.id, i) + "'>");
        html.push(record[0]);
        html.push("</div>");
        html.push("</td></tr>");
    }

    html.push("</table>");

    this.acBox.div.innerHTML = html.join('');
    this.select(0);
    // If we're displaying more suggestions than the given max, pin height and display vertical scroll bars.
    if (suggestions.length > AutoCompleteInputElement.MAX_SUGGESTIONS) {
        this.acBox.setStyle('height', (AutoCompleteInputElement.MAX_SUGGESTIONS * AutoCompleteInputElement.ROW_HEIGHT) + AutoCompleteInputElement.ROW_HEIGHT_UNITS);
        this.scrolling = true;
    } else {
        this.acBox.setStyle('height', 'auto');
        this.scrolling = false;
    }
    this.acBox.setStyle('display', 'block');
    this.scrollDiv();
}

AutoCompleteInputElement.prototype.select = function(row) {
    if (this.selected == row) {
        return;
    }

    if (this.selected >= 0) { // there's a row currently selected
        var rowRef = this.getRow(this.selected);
        if (rowRef) {
            rowRef.className = AutoCompleteInputElement.ROW_CSS_CLASS;
        }
    }
    this.selected = row;
    var rowRef = this.getRow(this.selected);
    if (rowRef) {
        rowRef.className = AutoCompleteInputElement.ROW_CSS_CLASS_SELECTED;
    }
}

/**
 * Circular select previous. Go to last row if user moves up on first row.
 */
AutoCompleteInputElement.prototype.selectPrev = function() {
    if (!this.hasValidSelection()) return;

    var newsel = this.selected - 1;
    if (newsel < 0) newsel = this.curSuggestions.length - 1;
    this.select(newsel);
    this.scrollDiv();
}

/**
 * Circular select next. Go to first row if user moves down on last row.
 */
AutoCompleteInputElement.prototype.selectNext = function() {
    if (!this.hasValidSelection()) return;

    var newsel = (this.selected + 1) % this.curSuggestions.length;
    this.select(newsel);
    this.scrollDiv();
}

/**
 * Scroll AC box so that the currently selected can be seen inside client window.
 */
AutoCompleteInputElement.prototype.scrollDiv = function() {
    if ((!this.hasValidSelection()) || (!this.scrolling)) {
        return;
    }

    // We try to place the selected row roughly in the center of the window.
    var scrollh = (this.acBox.div.scrollHeight * ((this.selected + 1) /  this.curSuggestions.length)) -
                  (this.acBox.div.clientHeight * 0.5);
    this.acBox.div.scrollTop = scrollh;
}

AutoCompleteInputElement.prototype.deselect = function() {
    return this.select(-1);
}

/**
 * @return true if auto-complete box is being displayed and a suggestion is selected within the auto-complete box.
 */
AutoCompleteInputElement.prototype.hasValidSelection = function() {
    return (this.element &&
            (this.selected >= 0) &&
            this.curSuggestions &&
            this.curSuggestions.length &&
            (this.selected < this.curSuggestions.length) &&
            this.isACBoxVisible());
}

AutoCompleteInputElement.prototype.initACBox = function() {
    if (! this.element) {
        return;
    }

    this.acBox = document.createElement("div");
    this.acBox.id = this.id + AutoCompleteInputElement.BOX_ID;
    this.acBox.className = AutoCompleteInputElement.BOX_CSS_CLASS;
    document.body.appendChild(this.acBox);
    var self = this;
    addEvent(this.acBox, 'click', function() { self.complete(); });
    this.acBox = new iframeShim(this.acBox);

    // Add handler to window as necessary so we can relocate window.
    // We only need one handler for the entire window so we set a static flag once that handler is created.
    if (!AutoCompleteInputElement.hasResizeHandler) {
        addEvent(window, 'resize', AutoCompleteInputElement.resizeHandler);
        AutoCompleteInputElement.hasResizeHandler = true;
    }
}

/**
 * Replace the contents of the input element with the currently selected suggestion.
 * @return true if complete gets executed
 */
AutoCompleteInputElement.prototype.complete = function() {
    if (! this.element) {
        return false;
    }

    if (!this.hasValidSelection()) {
        return false;
    }

    var selectedEntry = this.curSuggestions[this.selected];
    this.setAppliedFlag(true);
    this.innerComplete(selectedEntry);
    this.clearACBox();
    return true;
}

/**
 * Suggestion entries are handled by this method.
 * By default, the suggestion entry is an array where the first item is the suggestion string.
 * An optional second item in the array is executed as JavaScript (eval()) if it exists.
 */
AutoCompleteInputElement.prototype.innerComplete = function(suggestionEntry) {
    if ((!this.element) || (!suggestionEntry) || (suggestionEntry.length == 0)) {
        return;
    }

    this.element.value = suggestionEntry[0];
    if (suggestionEntry.length > 1) {
        eval(suggestionEntry[1]);
    }
}

/**
 * Create or update the corresponding input element to indicate if the auto-complete suggestion was applied.
 */
AutoCompleteInputElement.prototype.setAppliedFlag = function(flag) {
    var acApplied = flag ? '1' : '0';
    if (this.acAppliedField) {
        this.acAppliedField.value = acApplied;
        return;
    }

    var editform = document.getElementById(EditPageConstants.pEDIT_PAGE);
    if (editform) {
        var fieldId = this.id + AbstractAutoCompleteServlet.AUTOCOMPLETE_USED_SUFFIX;
        field = document.createElement("input");
        field.type = 'hidden';
        field.id = fieldId;
        field.name = fieldId;
        field.value = acApplied;
        editform.appendChild(field);
        this.acAppliedField = field;
    }
}

AutoCompleteInputElement.prototype.getRow = function(number) {
    return document.getElementById(AutoCompleteInputElement.getRowIdStatic(this.id, number));
}

// SERVLET COMMUNICATION
AutoCompleteInputElement.prototype.retreiveFromServlet = function(query) {
    // Do not query if input is too short.
    if ((!query) || (query.length < this.minSuggestLen)) {
        return false;
    }

    if (this.triedQueries[this.getCacheKey(query)]) {
        return false;
    }
    this.triedQueries[this.getCacheKey(query)] = true; // We try every query query once.

    var self = this;
    var url = [];
    url.push(this.servletURI);
    url.push("?");
    url.push(AbstractAutoCompleteServlet.pINPUT);
    url.push("=");
    if (query.length > 0) {
        url.push(encodeURIComponent(query));
    }

    if (this.requestParams) {
        for (var i in this.requestParams) {
            url.push("&");
            url.push(i);
            url.push("=");
            url.push(this.requestParams[i]);
        }
    }

    XBrowser.getHttpResponse(url.join(''), function(request) {
        var resp = request.responseText;
        if (resp) {
            var tmpResp = eval(resp);
            self.saveToCache(query, tmpResp);
            self.displaySuggestions(true);
        }
    });
    return true;
}

// SUGGEST MATCH
/**
 * This is first method that is called when text is entered. It generates suggesions and displays them.
 * @param isHttpResponse set to true when suggesting are being displayed after a successful suggestion retrieve.
 */
AutoCompleteInputElement.prototype.displaySuggestions = function(isHttpResponse) {
    // Do not display suggestions if element is not in focus.
    if ((!this.element) || (!this.focused)) {
        return;
    }

    var input = trim(this.element.value);
     // need to redisplay suggestions if input text has changed. if we retrieved new suggestions, we need to redisplay then as well.
    if (isHttpResponse || (input != this.lastInput)) {
        this.setAppliedFlag(false);
        this.lastInput = input;
        this.curSuggestions = this.getSuggestions(input);
        this.updateACBox(this.curSuggestions);
    }

}

/**
 * Close suggestion box and deselect current suggestion.
 */
AutoCompleteInputElement.prototype.clearSuggestions = function() {
    if (! this.element) {
        return;
    }

    this.curSuggestions = null;
    this.clearACBox();
    this.deselect();
}

/**
 * Read contents of text input element and retreive suggestions based on that.
 * Checks cache first and retreives suggestions from servlet as necessary.
 */
AutoCompleteInputElement.prototype.getSuggestions = function(input) {
    if (! this.element) {
        return;
    }

    var superSet = this.checkCacheOrRetreive(input);
    if (! superSet) {
        return [];
    }

    var resultSet = [];
    for (var i = 0; i < superSet.length; i++) {
        var suggestion = superSet[i];
        if (AutoCompleteInputElement.matches(input, suggestion[0])) {
            resultSet.push(suggestion);
        }
    }

    // TODO MMP Very basic optimization remembers the last search.
    return resultSet;
}

AutoCompleteInputElement.prototype.getCacheKey = function(query) {
    if (this.minSuggestLen == 0) {
        return 'dummy';
    }
    return query.substr(0, this.minSuggestLen);
}

AutoCompleteInputElement.prototype.saveToCache = function(query, results) {
    this.cache[this.getCacheKey(query)] = results;
}

/**
 * Convert input string into a cache key and probe cache with the key.
 * If cache does not contain key, retreive from servlet with input.
 * If cache contains key, return cache results.
 */
AutoCompleteInputElement.prototype.checkCacheOrRetreive = function(input) {
    var cacheKey = this.getCacheKey(input);

    // Need to query servlet if we don't have values yet.
    if (! this.cache[cacheKey]) {
        this.retreiveFromServlet(input);
    }

    return this.cache[cacheKey];
}

AutoCompleteInputElement.prototype.handleInput = function(event) {
    // If we're in an input method (eg, Hiragana), then only display when the character is finished
    // http://bugforce.soma.salesforce.com/bug/bugDetail.jsp?id=100000000000qY0
    if (this.inKeyIME) {
        this.inKeyIME = false;
        if (event.keyCode == KEY_ENTER) {
            this.displaySuggestions();
        }
    }
    // If not navigating then repopulate suggestions
    else if (!AutoCompleteInputElement.isNav(event)) {
        this.displaySuggestions();
    }
}

AutoCompleteInputElement.prototype.handleNav = function(event) {
    if (AutoCompleteInputElement.isNav(event)) {
        if (event.keyCode == KEY_ESC) {
            this.clearSuggestions();
        } else if (event.keyCode == KEY_ARROW_U) {
            this.selectPrev();
        } else if (event.keyCode == KEY_ARROW_D) {
            this.selectNext();
        } else if (event.keyCode == KEY_TAB) {
            this.complete();
        } else if (event.keyCode == KEY_ENTER) {
            // if complete is executed, capture the enter key
            if (this.complete()) {
                AutoCompleteInputElement.captureKeystroke(event);
            }
        }
    } else if(event.keyCode == KEY_PROCESS) {
        this.inKeyIME = true;
    }
}

// STATIC HELPERS
/** Single method crafts row Id strings for consistency. */
AutoCompleteInputElement.getRowIdStatic = function(id, number) {
    return '' + id + AutoCompleteInputElement.ROW_ID + number;
}

AutoCompleteInputElement.getInstance = function(id) {
    return(AutoCompleteInputElement.instanceRefs[id]);
}

AutoCompleteInputElement.mouseOver = function(id, rowNumber) {
    var inst = AutoCompleteInputElement.getInstance(id);

    var rowId = AutoCompleteInputElement.getRowIdStatic(id, rowNumber);
    var row = document.getElementById(rowId);
    if (! (inst && rowId)) {
        return;
    }

    inst.select(rowNumber);
}

/**
 * Return true if 'string' starts with 'substring.'
 * Normalizes both arguments.
 */
AutoCompleteInputElement.matches = function(substring, string) {
    if (!substring || !string) return false;
    substring = AutoCompleteInputElement.normalize(substring);
    string = AutoCompleteInputElement.normalize(string);
    if (substring.length > string.length) return false;
    return (string.indexOf(substring) === 0);
}

/**
 * Lower case string with leading and trailing white space removed.
 * Used for prefix matching suggestions.
 */
AutoCompleteInputElement.normalize = function(string) {
    return trim(string.toLowerCase());
}

/**
 * Checks if given key event is a navigation control event.
 */
AutoCompleteInputElement.isNav = function(event) {
    if (!event || !event.keyCode)
        return false;

    // We use these four keys for navigation
    return ((event.keyCode == KEY_ARROW_D) ||
            (event.keyCode == KEY_ARROW_U) ||
            (event.keyCode == KEY_ESC) ||
            (event.keyCode == KEY_TAB) ||
            (event.keyCode == KEY_ENTER));
}

/**
 * Static handler called by the onblur event. Gets correct class instance and clears suggestions.
 */
AutoCompleteInputElement.blurHandler = function(id) {
    var inst = AutoCompleteInputElement.getInstance(id);
    if (inst) {
        inst.clearSuggestions();
    }
}

/**
 * Capture given event (presumably a keystroke and prevent the event from being handled by the browser.
 * We use this to prevent the enter key from saving the form when completing the form.
 */
AutoCompleteInputElement.captureKeystroke = function(event) {
    if (XBrowser.userAgent.isIE) {
        event.returnValue = false;
        event.cancelBubble = false;
    } else {
        event.preventDefault();
        event.stopPropagation();
    }
}

/**
 * This handler is called every time the window is resized it repositions all visible auto-complete boxes.
 */
AutoCompleteInputElement.resizeHandler = function() {
    // Reposition all the AC boxes on screen
    for (var id in AutoCompleteInputElement.instanceRefs) {
        AutoCompleteInputElement.instanceRefs[id].positionACBox(true);
    }
}

//#depend common.page.EditPage
/*
 * @author jwalters
 * @since 150
 *
 * Handle lookup results for the Assigned To field when we may have multiple users
 */
function TaskEditPage() {}

TaskEditPage.prototype = new EditPage();

TaskEditPage.prototype.onChangeOwnerDisplay = function (textInputElementId, readOnlyElementId, lookupIconElementId, dropdownElementId, maxLength) {
	var textInputElement = document.getElementById(textInputElementId);
	var readOnlyElement = document.getElementById(readOnlyElementId);
	var lookupIconElementSingle = document.getElementById(lookupIconElementId);
	var lookupIconElementMulti = document.getElementById(lookupIconElementId + TaskUi.pLOOKUP_BUTTON_MULTI_OWNER_SUFFIX);
	var dropdownElement = document.getElementById(dropdownElementId);
	var idElement = document.getElementById(textInputElementId + EditElement.pID_SUFFIX);

	var isMultiOwnerDisplay = idElement.value.indexOf(TaskUi.ASSIGNEE_SEPARATOR) > 0 || (idElement.value != Udd.EMPTY_KEY && idElement.value.substring(0,3) != '005');
	var singleOwnerDisplayStyle = 'inline';
	var multiOwnerDisplayStyle = 'none';
	if (isMultiOwnerDisplay) {
		singleOwnerDisplayStyle = 'none';
		multiOwnerDisplayStyle = 'block';
	}

	// Single Owner Display elements
	textInputElement.style.display = singleOwnerDisplayStyle;
 	lookupIconElementSingle.style.display = singleOwnerDisplayStyle;
 	if (dropdownElement) {
 		dropdownElement.style.display = singleOwnerDisplayStyle;
 	}

	// Multi Owner Display elements
	readOnlyElement.style.display = multiOwnerDisplayStyle;
 	lookupIconElementMulti.style.display = multiOwnerDisplayStyle;

	// below is for when UROG lookup is implemented
	var readOnlyMessage = textInputElement.value;
	if (readOnlyMessage.length > maxLength) {
		readOnlyMessage = readOnlyMessage.substring(0, maxLength);
		readOnlyMessage += LC.getLabel("Sidebar", "ellipses");
	}

	var ownerListElement = document.getElementById(textInputElementId + TaskUi.pLOOKUP_DISPLAY_SUFFIX);
	ownerListElement.innerHTML = JSUtils.unescapeChar(readOnlyMessage, '\\');
	document.close();
}

TaskEditPage.prototype.setNotificationValue = function() {
   var el = document.getElementById(TaskUi.pNOTIFY_PREFERENCE_GROUP_ELEMENT);
   el.style.display='block';
   document.getElementById(TaskUi.pSHOW_PREFERENCE).value='1';
}



//#depend common.page.EditPage
/*
 * @author jwalters
 * @since 148
 *
 * AJAX refresh of calendar section of Event Edit Page.  Prevents need for full page refresh
 */
function EventEditPage() {
    this.inviteePopupCount = 0;
    this.defaultTimesSet = false;
}

EventEditPage.prototype = new EditPage();

EventEditPage.prototype.updateCalendar = function (args) {
    var postArgsMap = {};
    for (var arg in args) {
        var elements = document.getElementsByName(args[arg]);
        if (elements != null) {
            for (var i = 0; i < elements.length; i++) {
                element = elements[i];
                if (element.type == 'checkbox') {
                    window.sfdcPage.pushPostArg(postArgsMap, args[arg], element.checked ? '1' : '0');
                } else if ((element.type != 'radio') || element.checked) {
                    window.sfdcPage.pushPostArg(postArgsMap, args[arg], element.value);
                }
            }
        }
    }
    var iframe = document.getElementById(EventPage.CALENDAR_IFRAME_ID);
    if (!iframe) {
        iframe = document.createElement("iframe");
        iframe.src = IFrameElement.BLANK_SRC;
        iframe.id = EventPage.CALENDAR_IFRAME_ID;
        iframe.style.display = "none";
        document.body.appendChild(iframe);
    }
    XBrowser.postHttpResponse(window.location.pathname, window.sfdcPage.replaceCalendar, XBrowser.buildPost(postArgsMap));
}

EventEditPage.prototype.pushPostArg = function (map, arg, value) {
    if (map[arg] == null) {
        map[arg] = new Array();
    }
    map[arg].push(value);
}

EventEditPage.prototype.replaceCalendar = function (request) {
    var iframe = document.getElementById(EventPage.CALENDAR_IFRAME_ID);
    var iFrameDoc =  iframe.contentWindow.document;
    iFrameDoc.body.innerHTML = request.responseText;
    iFrameDoc.close();
    var newCalendar = iFrameDoc.getElementById(EditEventMultiUserCalendarElementConstants.EDIT_PAGE_CALENDAR);
    window.sfdcPage.setConflictError(newCalendar);
    document.getElementById(EditEventMultiUserCalendarElementConstants.EDIT_PAGE_CALENDAR).innerHTML = newCalendar.innerHTML;
    document.close();
}

EventEditPage.prototype.setConflictError = function (newCalendar) {
    if (getElementsByClassName(EditElement.ERROR_CLASS, document.getElementById(DetailElement.DEFAULT_DETAIL_ELEMENT_ID)).length > 0){
        // there's another error, so leave it alone
        return;
    }

    var pageErrorDiv = document.getElementById(DetailElement.DEFAULT_ERROR_DIV_ID);
    if (getElementsByClassName(EditElement.ERROR_CLASS, newCalendar).length > 0){
        pageErrorDiv.style.display = "block";
    } else {
        pageErrorDiv.style.display = "none";
    }
}

EventEditPage.prototype.clearTimeElements = function (allDayId, isRecurrenceId, eventTimeId, startDateId, startTimeId, endDateId, endTimeId, isEditableNotPreview) {
    if (isEditableNotPreview) {
        var isAllDay = document.getElementById(allDayId).checked;
        if (document.getElementById(eventTimeId)) {
            document.getElementById(eventTimeId).disabled = isAllDay;
        }
        if (document.getElementById(startTimeId)) {
            document.getElementById(startTimeId).disabled = isAllDay;
        }
        if (document.getElementById(endTimeId)) {
            document.getElementById(endTimeId).disabled = isAllDay;
        }
        if (document.getElementById(DurationInputElement.pHOURS_NAME)) {
            document.getElementById(DurationInputElement.pHOURS_NAME).disabled = isAllDay;
            document.getElementById(DurationInputElement.pMINUTES_NAME).disabled = isAllDay;
        }
        if (document.getElementById(isRecurrenceId) && document.getElementById(startDateId) && document.getElementById(endDateId)) {
            var disableDates = isAllDay && document.getElementById(isRecurrenceId).checked;
            document.getElementById(startDateId).disabled = disableDates;
            document.getElementById(endDateId).disabled = disableDates;
        }
    }
}

EventEditPage.prototype.adjustAddToInviteesLink = function () {
    var isPersonAccount = document.getElementById(EventUi.pISPERSONACCOUNT);
    if (isPersonAccount.value == "true") {
        document.getElementById(EventUi.pADD_INVITEE_ID).style.display="";
    } else {
        document.getElementById(EventUi.pADD_INVITEE_ID).style.display="none";
    }
}

EventEditPage.prototype.adjustPrivate = function (whoId, whatId, privateCheckboxId) {
    var whoElem = document.getElementById(whoId);
    var whatElem = document.getElementById(whatId);
    var whoValue = whoElem ? whoElem.value : "";
    var whatValue = whatElem ? whatElem.value : "";

    var privateElem = document.getElementById(privateCheckboxId);
    if (privateElem != null) {
        if (whoValue != "" || whatValue != "" || this.getInviteePopupCount() > 0) {
            privateElem.checked=false;
            privateElem.disabled=true;
        } else {
            privateElem.disabled=false;
        }
    }
}

EventEditPage.prototype.setInviteePopupCount = function (count) {
    this.inviteePopupCount = count;
}

EventEditPage.prototype.getInviteePopupCount = function () {
    return this.inviteePopupCount;
}

EventEditPage.prototype.adjustWhat = function (isNotLeadWho, isEditableNotPreview, isPrivate) {
    if (isEditableNotPreview){
        if (isPrivate) {
            //dswt is in ActivityUI
            dswt();
            // call disableWho
        } else {
            if (isNotLeadWho) {
                //enwt is in ActivityUI
                enwt();
            } else {
                //dswt is in ActivityUI
                dswt();
            }
            // call enableWho
        }
    }
}

EventEditPage.prototype.adjustWhoWhatForMultiWho = function (whoLookupId, whoTypeId, leadPrefix, isEditableNotPreview, isPrivate) {
    if (isEditableNotPreview){
        if (isPrivate) {
            //dswt is in ActivityUI
            dswt();
            this.disableWho(whoLookupId, whoTypeId);
        } else {
            if (document.getElementById(whoTypeId).value != leadPrefix) {
                //enwt is in ActivityUI
                enwt();
            }
            this.enableWho(whoLookupId, whoTypeId);
        }
    }
}

EventEditPage.prototype.disableWho = function (whoLookupId, whoTypeId) {
    document.getElementById(whoLookupId).disabled=true;
    document.getElementById(whoTypeId).disabled=true;
    var link = document.getElementById(Activity.WHO_BUTTON_ID);
    link.style.display="none";
}

EventEditPage.prototype.enableWho = function (whoLookupId, whoTypeId) {
    document.getElementById(whoLookupId).disabled=false;
    document.getElementById(whoTypeId).disabled=false;
    var link = document.getElementById(Activity.WHO_BUTTON_ID);
    link.style.display="";
}

/*
 * class method called from both edit and detail pages.
 * on detail page there is no allDay element, so we are passing in the saved value
 * and it can't change there because it's a detail page
 */
EventEditPage.adjustReminderOptions = function (isAllDayEventOnDetailPage, allDayId, reminderDateTimeTimeId) {
    var allDayElem = document.getElementById(allDayId);
    var reminderSelectElem = document.getElementById(EventUi.REMINDER_SELECT_ID);
    var reminderDateTimeElem = document.getElementById(EventUi.REMINDER_DATE_TIME_ID);
    var reminderCheckboxElem = document.getElementById(EventUi.REMINDER_SET_ID);

    if (reminderSelectElem && reminderDateTimeElem) {
        var allDay = allDayElem ? allDayElem.checked : isAllDayEventOnDetailPage;
        reminderSelectElem.style.display = allDay ? "none" : "inline";
        reminderDateTimeElem.parentNode.style.display = allDay ? "inline" : "none";
        var reminderSet = reminderCheckboxElem.checked;
        reminderSelectElem.disabled = !reminderSet;
        reminderDateTimeElem.disabled = !reminderSet;
        if (reminderDateTimeTimeId != null) {
            var reminderDateTimeTimeElem = document.getElementById(reminderDateTimeTimeId);
            if (reminderDateTimeTimeElem) {
                document.getElementById(reminderDateTimeTimeId).disabled = !reminderSet;
            }
        }
    }
}

/*
 * onclick handler for recurrence frequency radio buttons.
 * The argument to adjustRecurrenceFrequency() must be the name of the div containing the selected frequency subgroup.
 */
EventEditPage.prototype.adjustRecurrenceFrequency = function (freq) {
    var divIds = EventUi.ALL_SUBGROUP_DIVS;
    for ( i = 0 ; i < divIds.length ; i++) {
        if (divIds.charAt(i) == freq.charAt(0)) {
            document.getElementById(divIds.charAt(i)).style.display="";
        } else {
            document.getElementById(divIds.charAt(i)).style.display="none";
        }
    }
}

EventEditPage.prototype.selectMakeRecurring = function (isRecurrenceId, isAllDayId, activityDateId, startDateId, endDateId) {
    var isRecurrenceElem = document.getElementById(isRecurrenceId);
    var isAllDayElem = document.getElementById(isAllDayId);
    var activityDateElem = document.getElementById(activityDateId);
    var startDateElem = document.getElementById(startDateId);
    var endDateElem = document.getElementById(endDateId);
    var isRecurring = isRecurrenceElem.checked;
    if (activityDateElem) {
        activityDateElem.disabled = isRecurring;
    }
    if (isAllDayElem && startDateElem && endDateElem) {
        var disableDates = isRecurring && isAllDayElem.checked;
        startDateElem.disabled = disableDates;
        endDateElem.disabled = disableDates;
    }
    this.showRecurrenceOptions(isRecurring);
}

EventEditPage.prototype.showRecurrenceOptions = function (showOptions) {
    if (showOptions) {
        document.getElementById(EventUi.RECURRENCE_PATTERN_DIV).style.display="";
        if (document.getElementById(EventUi.pONLINE_MEETING) != null) {
            document.getElementById(EventUi.pONLINE_MEETING).style.display="none";
            document.getElementById(EventUi.pONLINE_HOVER).style.display="none";
        }
    } else {
        document.getElementById(EventUi.RECURRENCE_PATTERN_DIV).style.display="none";
        if (document.getElementById(EventUi.pONLINE_MEETING) != null) {
            document.getElementById(EventUi.pONLINE_MEETING).style.display="";
            document.getElementById(EventUi.pONLINE_HOVER).style.display="";
        }
    }
}

EventEditPage.prototype.updateDates = function (masterDateId, dateFields) {
    var masterDateElem = document.getElementById(masterDateId);
    if (masterDateElem != null) {
        for (var dateFieldId in dateFields) {
            var dateFieldElem = document.getElementById(dateFields[dateFieldId]);
            if (dateFieldElem != null) {
                dateFieldElem.value = masterDateElem.value;
            }
        }
    }
}

EventEditPage.prototype.checkDuration = function (isRecurringId, isAllDayId, startDateId, startTimeId, endDateId, endTimeId) {
    var isRecurringElem = document.getElementById(isRecurringId);
    var isAllDayElem = document.getElementById(isAllDayId);
    var allDay = isAllDayElem ? isAllDayElem.checked : false;
    var startDateElem = document.getElementById(startDateId);
    var startTimeElem = document.getElementById(startTimeId);
    var endDateElem = document.getElementById(endDateId);
    var endTimeElem = document.getElementById(endTimeId);
    var disabledRecurrenceMsgElem = document.getElementById(EventPage.DISABLED_RECURRENCE_MSG_DIV);

    if (isRecurringElem != null && startDateElem != null && endDateElem != null && startTimeElem != null && endTimeElem != null) {
        var startDateVal = startDateElem.value;
        var endDateVal = endDateElem.value;
        var hasStartTime = !startTimeElem.disabled && startTimeElem.value != "";
        var hasEndTime = !endTimeElem.disabled && endTimeElem.value != "";
        var useTime = hasStartTime && hasEndTime;
        if (useTime) {
            startDateVal = startDateVal + " " + startTimeElem.value;
            endDateVal = endDateVal + " " + endTimeElem.value;
        }
        var startDateTime = DateUtil.getDateFromValue(startDateVal, useTime);
        var endDateTime = DateUtil.getDateFromValue(endDateVal, useTime);
        if (startDateTime != null && endDateTime != null) {
            var durationInMinutes = DateUtil.differenceInMinutes(startDateTime, endDateTime);
            if (allDay) {
                durationInMinutes += EventObject.ONE_DAY_IN_MINUTES;
            }
            if (durationInMinutes > EventObject.ONE_DAY_IN_MINUTES) {
                isRecurringElem.checked = false;
                isRecurringElem.disabled = true;
                this.showRecurrenceOptions(false);
                disabledRecurrenceMsgElem.style.visibility="visible";
                return;
            }
        }
        isRecurringElem.disabled = false;
        disabledRecurrenceMsgElem.style.visibility="hidden";
    }
}

EventEditPage.prototype.setDefaultTimes = function (isAllDay, startTimeId, startTimeVal, endTimeId, endTimeVal) {
    var startTimeElem = document.getElementById(startTimeId);
    var endTimeElem = document.getElementById(endTimeId);
    if (!this.defaultTimesSet && !isAllDay && startTimeElem != null && endTimeElem != null) {
        startTimeElem.value = startTimeVal;
        endTimeElem.value = endTimeVal;
        this.defaultTimesSet = true;
    }
}



//#depend common.page.EditPage
/**
  JS code the Tasks for Multiple Users UROG lookup.

  @author eli
  @since 150
*/
function TaskOwnerUROGLookup(controllerId, targetId, selectId, baseName, noneLabel, jsVarName, isSearch) {
    var lookup = this;
    this.appendToOnloadQueue(function() {lookup.init();});
    // incomplete search filter element object so we can set error messages
    this.selectEleId = selectId;
    this.baseName = baseName;
    this.noneLabel = noneLabel;
    this.jsVarName = jsVarName;
    this.isSearch = isSearch;
}

TaskOwnerUROGLookup.prototype = new EditPage();

TaskOwnerUROGLookup.prototype.isUrogId = function(id) {
    if (!id || id.length == 0) {
        return false;
    }
    // Checks for format X:123456789012345
    var idSplit = id.split(':');
    return (idSplit.length == 2 && idSplit[0].length==1 && idSplit[1].length==15);
}

TaskOwnerUROGLookup.prototype.init = function() {
    var lookup = this;
    addEvent(document.getElementById(TaskOwnerLookup.DONE_BUTTON_ID), 'click', function() {lookup.onDone();}, false);
    window.sfdcPage.initButtons([ TaskOwnerLookup.DONE_BUTTON_ID, EditPageConstants.pCANCEL ]);

    this.jsVarName = eval(this.jsVarName);

    // Grab values from Task Edit Page
    if (top.window.opener && !this.isSearch) {
        var labels = JSUtils.splitWithQuoteAndEsc(top.window.opener.document.getElementById(this.baseName + EditElement.pOLD_NAME_SUFFIX).value, TaskUi.ASSIGNEE_SEPARATOR);
        var values = top.window.opener.document.getElementById(this.baseName + TaskOwnerLookup.pLOOKUP_UROG_SUFFIX).value.split(TaskUi.ASSIGNEE_SEPARATOR);
        var idsString = top.window.opener.document.getElementById(this.baseName + EditElement.pID_SUFFIX).value
        var ids = idsString.split(TaskUi.ASSIGNEE_SEPARATOR);

        var targetOptions = document.getElementById(this.selectEleId).options;

        if (idsString.length > 0 && ids.length > 0 && labels.length == values.length && ids.length == values.length) {
            // Check each value (UROG ID) and make sure it's a valid urog style id (U: 005xxxxxxxxxxxx)
            for (var i=0; i<values.length && values[i].length>0 && this.isUrogId(values[i]); i++) {
                var option = new Option (labels[i], values[i]);

                // replace the target value if its the last one
                if (targetOptions.length == 1 && targetOptions[0].text == this.noneLabel) {
                    targetOptions[0] = option;
                } else {
                    targetOptions[targetOptions.length] = option;
                }
            }
            this.jsVarName.beforeMoveRight();
            this.jsVarName.filter();
        }
    }
}

TaskOwnerUROGLookup.prototype.onSwitchTab = function() {
    if (!this.isValueSelected(document.getElementById(this.selectEleId))) {
        //location = loc;
        return true;
    }
    var response = Modal.confirm(LC.getLabel("Page_Task", "confirmSwitchingTabs"));
    if (response) {
        //location = loc;
        return true;
    } else {
        return false;
    }
}

TaskOwnerUROGLookup.prototype.isValueSelected = function(select) {
    if (select.length < 1) {
        return false;
    } else if (select.length == 1) {
        var text = select.options[0].text;
        if (text == null || text == "" || text == this.noneLabel) {
            return false;
        }
    }
    return true;
}

TaskOwnerUROGLookup.prototype.onDone = function() {
    var separator = TaskUi.ASSIGNEE_SEPARATOR;

    var labels = [];
    var values = [];
    var valuesIdOnly = [];

    var select = document.getElementById(this.selectEleId);

    var noneSelectedMsg = LC.getLabel("Page_Task", "taskUrogNoValuesSelected");
    if (!this.isValueSelected(select)) {
        this.jsVarName.showErrorMessage(true, noneSelectedMsg);
        return;
    }

    window.sfdcPage.disableSaveButtons();
    for (var i = 0; i < select.length; i++) {
        var val = select.options[i].value.replace(new RegExp('\\\\','g'), '\\\\');
        val = val.replace(new RegExp(separator,"g"), '\\' + separator);
        values.push(val);

        valuesIdOnly.push(val.replace(new RegExp('.\:', 'g'), ''));

    	var lbl = select.options[i].textContent ? select.options[i].textContent : select.options[i].innerText;
        lbl = lbl.replace(new RegExp('\\\\','g'), '\\\\');
        labels.push(lbl.replace(new RegExp(separator,"g"), '\\' + separator));
    }

    var ajaxServletUrl = UrlMap.convertClassNameToUrl(AjaxGetUsersInGroups.pCLASS_NAME, null);
    var postMap = {};
    // If there's only one selection and it's a user, send the label and id back in normal form.
    if (valuesIdOnly.length == 1 && valuesIdOnly[0].substring(0,3) == '005') {
    	var lbl = select.options[0].textContent ? select.options[0].textContent : select.options[0].innerText;
        lbl = lbl.replace(new RegExp('\\\\','g'), '\\\\');
		lbl = lbl.substring(lbl.indexOf(':')+2);
		var urog = this;
	    setTimeout(function () {top.window.opener.lookupPick('editPage',urog.baseName + EditElement.pID_SUFFIX,urog.baseName,'',
	    	valuesIdOnly[0],lbl,'','')}, 0);
    } else {
        this.valuesIdOnlyString = valuesIdOnly.join(separator);
        this.labelsString = labels.join(separator);
        this.valuesString = values.join(separator);
	    postMap[AjaxGetUsersInGroups.pOWNER_ID_LIST] = this.valuesIdOnlyString;
	    postMap[AjaxGetUsersInGroups.pOWNER_NAME_LIST] = this.labelsString;
	    XBrowser.postHttpResponse(ajaxServletUrl, this.handleResponse, XBrowser.buildPost(postMap));
    }
}

TaskOwnerUROGLookup.prototype.handleResponse = function(request) {
    var response = Util.evalAjaxServletOutput(request.responseText);
    var errorMessage = response[AjaxGetUsersInGroups.pINVALID_GROUPS_MESSAGE];
    var numUsers = response[AjaxGetUsersInGroups.pNUM_USERS];
    var errorPrefix = LC.getLabel("Global", "labelWithColon", LC.getLabel("Global", "error")) + " ";
    if (errorMessage != null) {
        window.sfdcPage.jsVarName.showErrorMessage(true, errorPrefix + errorMessage);
        window.sfdcPage.enableSaveButtons();
        return;
    }
    if (numUsers > TaskUi.MAX_TMU_ASSIGNEES) {
        window.sfdcPage.jsVarName.showErrorMessage(true, errorPrefix + LC.getLabel("Page_Task", "taskUrogTooManyUsersSelected", TaskUi.MAX_TMU_ASSIGNEES));
        window.sfdcPage.enableSaveButtons();
        return;
    } else if (numUsers == 0) {
        window.sfdcPage.jsVarName.showErrorMessage(true, errorPrefix + LC.getLabel("Page_Task", "tmuHasNoUsers"));
        window.sfdcPage.enableSaveButtons();
        return;
    }

    var textSummaryElement = top.window.opener.document.getElementById(window.sfdcPage.baseName + TaskUi.pLOOKUP_SUMMARY_SUFFIX);
    if (textSummaryElement != null) {
        if (numUsers == 1) {
            textSummaryElement.innerHTML = LC.getLabel("Page_Task", "TMU_summary_singular");
        } else {
            textSummaryElement.innerHTML = LC.getLabel("Page_Task", "TMU_summary", numUsers);
        }
    }

    var valuesIdTarget = window.sfdcPage.baseName + EditElement.pID_SUFFIX;
    var valuesTarget = window.sfdcPage.baseName + TaskOwnerLookup.pLOOKUP_UROG_SUFFIX;
    var labelsTarget = window.sfdcPage.baseName;
    setTimeout(function () {top.window.opener.lookupPick('editPage',valuesIdTarget,labelsTarget,valuesTarget,window.sfdcPage.valuesIdOnlyString,
            window.sfdcPage.labelsString,window.sfdcPage.valuesString,'')}, 0);
}

//#depend SearchPage
/*
 * @author agusev
 * @since 146
 * Product specific search results logic
 *
 *
 *
 * Note that ProductSearchPage extends SearchPage - however we need to have SearchPage to be fully initialized before
 * ProductSearchPage.prototype = new SearchPage(); Thus at this point ProductSearchPage should be inluded into library after SearchPage
 *
 *
 */
function ProductSearchPage() {}

ProductSearchPage.prototype = new SearchPage();


ProductSearchPage.prototype.filterResults = function (actionUrl, currentUrl, listUrl, listQS, listId, numFilters) {
        if(!window.sfdcPage.hook_shouldProceedWithAction()){
            return;
         }
        var identifier = this.createIdentifier();
        this.processAction(listId, null, identifier);
        var newUrl = listUrl;

        var elements = document.getElementsByName(SearchRelatedList.pSEARCH)

        var searchQuery;
        // fix for IE
        for(var ind = 0; ind<elements.length; ind++){
            if(elements[ind].id == SearchRelatedList.pSEARCH){
                searchQuery = elements[ind].value;
                break;
            }
        }

        if(searchQuery != ""){
                newUrl = newUrl + "&" + SearchRelatedList.pSEARCH + "=" + this.encodeForSearch(searchQuery);
        }

        var hasFilters = false;
        for(var ind=0;ind<numFilters;ind++){
            var columnParam = listId + FilterSelectionElement.pCOLUMN + ind;
            var operatorParam = listId + FilterSelectionElement.pOPERATOR + ind;
            var valueParam = listId + FilterSelectionElement.pFILTER_VALUE + ind;
            var columnField = document.getElementById(columnParam).value;
            var operatorField = document.getElementById(operatorParam).value;
            var valueField = document.getElementById(valueParam).value;
            if(columnField!="" && operatorField!=""){
                newUrl = newUrl + "&" + columnParam + "=" + this.encodeForSearch(columnField);
                newUrl = newUrl + "&" + operatorParam + "=" + this.encodeForSearch(operatorField);
                newUrl = newUrl + "&" + valueParam + "=" + this.encodeForSearch(valueField);
                hasFilters = true;
            }
        }

        if(hasFilters){
            // used to indicate search filtering and thus trigger large set
            newUrl = newUrl + "&" + SearchRelatedList.FILTER_FIELDS_PARAM + "=1";
        }

          newUrl = this.addActionIdentifier(newUrl, identifier);
          this.callRelatedListActionAndSaveHistory(actionUrl, currentUrl, newUrl, listQS, listId);
}


ProductSearchPage.prototype.evalScripts = function (rlElement) {
  var scriptElements = rlElement.getElementsByTagName('script');
  for (var ind = 0; ind<scriptElements.length;ind++){
      var jsExpression = scriptElements[ind].innerHTML;
      eval(jsExpression);
  }
}

ProductSearchPage.prototype.handleKeyPress = function (event, listId, element) {
    var keynum = this.getKeyNumForEvent(event);
    if(keynum && keynum ==  KEY_ENTER){
        var enterButton = document.getElementById(SearchRelatedList.FILTER_FIELDS_SAVE_PREFIX + listId);
        if(enterButton){
            // need to loose focus on the object to avoid double form submit
            element.blur();
            enterButton.click();
        }
    }
    return false;
}

ProductSearchPage.prototype.verifyChecked = function (form, element_name, errorMessage) {
    var shouldSubmit = verifyChecked(form, element_name, errorMessage);
    if(shouldSubmit){
        form.submit();
    }
    return shouldSubmit;
}

ProductSearchPage.prototype.selectionCancel = function (form) {
    // add hidden input element with cancel name and submit
    var inputElement = document.createElement('input');
    inputElement.type = 'hidden';
    inputElement.name = 'cancel';
    inputElement.value = 'Cancel';
    form.appendChild(inputElement);
    form.submit();
}

ProductSearchPage.prototype.hook_postRelatedListActionUpdate = function(listUrl){
      // this is needed for filter operators to be scoped by selected filter field
      var filterOnloadExpression = " if(window." + FilterSelectionElement.ON_LOAD_CRITERIA + "){ " + FilterSelectionElement.ON_LOAD_CRITERIA  + "(); }";
      eval(filterOnloadExpression);
}

ProductSearchPage.prototype.isTagBrowser = function (dataElement){
    return false;
}




//#depend SearchPage
/*
 * @author agusev
 * @since 150
 * Tag browsing and search logic
 *
 */
function TagSearchPage() {
    this.menuButtonOpenId = null;
    this.activeCancelRenameButton = null;
}

TagSearchPage.prototype = new SearchPage();

TagSearchPage.prototype.setTagLinkReturnsResults = function (value) {
    this.tagLinkReturnResults = value;
}

TagSearchPage.prototype.setMenuButtonOpen = function (parentDiv) {
    var existingElementId = this.menuButtonOpenId;
    this.onLinkOver(parentDiv);
    this.menuButtonOpenId = parentDiv.id;

    // try close existing element
    if(existingElementId){
        var element = document.getElementById(existingElementId);
        if (element) {
            this.onLinkOut(element);
        }
    }
}

TagSearchPage.prototype.setMenuButtonClosed = function () {
    var existingElementId = this.menuButtonOpenId;
    this.menuButtonOpenId = null;
    if(existingElementId){
        var element = document.getElementById(existingElementId);
        if (element) {
            this.onLinkOut(element);
        }
    }
}

/**
 * Depending on the current tagLinkReturnResults (tagLinkMode)
 * this will either return results or populate tag seleciton field
 */
TagSearchPage.prototype.tagLinkAction = function (actionUrl, tagLink, tagLinkId, thisLink) {
    // always populate tag selection field
    this.removeError();
    var noneLabel = LC.getLabel("ManageTags", "noneSelected");

    if (this.hasTagsInEdit()) {
        var found = false;
        for (var i = 0; i < this.currentTags.length; i++) {
            var curTag = this.currentTags[i];
            var curTagId = this.currentTagsIds[i];
            if (curTag == tagLink && curTagId == tagLinkId) {
                this.currentTags.splice(i, 1); // remove found element
                this.currentTagsIds.splice(i, 1); // remove found element id
                found = true;
                break;
            }
        }
        if (!found) {
            this.currentTags.push(tagLink);
            this.currentTagsIds.push(tagLinkId);
        }
    } else {
         this.currentTags = [tagLink];
         this.currentTagsIds = [tagLinkId];
    }
    this.updateCurrentTags();

    window.location = this.addAdditionalParams(actionUrl, true);

}

/**
 * Updates selected tag field and the corresponding HTML element displaying data
 * @param newSelectedTags (optional) replaces current list of selected tags
 */
TagSearchPage.prototype.updateCurrentTags = function(newSelectedTags, newSelectedTagIds) {
    if (newSelectedTags && newSelectedTagIds) {
        this.currentTags = newSelectedTags;
        this.currentTagsIds = newSelectedTagIds;
    }
    var changeTagsArea = document.getElementById(TagConstants.CHANGE_TAGS_NAMES);
    var changeTagsIdsArea = document.getElementById(TagConstants.CHANGE_TAGS_IDS);
    if (changeTagsArea && changeTagsIdsArea) {
        if (this.hasTagsInEdit()) {
            changeTagsArea.innerHTML = this.currentTags.join(', ');
            changeTagsIdsArea.innerHTML = this.currentTagsIds.join(', ');
        } else {
            changeTagsArea.innerHTML = LC.getLabel("ManageTags", "noneSelected");
            changeTagsIdsArea.innerHTML = LC.getLabel("ManageTags", "noneSelected");
        }
    }
}


TagSearchPage.prototype.swtichScopeMode = function (targetUrl) {
    window.location = targetUrl;
}



TagSearchPage.prototype.inlineEditAction = function(tagValue, tagId, listUrl, listQS, listId, description, tagScopeMode, isDelete, updateElementId, errorDiv, fallbackUpdateValue) {
    if (!this.hook_shouldProceedWithAction()) {
        return;
    }

    var updateString;
    var inputElement;

    if (isDelete){
        // we still send update string as indicator of edit action
        updateString = "delete";
    } else {
        inputElement = document.getElementById(updateElementId);
        updateString = inputElement ? inputElement.value : fallbackUpdateValue;
    }

    if(!updateString) {
        this.displayError(LC.getLabel("ManageTags", "errorMissingName"), false, errorDiv);
        if (inputElement) inputElement.className = inputElement.className + " " +EditElement.ERROR_CLASS;
        return false;
    } else if (/[,\.\\\/\'"!@#\$%\^&\*\(\)\+=\{\}:;<>\|\[\]]/.exec(updateString)) {
        // This regex is matches a number invalid characters, it's not exhaustive
        this.displayError(LC.getLabel("ManageTags", "errorOnRename"), false, errorDiv);
        if (inputElement) inputElement.className = inputElement.className + " " +EditElement.ERROR_CLASS;
        return false;
    } else if ((TagAutoComplete.normalize(updateString).length === 0)) {
        this.displayError(LC.getLabel("TagHeader", "tag_whitespace_error"), false, errorDiv);
        if (inputElement) inputElement.className = inputElement.className + " " +EditElement.ERROR_CLASS;
        return false;
    }

    // if this is rename check whether this merge tags
    if(!isDelete) {

        var queryString = new QueryString("");
        queryString.add("t", new Date().getTime());
        queryString.add(TagConstants.TAG_UPDATE_STRING, updateString);
        queryString.add(TagConstants.pTAG_SCOPE_MODE, tagScopeMode);
        queryString.add(TagConstants.TAG_ID_LIST, tagId);

        var loc = TagConstants.TAG_MERGE_CHECK + queryString.toString();

        var self = this;

        var handleRenameResponse = function(response) {
            var response = Util.evalAjaxServletOutput(response.responseText);
            var renameTagId = response.tagId;
            if (renameTagId && window.confirm(LC.getLabel('ManageTags','renameWarning', updateString))) {
                self.inner_inlineEditAction(updateString, tagValue, tagId, listUrl, listQS, listId, description, tagScopeMode, isDelete, updateElementId, errorDiv, renameTagId);
            } else if(!renameTagId) {
                self.inner_inlineEditAction(updateString, tagValue, tagId, listUrl, listQS, listId, description, tagScopeMode, isDelete, updateElementId, errorDiv);
            }
        }
        var handleRenameError = function(err) {
            if (self.saveCancelCall) {
                self.saveCancelCall();
            }
            self.displayError(LC.getLabel("TagHeader", "server_error_edit"));
        };
        XBrowser.getHttpResponse(loc, handleRenameResponse, handleRenameError);
    } else {
        this.inner_inlineEditAction(updateString, tagValue, tagId, listUrl, listQS, listId, description, tagScopeMode, isDelete, updateElementId, errorDiv);
    }
}

TagSearchPage.prototype.inner_inlineEditAction = function(updateString, tagValue, tagId, listUrl, listQS, listId, description, tagScopeMode, isDelete, updateElementId, errorDiv, renameTagId) {

    var postQs = new QueryString("");
    postQs.add(TagConstants.TAG_UPDATE_STRING, updateString);
    postQs.add(TagConstants.IS_DELETE, isDelete ? "1" : "0");
    postQs.add(TagConstants.pTAG_SCOPE_MODE, tagScopeMode);
    postQs.add(TagConstants.TAG_ID_LIST, tagId);


    var identifier = this.createIdentifier();
    this.processAction(listId, description, identifier, true);
    if(this.activeCancelRenameButton){
        this.activeCancelRenameButton.click();
        this.activeCancelRenameButton = null;
    }
    var listUrl = this.addActionIdentifier(listUrl, identifier);
    // do not add tag list to ensure edit or delete operation clears selection
    listUrl = this.addAdditionalParams(listUrl);

    // if we are merging than in tag list use tag that we are merging to if current tag is selected
    if (renameTagId) {
        listUrl = listUrl.replace(new RegExp( tagId, "g" ), renameTagId);
    }

     // handlers for save action
    var self = this;
    var handleError = function(err) {
        if (self.saveCancelCall) {
            self.saveCancelCall();
        }
        self.displayError(LC.getLabel("TagHeader", "server_error_edit"));
    };

    var handleResponse = function(request) {
        var xmlDoc = request.responseXML;
        // ensure that xml document returned
        if(!xmlDoc || (XBrowser.userAgent.isIE && !xmlDoc.xml)) {
            // handles the case of logout
            if (request.status == 200) {
                window.location.reload();
            } else {
                // otherwise displays an error
                self.saveCancelCall();
                self.displayError(LC.getLabel("TagHeader", "unknown_error"));
                return;
            }
        }
        var saved = xmlDoc.getElementsByTagName("ok")[0];
        if (saved) {
            self.removeError();

            if(!self.hasTagsInEdit()){
                callRelatedListAction(null, listUrl, listQS, listId, true, function() {
                    if (isDelete) {
                        self.notifySuccess(LC.getLabel("ManageTags", "successDelete", tagValue));
                    } else {
                        self.notifySuccess(LC.getLabel("ManageTags", "successRename", tagValue, updateString));
                    }});
                TagMenuButton.flushCache();
            } else {
                window.location = self.createInlinePageReloadUrl(listUrl, isDelete, tagValue, updateString);
            }
        }
        else {
            if (self.saveCancelCall) {
                self.saveCancelCall();
            }
            var error = xmlDoc.getElementsByTagName("error")[0];
            if (error) {
                self.displayError(error.firstChild.nodeValue, true);
            } else {
                self.displayError(LC.getLabel("TagHeader", "unknown_error"));
            }
        }
    };

    // use separate request to save tags
    // and call callRelatedListAction after update
    var loc = TagConstants.EDIT_TAGS_PAGE + "?t=" + new Date().getTime();
    var queryString = postQs.toString();
    XBrowser.postHttpResponse(loc, handleResponse, queryString.substring(1, queryString.length), handleError);
}


TagSearchPage.prototype.createInlinePageReloadUrl = function(listUrl, isDelete, tagValue, updateString) {
    if(listUrl){
        var parts = listUrl.split('?');
        var qs = (parts.length>1) ? parts[1] : "";
        var listQs = new QueryString(qs);
        listQs.remove(SearchRelatedList.SEARCH_ACTION_IDENTIFIER_PARAM);
        listQs.remove(TagConstants.TAG_SET_HAS_RECORDS);
        listQs.remove("rId");
        listQs.add(TagConstants.TAG_VALUE_FOR_UPDATE, tagValue);
        if(!isDelete){
            listQs.add(TagConstants.TAG_UPDATE_STRING, updateString);
        }
        var newListQs = listQs.toString();
        return parts[0] + newListQs;
    }
    return listUrl;
}

TagSearchPage.prototype.inlineDeleteAction = function(tagValue, tagId, listUrl, listQS, listId, description, tagScopeMode) {
    this.inlineEditAction(tagValue, tagId, listUrl, listQS, listId, description, tagScopeMode, true, null);
}

TagSearchPage.prototype.inlineRenameAction = function(elementId, tagValue, tagId, listUrl, listQS, listId, description, tagScopeMode) {

    var element = document.getElementById(elementId + MenuButtonElement.BUTTON);

    if (element) {

        // for IE we're only covering browser section at this point
        var tagBrowser = document.getElementById(XBrowser.userAgent.isIE ? TagConstants.BROWSER_TAG_TABLE_ID : TagConstants.BROWSER_LIST_ID);
        // prevent clicking on other tags from tag edit menu is open
        if (tagBrowser){
            var tagBrowserCover = document.createElement('div');
            tagBrowser.style.position = "relative";
            tagBrowser.appendChild(tagBrowserCover);
            tagBrowserCover.style.height = tagBrowser.clientHeight + "px";
            tagBrowserCover.style.width = tagBrowser.clientWidth + "px";
            tagBrowserCover.className = 'waitingHeaderSearchDiv';
        }

        var divElement = document.createElement('div');
        divElement.style.position = "absolute";
        divElement.style.display = 'none';
        element.parentNode.parentNode.appendChild(divElement);


        var inputField = document.createElement('input');
        inputField.type = "text";
        inputField.name = "tagRename" + elementId;
        inputField.id = inputField.name;
        inputField.maxLength = "100";
        inputField.size = "30";
        inputField.className = "tagRename";
        inputField.value = tagValue;
        divElement.appendChild(inputField);

        divElement.appendChild(document.createElement('br'));

        var self = this;

        var errorSpan = document.createElement('span');
        errorSpan.className = 'errorMsg';
        var errorDiv = document.createElement('div');
        errorDiv.style.display = 'none';
        errorDiv.className =  'tagRenameMenuError'
        errorDiv.appendChild(errorSpan);

        var cancelButton = document.createElement('input');
        cancelButton.title = LC.getLabel("Global","cancel");
        cancelButton.value = cancelButton.title;
        cancelButton.className = 'btn';
        cancelButton.type = "button";
        cancelButton.onclick = function () {
            element.parentNode.parentNode.removeChild(divElement);
            if (tagBrowser) {
                tagBrowser.removeChild(tagBrowserCover);
                tagBrowserCover = null;
            }
            divElement = null;
            self.onLinkOut(element.parentNode);
        };

        var saveButton = document.createElement('input');
        saveButton.title = LC.getLabel("Global","save");
        saveButton.value = saveButton.title;
        saveButton.className = 'btn';
        divElement.className = "tagRenameMenu";
        saveButton.type = "button";

        saveButton.onclick = function () {
            self.activeCancelRenameButton = cancelButton;
            self.inlineEditAction(tagValue, tagId, listUrl, listQS, listId, description, tagScopeMode, false, inputField.id, errorDiv);
        }
        divElement.appendChild(saveButton);
        divElement.appendChild(cancelButton);
        divElement.appendChild(errorDiv);
        // once the element is created show it on the page
        divElement.style.display = 'block';
        // this allows to select a tag when it is being edited
        inputField.onfocus = function () {
            setTimeout(function() {self.onLinkOver(element.parentNode)}, 0);
        }

        inputField.focus();

        inputField.onkeypress = function (e) {
            var keynum = self.getKeyNumForEvent(e);
            if (keynum && keynum ==  KEY_ESC) {
                cancelButton.click();
            } else if(keynum && keynum ==  KEY_ENTER) {
                saveButton.click();
            }
        }
    } else if (UserContext.isAccessibleMode) {
        var newName = window.prompt(LC.getLabel('ManageTags', 'accessibleRenamePrompt'), tagValue);
        if (newName) {
            this.inlineEditAction(tagValue, tagId, listUrl, listQS, listId, description, tagScopeMode, false, null, null, newName);
        }
    }
}

// saves tag browser cancel loading call
TagSearchPage.prototype.hook_saveCancelCall = function(listId, cancelCall) {
    if(listId && listId == TagConstants.BROWSER_LIST_ID){
        this.saveCancelCall = cancelCall;
    }
}

TagSearchPage.prototype.clearVariablesOnActionLoad = function () {
    if (this.saveCancelCall) {
        this.saveCancelCall = null;
    }
}

/**
 * This will be called on navigation back event from
 * non-tag page - it can be used to update state variables based on listUrl
 */
TagSearchPage.prototype.hook_updatedStateOnLoad = function(listUrl, listId){
    if(listId && listId == TagConstants.BROWSER_LIST_ID) {
        var parts = listUrl.split('?');
        var qs = (parts.length > 1) ? parts[1] : "";
        var listQs = new QueryString(qs);
    }
}

TagSearchPage.prototype.addAdditionalParams = function(listUrl, nonInlineAction) {
    if(listUrl){
        var parts = listUrl.split('?');
        var qs = (parts.length > 1) ? parts[1] : "";
        var listQs = new QueryString(qs);
        listQs.add(TagConstants.TAG_ID_LIST, this.hasTagsInEdit() ? (this.currentTagsIds.join(',')) : "");
        var tagSearchField = document.getElementById(TagConstants.SAVED_TAG_SEARCH);
        if (tagSearchField && tagSearchField.innerHTML && tagSearchField.innerHTML.length > 0) {
            var searchString = tagSearchField.innerHTML;
            listQs.add(TagConstants.TAG_SEARCH_FIELD, this.processTagSearchString(searchString));
        }

        // maintain the state of tag returned records
        var tagResults = document.getElementById(TagConstants.TAG_RESULTS_ID);
        if (!nonInlineAction && tagResults && tagResults.childNodes.length > 0){
            listQs.add(TagConstants.TAG_SET_HAS_RECORDS, "1");
        } else if (!nonInlineAction){
            listQs.add(TagConstants.TAG_SET_HAS_RECORDS, "0");
        }

        var newListQs = listQs.toString();
        if (this.currentTags && this.currentTagsIds) {
            this.currentTags = null;
            this.currentTagsIds = null;
        }
        return parts[0] + newListQs;
    }
    this.removeError();
    return listUrl;
}

/**
 * @return true if there are tags currently selected
 */
TagSearchPage.prototype.hasTagsInEdit = function() {
    if (!this.currentTags || !this.currentTagsIds) { // if uninitialized, initialize
        var changeTagsArea = document.getElementById(TagConstants.CHANGE_TAGS_NAMES);
        var changeTagsIdsArea = document.getElementById(TagConstants.CHANGE_TAGS_IDS);
        var noneLabel = LC.getLabel("ManageTags", "noneSelected");
        if (changeTagsIdsArea && changeTagsIdsArea.innerHTML != noneLabel && changeTagsArea && changeTagsArea.innerHTML != noneLabel) {
            this.currentTags = changeTagsArea.innerHTML.split(', ');
            this.currentTagsIds = changeTagsIdsArea.innerHTML.split(', ');
        } else {
            this.currentTags = [];
            this.currentTagsIds = [];
        }
    }
    return (this.currentTags && this.currentTags.length > 0 && this.currentTagsIds && this.currentTagsIds.length > 0);
}

// adjust for borders
TagSearchPage.prototype.getHeightForLoadingElementTag = function (dataElement){
    var borderOffset = -2;
    return dataElement.scrollHeight + borderOffset + "px";
}

TagSearchPage.prototype.getWidthForLoadingElementTag = function (dataElement){
    var borderOffset = -2;
    return dataElement.scrollWidth  + borderOffset + "px";
}

TagSearchPage.prototype.isTagBrowser = function (dataElement){
    return dataElement.childNodes[0] && dataElement.childNodes[0].id == TagConstants.BROWSER_TAG_TABLE_ID;
}

TagSearchPage.prototype.wrapTagBrowserSearch = function (actionUrl, currentUrl, listUrl, listQS, listId, description, hasExistingStirng) {
    this.removeError();
    var tagSearchField = document.getElementById(TagConstants.TAG_SEARCH_FIELD);
    if(tagSearchField) {
        var parts = listUrl.split('?');
        var qs = (parts.length > 1) ? parts[1] : "";
        var listQs = new QueryString(qs);
        var searchString = this.processTagSearchString(tagSearchField.value);
        listQs.add(TagConstants.TAG_SEARCH_FIELD, searchString);
        var savedTagSearchField = document.getElementById(TagConstants.SAVED_TAG_SEARCH);

        // clear out saved tag search only if
        if (savedTagSearchField && !hasExistingStirng) {
            savedTagSearchField.innerHTML = searchString;
        }

        if (hasExistingStirng || (searchString && searchString.length > 0)) {
            listQs.add("lsc", TagConstants.ROLODEX_SEARCH_VALUE);
        }else if(!searchString || searchString.length == 0) {
            // reset to all selector
            listQs.add("lsc", "-1");
        }


        var newListQs = listQs.toString();
        this.wrapDhtmlWaitingRequest(actionUrl, currentUrl, parts[0] + newListQs, listQS, listId, description, true);
    } else {
        this.wrapDhtmlWaitingRequest(actionUrl, currentUrl, listUrl, listQS, listId, description, true);
    }
}

TagSearchPage.prototype.processTagSearchString = function (searchString) {
    if(searchString){
        searchString = searchString.replace(/'/g, '"');
        searchString = searchString.replace(/\+/g, ' ');
    }
    return searchString;
}


TagSearchPage.prototype.submitTagBrowserAction = function (event, buttonId){
    if(buttonId){
        var button = document.getElementById(buttonId);
        if(button){
            var keynum = this.getKeyNumForEvent(event);
            if(keynum && keynum ==  KEY_ENTER){
                var editField = document.getElementById(TagConstants.TAG_EDIT_FIELD);
                if (editField) editField.blur();
                button.click();
                button.blur();
            }
        }
    }
}


TagSearchPage.prototype.getControlHeadersForCover = function(listSection) {
    if(listSection && listSection.id == TagConstants.BROWSER_LIST_ID) {
        var headers = new Array();
        headers[0] = getElementsByClassName(TagConstants.BROWSER_SEARCH_HEADER_CLASS, listSection, "div")[0];
        headers[1] = getElementsByClassName("withFilter", listSection, "div")[0];

        if (XBrowser.userAgent.isIE) {
            headers[2] = getElementsByClassName("withFilter", listSection, "table")[0];
        } else {
            headers[2] = getElementsByClassName("bNext", listSection, "div")[0];
        }

        return headers;
    } else {
        return getElementsByClassName("pbHeader", listSection, "div");
    }
}

/**
 * Displays error message dynamically based on the current edit mode.
 */
TagSearchPage.prototype.displayError = function(msg, skipErrorPrefix, errorElement) {
    var errorDiv = errorElement ? errorElement : document.getElementById(TagConstants.ERROR_DIV_ID);
    if (errorDiv) {
        if (errorDiv.lastChild) {
            errorDiv.lastChild.innerHTML = (skipErrorPrefix ? "" :(LC.getLabel('Global', 'error') + ': ')) + msg;
        }
        if (errorDiv.style.display == 'none') {
            if(errorElement){
                errorDiv.style.display = 'block';
            } else {
                // only use animation for default error position
                Animation.rollIn(errorDiv);
            }
        }
    }
}

/**
 * Removes error message dynamically based on the current edit mode.
 */
TagSearchPage.prototype.removeError = function(errorElement) {
    var errorDiv = errorElement ? errorElement : document.getElementById(TagConstants.ERROR_DIV_ID);
    if (errorDiv && errorDiv.style.display != 'none') {
        Animation.rollOut(errorDiv);
    }
}

/**
 * Adds right padding to the rolodex to resolve Firefox issue with
 * borders on span elements.
 */
TagSearchPage.prototype.fixRolodexPadding = function() {
    var rolodex = document.getElementById(TagConstants.TAG_ROLODEX_ID);
    if (!rolodex || !XBrowser.userAgent.isFirefox) return;
    var letters = rolodex.childNodes.length - 4;
    if (letters > 0) {
        rolodex.style.paddingRight = (letters * 2) + 'px';
    }
}

/**
 * Display message in success notification element.
 * @param msg message string, if null notification element is hidden
 */
TagSearchPage.prototype.notifySuccess = function(msg) {
    var elem = document.getElementById(TagConstants.NOTIFY_MSG_ID);
    if (!elem || !elem.parentNode) return;
    var parentDiv = elem.parentNode;
    if (msg) {
        elem.innerHTML = msg;
        if (parentDiv.style.display == 'none') {
            parentDiv.style.display = 'block';
            setTimeout(function() {Animation.rollOut(parentDiv)}, 5000);
        }
        return;
    }
    parentDiv.style.display = 'none';
}

TagSearchPage.prototype.onLinkOver = function(element) {
    if (element.parentNode.className.indexOf('hover') < 0 && this.menuButtonOpenId != element.id) {
        this.existingClass = element.parentNode.className;
        element.parentNode.className = element.parentNode.className + ' hover';
    }
}

TagSearchPage.prototype.onLinkOut = function(element) {
    if (this.menuButtonOpenId != element.id){
        element.parentNode.className = this.existingClass;
    }
}

TagSearchPage.prototype.addUnloadClearState = function() {
    if (XBrowser.userAgent.isIE) {
        if (this.dhtmlHistory) {
            this.dhtmlHistory.iframe = null;
            this.dhtmlHistory.parentObject = null;
            this.dhtmlHistory.listener = null;
            this.dhtmlHistory.historyStorage = null;
        }
        this.dhtmlHistory = null;

        this.openComponent = null;
        this.historyCounter = null;
        this.historyPrefix = null;
        this.historyStorage = null;
        this.actionIdStorage = null;
        this.duelingBoxRef = null;

        this.tagLinkReturnResults = null;
        this.currentTags = null;
        this.currentTagIds = null;
        this.menuButtonOpenId = null;
        this.ignoreClose = null;
    }
}
//#depend SearchPage
/*
 * @author pburstein
 * @since 152
 * Lookup Search Page
 *
 */

function LookupSearchPage() {
    SearchPage.call(this);
}

LookupSearchPage.prototype = new SearchPage();

//#depend SearchPage
/*
 * @author agusev
 * @since 154
 * Selection specific search results logic
 *
 */
function SelectionSearchPage() {}

SelectionSearchPage.prototype = new SearchPage();

SelectionSearchPage.prototype.hook_shouldProceedWithAction = function(){

    var elems = document.getElementsByName(ListView.CHECKBOX_ID);
    if(!elems) return;
    var counter = 0;
    for (i = 0; i < elems.length; ++i) {
        if(elems[i].checked){
            counter++;
        }
    }

    if (counter > 0) {
        return window.confirm(LC.getLabel('List','checkboxWarning'));
    } else {
        return true;
    }
}


SelectionSearchPage.prototype.hook_postRelatedListActionUpdate = function(listUrl){
    var hiddenSaveUrl = document.getElementsByName(EditPageConstants.pSAVE_NEW_URL);
    if (!hiddenSaveUrl || !hiddenSaveUrl[0]) {
        return;
    }
    hiddenSaveUrl[0].value = listUrl;

    // this is needed for filter operators to be scoped by selected filter field
      var filterOnloadExpression = " if(window." + FilterSelectionElement.ON_LOAD_CRITERIA + "){ " + FilterSelectionElement.ON_LOAD_CRITERIA  + "(); }";
      eval(filterOnloadExpression);
}

SelectionSearchPage.prototype.verifyChecked = function (form, element_name, errorMessage) {
    var shouldSubmit = verifyChecked(form, element_name, errorMessage);
    if(shouldSubmit && window.confirm(LC.getLabel('DeactivatedUserTagCleanupPage','cleanConfirmation'))){
        form.submit();
    }
    return shouldSubmit;
}

SelectionSearchPage.prototype.selectionCancel = function (form) {
    // just redirect to tag home url
    window.location = TagConstants.TAG_SEARCH_RESULTS_URL;
}


SelectionSearchPage.prototype.evalScripts = function (rlElement) {
  var scriptElements = rlElement.getElementsByTagName('script');
  for (var ind = 0; ind<scriptElements.length;ind++){
      var jsExpression = scriptElements[ind].innerHTML;
      eval(jsExpression);
  }
}

SelectionSearchPage.prototype.isTagBrowser = function (dataElement){
    return false;
}
//#depend ProductSearchPage
/*
 * @author agusev
 * @since 146
 * Product selection specific search results logic
 * 
 */
function ProductSelectionSearchPage() {}

ProductSelectionSearchPage.prototype = new ProductSearchPage();

ProductSelectionSearchPage.prototype.hook_shouldProceedWithAction = function(){
	
	var elems = document.getElementsByName(ListView.CHECKBOX_ID);
    if(!elems) return;
    var counter = 0;
    for (i = 0; i < elems.length; ++i) {
        if(elems[i].checked){
        	counter++;
        }
    }
	
	if (counter > 0) {
		return window.confirm(LC.getLabel('List','checkboxWarning'));
	} else {
		return true;
	}
} 


ProductSelectionSearchPage.prototype.hook_postRelatedListActionUpdate = function(listUrl){
	var hiddenSaveUrl = document.getElementsByName(EditPageConstants.pSAVE_NEW_URL);
	if (!hiddenSaveUrl || !hiddenSaveUrl[0]) {
		return;
	}
	hiddenSaveUrl[0].value = listUrl;
	
	// this is needed for filter operators to be scoped by selected filter field
  	var filterOnloadExpression = " if(window." + FilterSelectionElement.ON_LOAD_CRITERIA + "){ " + FilterSelectionElement.ON_LOAD_CRITERIA  + "(); }";
  	eval(filterOnloadExpression);
}
LC.labels = {
 'BrowseTags' : { 'noRecentTags' : 'No Recent Tags'}, 
 'Buttons' : { 'cancel' : 'Cancel' , 'close' : 'Close' , 'del' : 'Delete' , 'help' : 'Help' , 'ins' : 'Insert' , 'ok' : 'OK' , 'save' : 'Save' , 'saving' : 'Saving...' , 'submit' : 'Submit'}, 
 'CRTLookupLayer' : { 'ClearAll' : 'Clear All' , 'Path' : 'Path' , 'layerDesc' : 'Newly added fields will appear inside layout section labeled' , 'layerHeader' : 'Add Fields Related to' , 'maxDepthLimit' : '(Maximum lookup limit reached)' , 'viaLookup' : 'Via Lookup' , 'viaLookupParen' : '(via lookup)' , 'viewRelatedFields' : 'view related fields...'}, 
 'CaptchaElement' : { 'audio' : 'Get an audio challenge' , 'audioPrompt' : 'Enter the numbers you hear:' , 'dialog' : 'This simple test helps prevent malicious programs from accessing your data.  Your administrator requires this test for large downloads.  It will never be presented more than once per login session.' , 'image' : 'Get an image challenge' , 'imagePrompt' : 'Enter the words above, separated by a space:' , 'incorrect' : 'Incorrect, please try again' , 'lessinfo' : '&laquo; Less info' , 'moreinfo' : 'More info &raquo;' , 'refresh' : 'Get a new challenge'}, 
 'CrtLayout' : { 'CustomLabel' : 'Display As' , 'associatedWith' : 'associated with' , 'availFieldHover' : 'To add this field to the page layout, drag it into a field section' , 'checked' : 'Checked' , 'defaultState' : 'Default State:' , 'dragMultiSelect' : 'MultiSelect' , 'fieldsLimitErrorMsg' : 'You have exceeded the maximum limit of {0} fields. You cannot save this layout until the field count is at or below {0}.' , 'layoutSecHover' : 'To move this section, click this header and drag it to the desired new location' , 'lookupPath' : 'Lookup Path:' , 'mustSelectField' : 'Please select at least one item from within the page layout sections.' , 'sectionDelete' : 'Delete' , 'sectionEdit' : 'Edit' , 'sourceObject' : 'Source Object:' , 'unchecked' : 'Unchecked'}, 
 'DeactivatedUserTagCleanupPage' : { 'cleanConfirmation' : 'Cleaned Tags can not be restored, are you sure you would like to clean tags?'}, 
 'DependentElement' : { 'dependentFields' : 'Dependent Fields' , 'dependsOn' : 'depends on "{0}"'}, 
 'Edit' : { 'CharactersOver' : 'over limit' , 'CharactersRemaining' : 'remaining'}, 
 'EmailTemplate' : { 'SetLockedConfirmText' : 'Are you sure you want to lock this section?\n\nClick OK to prevent users from editing this section when sending an email' , 'emptyCellText' : 'Click here to enter content'}, 
 'FLSLayout' : { 'Layout' : 'Page Layout'}, 
 'Filter' : { 'DeleteConfirm' : 'Delete this view?' , 'edit' : 'Edit' , 'new' : 'Create New View' , 'refresh' : 'Refresh'}, 
 'FilterScope' : { '0' : 'User\'s Records' , '1' : 'User\'s Records' , '2' : 'All Records' , 'A' : 'User\'s Account Team\'s Records' , 'None' : 'None (Search Only)' , 'S' : 'User\'s Sales Team\'s Records' , 'T' : 'User\'s Team\'s Records'}, 
 'ForecastSharingPref' : { 'confirmAssignNoMgr' : 'Removing the forecast manager from this territory or role will also remove all manually shared access for any delegated forecast managers to this territory or role. Continue?'}, 
 'Global' : { 'action' : 'Action' , 'are_you_sure' : 'Are you sure?' , 'cancel' : 'Cancel' , 'colonSeparatedWords' : '{0}: {1}' , 'deleted' : 'Deleted' , 'error' : 'Error' , 'labelWithColon' : '{0}:' , 'loading' : 'Loading...' , 'save' : 'Save'}, 
 'GoogleAppsActivationUi' : { 'deactivateButton' : 'Deactivate' , 'deactivateTitle' : 'Feature Deactivation'}, 
 'GoogleDocCreatorPage' : { 'errorMsgNoValue' : 'Error: you must enter a value' , 'nameText' : 'Name Your New {0}' , 'pageTitle' : 'Create Google Doc'}, 
 'GoogleDocsActivationUi' : { 'deactivateWarningHeader' : 'Deactivating this feature will:'}, 
 'Icons' : { 'inlineEditUndo' : 'Undo' , 'lookup' : 'Lookup (New Window)'}, 
 'Images' : { 'checkbox_checked' : 'Checked' , 'checkbox_unchecked' : 'Not Checked'}, 
 'LayoutDND' : { 'confirmDeleteSectionPrompt' : 'Deleting this section will cause all its fields to be put back into Available Fields.'}, 
 'LayoutMap' : { 'Changed' : 'Changed' , 'NotAssigned' : 'Not Assigned' , 'PLAChangesAboveLimit' : 'Exceeded the maximum number of page layout assignment changes: {0}. To continue, save your changes before making additional changes to page layout assignments.' , 'Profiles' : 'Profiles' , 'RecordTypes' : 'Record Types' , 'SelectOne' : '-- Select Page Layout --' , 'Selected' : 'Selected'}, 
 'List' : { 'checkboxLimit' : 'You must select {0} rows or less to perform this operation.' , 'checkboxWarning' : 'Your selections on this page will be lost. Do you want to continue?' , 'edit' : 'Edit' , 'none' : 'Data not available for this view.' , 'selectionLimit' : 'You cannot select more than {0} rows.'}, 
 'Lookup' : { 'Title' : 'Lookup'}, 
 'MailMergeChoose' : { 'EntityName' : '{0} Name'}, 
 'ManageTags' : { 'accessibleRenamePrompt' : 'Enter new tag name: ' , 'errorMissingName' : 'You must specify a new tag name.' , 'errorOnRename' : 'Tags can only contain letters, numbers, spaces, dashes, and underscores, and must contain at least one letter or number.' , 'noneSelected' : '(None Selected)' , 'renameWarning' : 'A tag named "{0}" already exists. Click OK to combine the tags or click Cancel to specify a different tag name.' , 'successDelete' : 'You successfully deleted tag "{0}".' , 'successRename' : 'All instances of the tag "{0}" were renamed to "{1}".'}, 
 'ManageableInfo' : { 'LessInfo' : 'Hide Information' , 'MoreInfo' : 'Display More Information'}, 
 'MassListEdit' : { 'ClearSelected' : 'Clear Selected' , 'EditLabel' : 'Apply changes to' , 'ErrorColumn' : 'Error Description' , 'ManyErrors' : '{0} records did not save, review the details below.' , 'ManySuccessful' : '{0} records saved. ' , 'MultiEdit' : 'All {0} selected records' , 'NoName' : 'Not Available' , 'OneError' : '1 record did not save, review the details below.' , 'OneSuccessful' : '1 record saved.' , 'SingleEdit' : 'The record clicked' , 'Summary' : 'Error Summary'}, 
 'MobileConfig_Section_Filter' : { 'ExceptionTitle' : 'An internal server error has occurred'}, 
 'MobileConfig_Section_SyncSet' : { 'AddDlg_Caption' : 'Add a Data Set' , 'AddDlg_Label_SelectFrom' : 'Select From: ' , 'AddDlg_NoMoreObjects' : 'There are no more objects available for selection.' , 'AutoSave_PageUnloadError' : 'Your changes to {0} could not be saved.' , 'FilterPane_DefaultTitle' : 'Click "Add..." to add a Data set.' , 'FilterPane_Title_Loading' : 'Loading {0} ...' , 'FilterPane_Title_Saving' : 'Saving {0} ...' , 'RefreshDataSize' : 'Refresh Data Size' , 'TestDataSize' : 'Estimate Data Size' , 'WaitDlg_Text' : 'Please wait...'}, 
 'NewFormulaEditor' : { 'SelectedInfo' : 'You have selected:'}, 
 'ObjectsUi' : { 'ForcedOuterJoin_Body' : 'This relationship will be applied to this object and all subsequent objects.  Continue?' , 'ForcedOuterJoin_Title' : 'Confirm' , 'noDelete' : 'No, make no changes' , 'objectRemovalAlert_Body' : 'Changing related objects will impact reports created from this report type.&lt;br&gt;&lt;br&gt;\n                   It may also affect other aspects of the report type, including:\n                   &lt;br&gt;&lt;ul&gt;\n                       &lt;li&gt; Field selection and placement on the report wizard page\n                       &lt;li&gt; Fields manually added through lookups\n                       &lt;li&gt; Renamed field labels\n                   &lt;/ul&gt;&lt;br&gt;\n\n                   Proceed with change anyway?' , 'objectRemovalAlert_Header' : 'Are you sure you want to delete the object from the custom report type?' , 'yesDelete' : 'Yes, delete object'}, 
 'Page_ActivityReminder' : { 'new_flash' : '** New **' , 'popup_blocked' : 'The reminder popup was blocked.  Please disable popup blocking for this site and try again.'}, 
 'Page_BouncedEmailOverlay' : { 'bounceDate' : 'Bounce Date' , 'bounceReason' : 'Bounce Reason' , 'emailAddress' : 'Email Address' , 'makeValidButton' : 'Save and Remove Bounce Alert' , 'page_title' : 'Bounced Email'}, 
 'Page_CustomEntityDefinition_Edit' : { 'DefaultNameLabel' : '{0} Name' , 'DisplayFormatChangeWarning' : 'The new Display Format will only be applied to new records. Existing records will remain unchanged.'}, 
 'Page_EmailToSalesforceOrgSetup' : { 'whatDeactivatingWillDo1' : 'Remove Email to Salesforce activity logging.' , 'whatDeactivatingWillDo2' : 'Remove the My Email to Salesforce page for all users.'}, 
 'Page_EmailToUsers' : { 'allActiveUsers' : '&lt;All Active Salesforce Users&gt;' , 'emailBody' : '\nYour Administrator has enabled Email to Salesforce for your organization. Email to\nSalesforce allows you to automatically log emails you send from third-party email accounts as\nactivities on lead and contact records in Salesforce.\n\nFollow the link below to get started!\n{0}\n\nThank you,\n{1}\nSalesforce Administrator\n        ' , 'emailBodyLabel' : 'Message:' , 'emailSubject' : 'Your administrator has enabled Email to Salesforce!' , 'emailSubjectLabel' : 'Subject:' , 'page_title' : 'Send Notification Email to Users' , 'sendNotificationEmail' : 'Send Notification Email' , 'skipThisStep' : 'Skip This Step' , 'to' : 'To:'}, 
 'Page_My_Tabs' : { 'DefaultTabMarkerOnly' : '(default)'}, 
 'Page_ReminderSettings' : { 'day' : '{0} day' , 'days' : '{0} days' , 'hour' : '{0} hour' , 'hours' : '{0} hours' , 'hours_before' : '{0} hours before start' , 'minute' : '{0} minute' , 'minutes' : '{0} minutes' , 'minutes_before' : '{0} minutes before start' , 'overdue' : '{0} overdue'}, 
 'Page_SearchResult' : { 'dhtmlCustomizing' : 'Customizing...' , 'dhtmlFiltering' : 'Filtering...' , 'dhtmlLoading' : 'Loading...'}, 
 'Page_Task' : { 'TMU_summary' : '{0} Total Tasks' , 'TMU_summary_singular' : '1 Total Task' , 'confirmSwitchingTabs' : 'Leaving the Multiple Users tab deletes your selections. Click OK to continue and lose your selections. Click Cancel to return to the Multiple Users tab.\n\nTo add an individual user to your selections on the Multiple Users tab, select Users from the drop-down list and then search for the desired user.' , 'taskUrogNoValuesSelected' : 'Error: The Selected Members list cannot be empty.' , 'taskUrogTooManyUsersSelected' : 'The selected members exceed the maximum of {0} total users. Remove members so fewer than {0} users are included.' , 'tmuHasNoUsers' : 'No users found. The group or role you selected may be empty. Change your selection to include at least one user.'}, 
 'Paginator' : { 'clear_all_selections' : 'Clear All Selections ({0})' , 'deselect_page' : 'Deselect Page ({0})' , 'display' : 'Display' , 'first_page' : 'First Page' , 'last_page' : 'Last Page' , 'next' : 'Next' , 'next_page' : 'Next Page' , 'of' : 'of {0}' , 'page' : 'Page' , 'previous' : 'Previous' , 'previous_page' : 'Previous Page' , 'rpp' : 'records per page' , 'select_page' : 'Select Page ({0})' , 'selected' : 'Selected'}, 
 'Report' : { 'SelectAll' : 'Select All'}, 
 'Scontrol' : { 'AjaxError' : 'There was an error communicating with the server.' , 'CheckingSyntax' : 'Checking Syntax...'}, 
 'Search_Filter' : { 'too_many' : 'Your search returned more than {0} rows. Only the first {0} are displayed. Please refine search criteria.'}, 
 'SelectElement' : { 'Required' : '--None--'}, 
 'Sidebar' : { 'collapse' : 'Click to Close Sidebar [Alt+S]' , 'ellipses' : '...' , 'expand' : 'Click to Open Sidebar [Alt+S]'}, 
 'TagHeader' : { 'add_tags' : 'Add Tags' , 'auto_complete_more' : 'More...' , 'edit_tags' : 'Edit Tags' , 'no_tags' : '(No Tags)' , 'remove_tag' : 'Remove tag {0}' , 'saving' : 'Saving...' , 'server_error' : 'Your tags could not be saved because of an error contacting Salesforce.  Please try again later.' , 'server_error_edit' : 'Your tags could not be edited because of an error contacting Salesforce.  Please try again later.' , 'tag_list_more' : '({0} more)' , 'tag_list_tag_tip' : 'View records tagged {0}' , 'tag_whitespace_error' : 'Tags must contain at least one letter or number. Please try again.' , 'unknown_error' : 'Your tags could not be saved because of an unexpected error. Please try again later.'}
};
